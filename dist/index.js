// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/universalify/index.js
var require_universalify = __commonJS((exports) => {
  exports.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  exports.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  function patch(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }
    if (!fs.lutimes) {
      patchLutimes(fs);
    }
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    if (fs.chmod && !fs.lchmod) {
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchmodSync = function() {
      };
    }
    if (fs.chown && !fs.lchown) {
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    }
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs2.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs2.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs2.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs2.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs2.futimes) {
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
  var constants = import.meta.require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d3) {
      cwd = null;
      chdir.call(process, d3);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  function legacy(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== undefined) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  }
  var Stream = import.meta.require("stream").Stream;
  module.exports = legacy;
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports, module) => {
  function clone4(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
  module.exports = clone4;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  function patch(fs2) {
    polyfills(fs2);
    fs2.gracefulify = patch;
    fs2.createReadStream = createReadStream;
    fs2.createWriteStream = createWriteStream;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function go$readdir(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs2, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs2, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs2, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs2.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs2.WriteStream(path, options);
    }
    var fs$open = fs2.open;
    fs2.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs2;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
  }
  function resetQueue() {
    var now = Date.now();
    for (var i3 = 0;i3 < fs[gracefulQueue].length; ++i3) {
      if (fs[gracefulQueue][i3].length > 2) {
        fs[gracefulQueue][i3][3] = now;
        fs[gracefulQueue][i3][4] = now;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0)
      return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === undefined) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  }
  var fs = import.meta.require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone4 = require_clone();
  var util = import.meta.require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m3 = util.format.apply(util, arguments);
      m3 = "GFS4: " + m3.split(/\n/).join("\nGFS4: ");
      console.error(m3);
    };
  if (!fs[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs[gracefulQueue]);
        import.meta.require("assert").equal(fs[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
  }
  module.exports = patch(clone4(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
  }
  var retryTimer;
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS((exports) => {
  var u = require_universalify().fromCallback;
  var fs = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs[key] === "function";
  });
  Object.assign(exports, fs);
  api.forEach((method) => {
    exports[method] = u(fs[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.readv(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs.writev(fd, buffers, ...args);
    }
    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs.realpath.native === "function") {
    exports.realpath.native = u(fs.realpath.native);
  } else {
    process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  exports.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error3 = new Error(`Path contains invalid characters: ${pth}`);
        error3.code = "EINVAL";
        throw error3;
      }
    }
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports, module) => {
  var fs = require_fs();
  var { checkPath } = require_utils();
  var getMode = (options) => {
    const defaults = { mode: 511 };
    if (typeof options === "number")
      return options;
    return { ...defaults, ...options }.mode;
  };
  exports.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  exports.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var { makeDir: _makeDir, makeDirSync } = require_make_dir();
  var makeDir = u(_makeDir);
  module.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports, module) => {
  function pathExists(path) {
    return fs.access(path).then(() => true).catch(() => false);
  }
  var u = require_universalify().fromPromise;
  var fs = require_fs();
  module.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs.existsSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports, module) => {
  async function utimesMillis(path, atime, mtime) {
    const fd = await fs.open(path, "r+");
    let closeErr = null;
    try {
      await fs.futimes(fd, atime, mtime);
    } finally {
      try {
        await fs.close(fd);
      } catch (e) {
        closeErr = e;
      }
    }
    if (closeErr) {
      throw closeErr;
    }
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs.openSync(path, "r+");
    fs.futimesSync(fd, atime, mtime);
    return fs.closeSync(fd);
  }
  var fs = require_fs();
  var u = require_universalify().fromPromise;
  module.exports = {
    utimesMillis: u(utimesMillis),
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports, module) => {
  function getStats(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => fs.stat(file, { bigint: true }) : (file) => fs.lstat(file, { bigint: true });
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  }
  function getStatsSync(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file) => fs.statSync(file, { bigint: true }) : (file) => fs.lstatSync(file, { bigint: true });
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  async function checkPaths(src, dest, funcName, opts) {
    const { srcStat, destStat } = await getStats(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkPathsSync(src, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return { srcStat, destStat };
  }
  async function checkParentPaths(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = await fs.stat(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPaths(src, srcStat, destParent, funcName);
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = fs.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter((i3) => i3);
    const destArr = path.resolve(dest).split(path.sep).filter((i3) => i3);
    return srcArr.every((cur, i3) => destArr[i3] === cur);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  var fs = require_fs();
  var path = import.meta.require("path");
  var u = require_universalify().fromPromise;
  module.exports = {
    checkPaths: u(checkPaths),
    checkPathsSync,
    checkParentPaths: u(checkParentPaths),
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports, module) => {
  async function copy(src, dest, opts = {}) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
    }
    const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
    await stat.checkParentPaths(src, srcStat, dest, "copy");
    const include = await runFilter(src, dest, opts);
    if (!include)
      return;
    const destParent = path.dirname(dest);
    const dirExists = await pathExists(destParent);
    if (!dirExists) {
      await mkdirs(destParent);
    }
    await getStatsAndPerformCopy(destStat, src, dest, opts);
  }
  async function runFilter(src, dest, opts) {
    if (!opts.filter)
      return true;
    return opts.filter(src, dest);
  }
  async function getStatsAndPerformCopy(destStat, src, dest, opts) {
    const statFn = opts.dereference ? fs.stat : fs.lstat;
    const srcStat = await statFn(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  async function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    if (opts.overwrite) {
      await fs.unlink(dest);
      return copyFile(srcStat, src, dest, opts);
    }
    if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  async function copyFile(srcStat, src, dest, opts) {
    await fs.copyFile(src, dest);
    if (opts.preserveTimestamps) {
      if (fileIsNotWritable(srcStat.mode)) {
        await makeFileWritable(dest, srcStat.mode);
      }
      const updatedSrcStat = await fs.stat(src);
      await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    return fs.chmod(dest, srcStat.mode);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return fs.chmod(dest, srcMode | 128);
  }
  async function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) {
      await fs.mkdir(dest);
    }
    const items = await fs.readdir(src);
    await Promise.all(items.map(async (item) => {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      const include = await runFilter(srcItem, destItem, opts);
      if (!include)
        return;
      const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
      return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
    }));
    if (!destStat) {
      await fs.chmod(dest, srcStat.mode);
    }
  }
  async function onLink(destStat, src, dest, opts) {
    let resolvedSrc = await fs.readlink(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlink(resolvedSrc, dest);
    }
    let resolvedDest = null;
    try {
      resolvedDest = await fs.readlink(dest);
    } catch (e) {
      if (e.code === "EINVAL" || e.code === "UNKNOWN")
        return fs.symlink(resolvedSrc, dest);
      throw e;
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest);
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    await fs.unlink(dest);
    return fs.symlink(resolvedSrc, dest);
  }
  var fs = require_fs();
  var path = import.meta.require("path");
  var { mkdirs } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { utimesMillis } = require_utimes();
  var stat = require_stat();
  module.exports = copy;
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS((exports, module) => {
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
    }
    const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path.dirname(dest);
    if (!fs.existsSync(destParent))
      mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    else if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    else if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    const updatedSrcStat = fs.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    if (opts.filter && !opts.filter(srcItem, destItem))
      return;
    const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
    return getStats(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs.unlinkSync(dest);
    return fs.symlinkSync(resolvedSrc, dest);
  }
  var fs = require_graceful_fs();
  var path = import.meta.require("path");
  var mkdirsSync = require_mkdirs().mkdirsSync;
  var utimesMillisSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  module.exports = copySync;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  module.exports = {
    copy: u(require_copy()),
    copySync: require_copy_sync()
  };
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports, module) => {
  function remove(path, callback) {
    fs.rm(path, { recursive: true, force: true }, callback);
  }
  function removeSync(path) {
    fs.rmSync(path, { recursive: true, force: true });
  }
  var fs = require_graceful_fs();
  var u = require_universalify().fromCallback;
  module.exports = {
    remove: u(remove),
    removeSync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports, module) => {
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  var u = require_universalify().fromPromise;
  var fs = require_fs();
  var path = import.meta.require("path");
  var mkdir = require_mkdirs();
  var remove = require_remove();
  var emptyDir = u(async function emptyDir(dir) {
    let items;
    try {
      items = await fs.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  module.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports, module) => {
  async function createFile(file) {
    let stats;
    try {
      stats = await fs.stat(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    let dirStats = null;
    try {
      dirStats = await fs.stat(dir);
    } catch (err) {
      if (err.code === "ENOENT") {
        await mkdir.mkdirs(dir);
        await fs.writeFile(file, "");
        return;
      } else {
        throw err;
      }
    }
    if (dirStats.isDirectory()) {
      await fs.writeFile(file, "");
    } else {
      await fs.readdir(dir);
    }
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs.statSync(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path.dirname(file);
    try {
      if (!fs.statSync(dir).isDirectory()) {
        fs.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs.writeFileSync(file, "");
  }
  var u = require_universalify().fromPromise;
  var path = import.meta.require("path");
  var fs = require_fs();
  var mkdir = require_mkdirs();
  module.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports, module) => {
  async function createLink(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = await fs.lstat(dstpath);
    } catch {
    }
    let srcStat;
    try {
      srcStat = await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    if (dstStat && areIdentical(srcStat, dstStat))
      return;
    const dir = path.dirname(dstpath);
    const dirExists = await pathExists(dir);
    if (!dirExists) {
      await mkdir.mkdirs(dir);
    }
    await fs.link(srcpath, dstpath);
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs.lstatSync(dstpath);
    } catch {
    }
    try {
      const srcStat = fs.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs.existsSync(dir);
    if (dirExists)
      return fs.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs.linkSync(srcpath, dstpath);
  }
  var u = require_universalify().fromPromise;
  var path = import.meta.require("path");
  var fs = require_fs();
  var mkdir = require_mkdirs();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  module.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports, module) => {
  async function symlinkPaths(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      try {
        await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = await pathExists(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    try {
      await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  function symlinkPathsSync(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      const exists2 = fs.existsSync(srcpath);
      if (!exists2)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    const srcExists = fs.existsSync(srcpath);
    if (!srcExists)
      throw new Error("relative srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  var path = import.meta.require("path");
  var fs = require_fs();
  var { pathExists } = require_path_exists();
  var u = require_universalify().fromPromise;
  module.exports = {
    symlinkPaths: u(symlinkPaths),
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports, module) => {
  async function symlinkType(srcpath, type3) {
    if (type3)
      return type3;
    let stats;
    try {
      stats = await fs.lstat(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  function symlinkTypeSync(srcpath, type3) {
    if (type3)
      return type3;
    let stats;
    try {
      stats = fs.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  var fs = require_fs();
  var u = require_universalify().fromPromise;
  module.exports = {
    symlinkType: u(symlinkType),
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports, module) => {
  async function createSymlink(srcpath, dstpath, type3) {
    let stats;
    try {
      stats = await fs.lstat(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const [srcStat, dstStat] = await Promise.all([
        fs.stat(srcpath),
        fs.stat(dstpath)
      ]);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = await symlinkPaths(srcpath, dstpath);
    srcpath = relative.toDst;
    const toType = await symlinkType(relative.toCwd, type3);
    const dir = path.dirname(dstpath);
    if (!await pathExists(dir)) {
      await mkdirs(dir);
    }
    return fs.symlink(srcpath, dstpath, toType);
  }
  function createSymlinkSync(srcpath, dstpath, type3) {
    let stats;
    try {
      stats = fs.lstatSync(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs.statSync(srcpath);
      const dstStat = fs.statSync(dstpath);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type3 = symlinkTypeSync(relative.toCwd, type3);
    const dir = path.dirname(dstpath);
    const exists = fs.existsSync(dir);
    if (exists)
      return fs.symlinkSync(srcpath, dstpath, type3);
    mkdirsSync(dir);
    return fs.symlinkSync(srcpath, dstpath, type3);
  }
  var u = require_universalify().fromPromise;
  var path = import.meta.require("path");
  var fs = require_fs();
  var { mkdirs, mkdirsSync } = require_mkdirs();
  var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
  var { symlinkType, symlinkTypeSync } = require_symlink_type();
  var { pathExists } = require_path_exists();
  var { areIdentical } = require_stat();
  module.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports, module) => {
  var { createFile, createFileSync } = require_file();
  var { createLink, createLinkSync } = require_link();
  var { createSymlink, createSymlinkSync } = require_symlink();
  module.exports = {
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS((exports, module) => {
  function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  module.exports = { stringify, stripBom };
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports, module) => {
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  function readFileSync(file, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    await universalify.fromCallback(fs.writeFile)(file, str, options);
  }
  function writeFileSync(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    return fs.writeFileSync(file, str, options);
  }
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_) {
    _fs = import.meta.require("fs");
  }
  var universalify = require_universalify();
  var { stringify, stripBom } = require_utils2();
  var readFile = universalify.fromPromise(_readFile);
  var writeFile = universalify.fromPromise(_writeFile);
  var jsonfile = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  module.exports = jsonfile;
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports, module) => {
  var jsonFile = require_jsonfile();
  module.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS((exports, module) => {
  async function outputFile(file, data, encoding = "utf-8") {
    const dir = path.dirname(file);
    if (!await pathExists(dir)) {
      await mkdir.mkdirs(dir);
    }
    return fs.writeFile(file, data, encoding);
  }
  function outputFileSync(file, ...args) {
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs.writeFileSync(file, ...args);
  }
  var u = require_universalify().fromPromise;
  var fs = require_fs();
  var path = import.meta.require("path");
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  module.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports, module) => {
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  var { stringify } = require_utils2();
  var { outputFile } = require_output_file();
  module.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports, module) => {
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  var { stringify } = require_utils2();
  var { outputFileSync } = require_output_file();
  module.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module.exports = jsonFile;
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports, module) => {
  async function move(src, dest, opts = {}) {
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
    await stat.checkParentPaths(src, srcStat, dest, "move");
    const destParent = path.dirname(dest);
    const parsedParentPath = path.parse(destParent);
    if (parsedParentPath.root !== destParent) {
      await mkdirp(destParent);
    }
    return doRename(src, dest, overwrite, isChangingCase);
  }
  async function doRename(src, dest, overwrite, isChangingCase) {
    if (!isChangingCase) {
      if (overwrite) {
        await remove(dest);
      } else if (await pathExists(dest)) {
        throw new Error("dest already exists.");
      }
    }
    try {
      await fs.rename(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV") {
        throw err;
      }
      await moveAcrossDevice(src, dest, overwrite);
    }
  }
  async function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    await copy(src, dest, opts);
    return remove(src);
  }
  var fs = require_fs();
  var path = import.meta.require("path");
  var { copy } = require_copy2();
  var { remove } = require_remove();
  var { mkdirp } = require_mkdirs();
  var { pathExists } = require_path_exists();
  var stat = require_stat();
  module.exports = move;
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS((exports, module) => {
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    if (!isParentRoot(dest))
      mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase) {
    if (isChangingCase)
      return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  var fs = require_graceful_fs();
  var path = import.meta.require("path");
  var copySync = require_copy2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs().mkdirpSync;
  var stat = require_stat();
  module.exports = moveSync;
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports, module) => {
  var u = require_universalify().fromPromise;
  module.exports = {
    move: u(require_move()),
    moveSync: require_move_sync()
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS((exports, module) => {
  module.exports = {
    ...require_fs(),
    ...require_copy2(),
    ...require_empty(),
    ...require_ensure(),
    ...require_json(),
    ...require_mkdirs(),
    ...require_move2(),
    ...require_output_file(),
    ...require_path_exists(),
    ...require_remove()
  };
});

// node_modules/node-fetch-native-with-agent/dist/native.mjs
var exports_native = {};
__export(exports_native, {
  fetch: () => l,
  default: () => l,
  Response: () => h3,
  Request: () => t3,
  Headers: () => s,
  FormData: () => a,
  File: () => o3,
  Blob: () => e,
  AbortController: () => i3
});
var e, o3, a, s, t3, h3, i3, l;
var init_native = __esm(() => {
  e = globalThis.Blob;
  o3 = globalThis.File;
  a = globalThis.FormData;
  s = globalThis.Headers;
  t3 = globalThis.Request;
  h3 = globalThis.Response;
  i3 = globalThis.AbortController;
  l = globalThis.fetch || (() => {
    throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!");
  });
});

// node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.61758d11.cjs
var require_node_fetch_native_with_agent_61758d11 = __commonJS((exports) => {
  function getDefaultExportFromCjs(e3) {
    return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
  }
  var l3 = Object.defineProperty;
  var o4 = (e3, t4) => l3(e3, "name", { value: t4, configurable: true });
  var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  o4(getDefaultExportFromCjs, "getDefaultExportFromCjs"), exports.commonjsGlobal = commonjsGlobal, exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
});

// node_modules/node-fetch-native-with-agent/dist/shared/node-fetch-native-with-agent.df7e6bd6.cjs
var require_node_fetch_native_with_agent_df7e6bd6 = __commonJS((exports) => {
  function _interopDefaultCompat(e3) {
    return e3 && typeof e3 == "object" && "default" in e3 ? e3.default : e3;
  }
  function nop() {
  }
  function isStream$1(e3) {
    return e3 && typeof e3 == "object" && typeof e3.pipe == "function" && typeof e3.on == "function";
  }
  function isBlobLike$1(e3) {
    if (e3 === null)
      return false;
    if (e3 instanceof Blob$1)
      return true;
    if (typeof e3 != "object")
      return false;
    {
      const A = e3[Symbol.toStringTag];
      return (A === "Blob" || A === "File") && (("stream" in e3) && typeof e3.stream == "function" || ("arrayBuffer" in e3) && typeof e3.arrayBuffer == "function");
    }
  }
  function buildURL$3(e3, A) {
    if (e3.includes("?") || e3.includes("#"))
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    const t4 = stringify(A);
    return t4 && (e3 += "?" + t4), e3;
  }
  function parseURL(e3) {
    if (typeof e3 == "string") {
      if (e3 = new URL(e3), !/^https?:/.test(e3.origin || e3.protocol))
        throw new InvalidArgumentError$j("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return e3;
    }
    if (!e3 || typeof e3 != "object")
      throw new InvalidArgumentError$j("Invalid URL: The URL argument must be a non-null object.");
    if (!/^https?:/.test(e3.origin || e3.protocol))
      throw new InvalidArgumentError$j("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    if (!(e3 instanceof URL)) {
      if (e3.port != null && e3.port !== "" && !Number.isFinite(parseInt(e3.port)))
        throw new InvalidArgumentError$j("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (e3.path != null && typeof e3.path != "string")
        throw new InvalidArgumentError$j("Invalid URL path: the path must be a string or null/undefined.");
      if (e3.pathname != null && typeof e3.pathname != "string")
        throw new InvalidArgumentError$j("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (e3.hostname != null && typeof e3.hostname != "string")
        throw new InvalidArgumentError$j("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (e3.origin != null && typeof e3.origin != "string")
        throw new InvalidArgumentError$j("Invalid URL origin: the origin must be a string or null/undefined.");
      const A = e3.port != null ? e3.port : e3.protocol === "https:" ? 443 : 80;
      let t4 = e3.origin != null ? e3.origin : `${e3.protocol}//${e3.hostname}:${A}`, n3 = e3.path != null ? e3.path : `${e3.pathname || ""}${e3.search || ""}`;
      t4.endsWith("/") && (t4 = t4.substring(0, t4.length - 1)), n3 && !n3.startsWith("/") && (n3 = `/${n3}`), e3 = new URL(t4 + n3);
    }
    return e3;
  }
  function parseOrigin(e3) {
    if (e3 = parseURL(e3), e3.pathname !== "/" || e3.search || e3.hash)
      throw new InvalidArgumentError$j("invalid url");
    return e3;
  }
  function getHostname(e3) {
    if (e3[0] === "[") {
      const t4 = e3.indexOf("]");
      return assert$d(t4 !== -1), e3.substring(1, t4);
    }
    const A = e3.indexOf(":");
    return A === -1 ? e3 : e3.substring(0, A);
  }
  function getServerName$1(e3) {
    if (!e3)
      return null;
    assert$d.strictEqual(typeof e3, "string");
    const A = getHostname(e3);
    return net$2.isIP(A) ? "" : A;
  }
  function deepClone(e3) {
    return JSON.parse(JSON.stringify(e3));
  }
  function isAsyncIterable(e3) {
    return e3 != null && typeof e3[Symbol.asyncIterator] == "function";
  }
  function isIterable$1(e3) {
    return e3 != null && (typeof e3[Symbol.iterator] == "function" || typeof e3[Symbol.asyncIterator] == "function");
  }
  function bodyLength(e3) {
    if (e3 == null)
      return 0;
    if (isStream$1(e3)) {
      const A = e3._readableState;
      return A && A.objectMode === false && A.ended === true && Number.isFinite(A.length) ? A.length : null;
    } else {
      if (isBlobLike$1(e3))
        return e3.size != null ? e3.size : null;
      if (isBuffer$1(e3))
        return e3.byteLength;
    }
    return null;
  }
  function isDestroyed(e3) {
    return e3 && !!(e3.destroyed || e3[kDestroyed$1] || stream$1.isDestroyed?.(e3));
  }
  function isReadableAborted(e3) {
    const A = e3?._readableState;
    return isDestroyed(e3) && A && !A.endEmitted;
  }
  function destroy$1(e3, A) {
    e3 == null || !isStream$1(e3) || isDestroyed(e3) || (typeof e3.destroy == "function" ? (Object.getPrototypeOf(e3).constructor === IncomingMessage && (e3.socket = null), e3.destroy(A)) : A && queueMicrotask(() => {
      e3.emit("error", A);
    }), e3.destroyed !== true && (e3[kDestroyed$1] = true));
  }
  function parseKeepAliveTimeout(e3) {
    const A = e3.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return A ? parseInt(A[1], 10) * 1000 : null;
  }
  function headerNameToString(e3) {
    return typeof e3 == "string" ? headerNameLowerCasedRecord$1[e3] ?? e3.toLowerCase() : tree.lookup(e3) ?? e3.toString("latin1").toLowerCase();
  }
  function bufferToLowerCasedHeaderName(e3) {
    return tree.lookup(e3) ?? e3.toString("latin1").toLowerCase();
  }
  function parseHeaders(e3, A) {
    A === undefined && (A = {});
    for (let t4 = 0;t4 < e3.length; t4 += 2) {
      const n3 = headerNameToString(e3[t4]);
      let r = A[n3];
      if (r)
        typeof r == "string" && (r = [r], A[n3] = r), r.push(e3[t4 + 1].toString("utf8"));
      else {
        const s3 = e3[t4 + 1];
        typeof s3 == "string" ? A[n3] = s3 : A[n3] = Array.isArray(s3) ? s3.map((i4) => i4.toString("utf8")) : s3.toString("utf8");
      }
    }
    return "content-length" in A && "content-disposition" in A && (A["content-disposition"] = Buffer.from(A["content-disposition"]).toString("latin1")), A;
  }
  function parseRawHeaders(e3) {
    const A = e3.length, t4 = new Array(A);
    let n3 = false, r = -1, s3, i4, E4 = 0;
    for (let Q = 0;Q < e3.length; Q += 2)
      s3 = e3[Q], i4 = e3[Q + 1], typeof s3 != "string" && (s3 = s3.toString()), typeof i4 != "string" && (i4 = i4.toString("utf8")), E4 = s3.length, E4 === 14 && s3[7] === "-" && (s3 === "content-length" || s3.toLowerCase() === "content-length") ? n3 = true : E4 === 19 && s3[7] === "-" && (s3 === "content-disposition" || s3.toLowerCase() === "content-disposition") && (r = Q + 1), t4[Q] = s3, t4[Q + 1] = i4;
    return n3 && r !== -1 && (t4[r] = Buffer.from(t4[r]).toString("latin1")), t4;
  }
  function isBuffer$1(e3) {
    return e3 instanceof Uint8Array || Buffer.isBuffer(e3);
  }
  function validateHandler$1(e3, A, t4) {
    if (!e3 || typeof e3 != "object")
      throw new InvalidArgumentError$j("handler must be an object");
    if (typeof e3.onConnect != "function")
      throw new InvalidArgumentError$j("invalid onConnect method");
    if (typeof e3.onError != "function")
      throw new InvalidArgumentError$j("invalid onError method");
    if (typeof e3.onBodySent != "function" && e3.onBodySent !== undefined)
      throw new InvalidArgumentError$j("invalid onBodySent method");
    if (t4 || A === "CONNECT") {
      if (typeof e3.onUpgrade != "function")
        throw new InvalidArgumentError$j("invalid onUpgrade method");
    } else {
      if (typeof e3.onHeaders != "function")
        throw new InvalidArgumentError$j("invalid onHeaders method");
      if (typeof e3.onData != "function")
        throw new InvalidArgumentError$j("invalid onData method");
      if (typeof e3.onComplete != "function")
        throw new InvalidArgumentError$j("invalid onComplete method");
    }
  }
  function isDisturbed(e3) {
    return !!(e3 && (stream$1.isDisturbed(e3) || e3[kBodyUsed$1]));
  }
  function isErrored(e3) {
    return !!(e3 && stream$1.isErrored(e3));
  }
  function isReadable(e3) {
    return !!(e3 && stream$1.isReadable(e3));
  }
  function getSocketInfo(e3) {
    return { localAddress: e3.localAddress, localPort: e3.localPort, remoteAddress: e3.remoteAddress, remotePort: e3.remotePort, remoteFamily: e3.remoteFamily, timeout: e3.timeout, bytesWritten: e3.bytesWritten, bytesRead: e3.bytesRead };
  }
  function ReadableStreamFrom$1(e3) {
    let A;
    return new ReadableStream({ async start() {
      A = e3[Symbol.asyncIterator]();
    }, async pull(t4) {
      const { done: n3, value: r } = await A.next();
      if (n3)
        queueMicrotask(() => {
          t4.close(), t4.byobRequest?.respond(0);
        });
      else {
        const s3 = Buffer.isBuffer(r) ? r : Buffer.from(r);
        s3.byteLength && t4.enqueue(new Uint8Array(s3));
      }
      return t4.desiredSize > 0;
    }, async cancel(t4) {
      await A.return();
    }, type: "bytes" });
  }
  function isFormDataLike$1(e3) {
    return e3 && typeof e3 == "object" && typeof e3.append == "function" && typeof e3.delete == "function" && typeof e3.get == "function" && typeof e3.getAll == "function" && typeof e3.has == "function" && typeof e3.set == "function" && e3[Symbol.toStringTag] === "FormData";
  }
  function addAbortListener$1(e3, A) {
    return "addEventListener" in e3 ? (e3.addEventListener("abort", A, { once: true }), () => e3.removeEventListener("abort", A)) : (e3.addListener("abort", A), () => e3.removeListener("abort", A));
  }
  function toUSVString(e3) {
    return hasToWellFormed ? `${e3}`.toWellFormed() : nodeUtil.toUSVString(e3);
  }
  function isUSVString(e3) {
    return hasIsWellFormed ? `${e3}`.isWellFormed() : toUSVString(e3) === `${e3}`;
  }
  function isTokenCharCode(e3) {
    switch (e3) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return e3 >= 33 && e3 <= 126;
    }
  }
  function isValidHTTPToken$1(e3) {
    if (e3.length === 0)
      return false;
    for (let A = 0;A < e3.length; ++A)
      if (!isTokenCharCode(e3.charCodeAt(A)))
        return false;
    return true;
  }
  function isValidHeaderChar$1(e3) {
    return !headerCharRegex.test(e3);
  }
  function parseRangeHeader(e3) {
    if (e3 == null || e3 === "")
      return { start: 0, end: null, size: null };
    const A = e3 ? e3.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return A ? { start: parseInt(A[1]), end: A[2] ? parseInt(A[2]) : null, size: A[3] ? parseInt(A[3]) : null } : null;
  }
  function addListener$1(e3, A, t4) {
    return (e3[kListeners] ?? (e3[kListeners] = [])).push([A, t4]), e3.on(A, t4), e3;
  }
  function removeAllListeners$1(e3) {
    for (const [A, t4] of e3[kListeners] ?? [])
      e3.removeListener(A, t4);
    e3[kListeners] = null;
  }
  function errorRequest(e3, A, t4) {
    try {
      A.onError(t4), assert$d(A.aborted);
    } catch (n3) {
      e3.emit("error", n3);
    }
  }
  function processHeader(e3, A, t4) {
    if (t4 && typeof t4 == "object" && !Array.isArray(t4))
      throw new InvalidArgumentError$i(`invalid ${A} header`);
    if (t4 === undefined)
      return;
    let n3 = headerNameLowerCasedRecord[A];
    if (n3 === undefined && (n3 = A.toLowerCase(), headerNameLowerCasedRecord[n3] === undefined && !isValidHTTPToken(n3)))
      throw new InvalidArgumentError$i("invalid header key");
    if (Array.isArray(t4)) {
      const r = [];
      for (let s3 = 0;s3 < t4.length; s3++)
        if (typeof t4[s3] == "string") {
          if (!isValidHeaderChar(t4[s3]))
            throw new InvalidArgumentError$i(`invalid ${A} header`);
          r.push(t4[s3]);
        } else if (t4[s3] === null)
          r.push("");
        else {
          if (typeof t4[s3] == "object")
            throw new InvalidArgumentError$i(`invalid ${A} header`);
          r.push(`${t4[s3]}`);
        }
      t4 = r;
    } else if (typeof t4 == "string") {
      if (!isValidHeaderChar(t4))
        throw new InvalidArgumentError$i(`invalid ${A} header`);
    } else if (t4 === null)
      t4 = "";
    else {
      if (typeof t4 == "object")
        throw new InvalidArgumentError$i(`invalid ${A} header`);
      t4 = `${t4}`;
    }
    if (e3.host === null && n3 === "host") {
      if (typeof t4 != "string")
        throw new InvalidArgumentError$i("invalid host header");
      e3.host = t4;
    } else if (e3.contentLength === null && n3 === "content-length") {
      if (e3.contentLength = parseInt(t4, 10), !Number.isFinite(e3.contentLength))
        throw new InvalidArgumentError$i("invalid content-length header");
    } else if (e3.contentType === null && n3 === "content-type")
      e3.contentType = t4, e3.headers.push(A, t4);
    else {
      if (n3 === "transfer-encoding" || n3 === "keep-alive" || n3 === "upgrade")
        throw new InvalidArgumentError$i(`invalid ${n3} header`);
      if (n3 === "connection") {
        const r = typeof t4 == "string" ? t4.toLowerCase() : null;
        if (r !== "close" && r !== "keep-alive")
          throw new InvalidArgumentError$i("invalid connection header");
        r === "close" && (e3.reset = true);
      } else {
        if (n3 === "expect")
          throw new NotSupportedError$1("expect header not supported");
        e3.headers.push(A, t4);
      }
    }
  }
  function buildConnector$3({ allowH2: e3, maxCachedSessions: A, socketPath: t4, timeout: n3, ...r }) {
    if (A != null && (!Number.isInteger(A) || A < 0))
      throw new InvalidArgumentError$g("maxCachedSessions must be a positive integer or zero");
    const s3 = { path: t4, ...r }, i4 = new SessionCache(A ?? 100);
    return n3 = n3 ?? 1e4, e3 = e3 ?? false, o4(function({ hostname: Q, host: C, protocol: I, port: a3, servername: f3, localAddress: h4, httpSocket: L }, c3) {
      let l3;
      if (I === "https:") {
        tls || (tls = require$$4__default$1), f3 = f3 || s3.servername || util$k.getServerName(C) || null;
        const k3 = f3 || Q, w = i4.get(k3) || null;
        assert$b(k3), l3 = tls.connect({ highWaterMark: 16384, ...s3, servername: f3, session: w, localAddress: h4, ALPNProtocols: e3 ? ["http/1.1", "h2"] : ["http/1.1"], socket: L, port: a3 || 443, host: Q }), l3.on("session", function(U) {
          i4.set(k3, U);
        });
      } else
        assert$b(!L, "httpSocket can only be sent on TLS update"), l3 = net$1.connect({ highWaterMark: 64 * 1024, ...s3, localAddress: h4, port: a3 || 80, host: Q });
      if (s3.keepAlive == null || s3.keepAlive) {
        const k3 = s3.keepAliveInitialDelay === undefined ? 60000 : s3.keepAliveInitialDelay;
        l3.setKeepAlive(true, k3);
      }
      const S = setupTimeout(() => onConnectTimeout(l3), n3);
      return l3.setNoDelay(true).once(I === "https:" ? "secureConnect" : "connect", function() {
        if (S(), c3) {
          const k3 = c3;
          c3 = null, k3(null, this);
        }
      }).on("error", function(k3) {
        if (S(), c3) {
          const w = c3;
          c3 = null, w(k3);
        }
      }), l3;
    }, "connect");
  }
  function setupTimeout(e3, A) {
    if (!A)
      return () => {
      };
    let t4 = null, n3 = null;
    const r = setTimeout(() => {
      t4 = setImmediate(() => {
        process.platform === "win32" ? n3 = setImmediate(() => e3()) : e3();
      });
    }, A);
    return () => {
      clearTimeout(r), clearImmediate(t4), clearImmediate(n3);
    };
  }
  function onConnectTimeout(e3) {
    let A = "Connect Timeout Error";
    Array.isArray(e3.autoSelectFamilyAttemptedAddresses) && (A += ` (attempted addresses: ${e3.autoSelectFamilyAttemptedAddresses.join(", ")})`), util$k.destroy(e3, new ConnectTimeoutError(A));
  }
  function onTimeout() {
    fastNow = Date.now();
    let e3 = fastTimers.length, A = 0;
    for (;A < e3; ) {
      const t4 = fastTimers[A];
      t4.state === 0 ? t4.state = fastNow + t4.delay : t4.state > 0 && fastNow >= t4.state && (t4.state = -1, t4.callback(t4.opaque)), t4.state === -1 ? (t4.state = -2, A !== e3 - 1 ? fastTimers[A] = fastTimers.pop() : fastTimers.pop(), e3 -= 1) : A += 1;
    }
    fastTimers.length > 0 && refreshTimeout();
  }
  function refreshTimeout() {
    fastNowTimeout?.refresh ? fastNowTimeout.refresh() : (clearTimeout(fastNowTimeout), fastNowTimeout = setTimeout(onTimeout, 1000), fastNowTimeout.unref && fastNowTimeout.unref());
  }
  function enumToMap(e3) {
    const A = {};
    return Object.keys(e3).forEach((t4) => {
      const n3 = e3[t4];
      typeof n3 == "number" && (A[t4] = n3);
    }), A;
  }
  function requireLlhttpWasm() {
    if (hasRequiredLlhttpWasm)
      return llhttpWasm;
    hasRequiredLlhttpWasm = 1;
    const { Buffer: e3 } = require$$6__default;
    return llhttpWasm = e3.from("AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=", "base64"), llhttpWasm;
  }
  function requireLlhttp_simdWasm() {
    if (hasRequiredLlhttp_simdWasm)
      return llhttp_simdWasm;
    hasRequiredLlhttp_simdWasm = 1;
    const { Buffer: e3 } = require$$6__default;
    return llhttp_simdWasm = e3.from("AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64"), llhttp_simdWasm;
  }
  function requireConstants$2() {
    if (hasRequiredConstants$2)
      return constants$3;
    hasRequiredConstants$2 = 1;
    const e3 = ["GET", "HEAD", "POST"], A = new Set(e3), t4 = [101, 204, 205, 304], n3 = [301, 302, 303, 307, 308], r = new Set(n3), s3 = ["1", "7", "9", "11", "13", "15", "17", "19", "20", "21", "22", "23", "25", "37", "42", "43", "53", "69", "77", "79", "87", "95", "101", "102", "103", "104", "109", "110", "111", "113", "115", "117", "119", "123", "135", "137", "139", "143", "161", "179", "389", "427", "465", "512", "513", "514", "515", "526", "530", "531", "532", "540", "548", "554", "556", "563", "587", "601", "636", "989", "990", "993", "995", "1719", "1720", "1723", "2049", "3659", "4045", "4190", "5060", "5061", "6000", "6566", "6665", "6666", "6667", "6668", "6669", "6679", "6697", "10080"], i4 = new Set(s3), E4 = ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"], Q = new Set(E4), C = ["follow", "manual", "error"], I = ["GET", "HEAD", "OPTIONS", "TRACE"], a3 = new Set(I), f3 = ["navigate", "same-origin", "no-cors", "cors"], h4 = ["omit", "same-origin", "include"], L = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"], c3 = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], l3 = ["half"], S = ["CONNECT", "TRACE", "TRACK"], k3 = new Set(S), w = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""], U = new Set(w);
    return constants$3 = { subresource: w, forbiddenMethods: S, requestBodyHeader: c3, referrerPolicy: E4, requestRedirect: C, requestMode: f3, requestCredentials: h4, requestCache: L, redirectStatus: n3, corsSafeListedMethods: e3, nullBodyStatus: t4, safeMethods: I, badPorts: s3, requestDuplex: l3, subresourceSet: U, badPortsSet: i4, redirectStatusSet: r, corsSafeListedMethodsSet: A, safeMethodsSet: a3, forbiddenMethodsSet: k3, referrerPolicySet: Q }, constants$3;
  }
  function requireGlobal() {
    if (hasRequiredGlobal)
      return global$1;
    hasRequiredGlobal = 1;
    const e3 = Symbol.for("undici.globalOrigin.1");
    function A() {
      return globalThis[e3];
    }
    o4(A, "getGlobalOrigin");
    function t4(n3) {
      if (n3 === undefined) {
        Object.defineProperty(globalThis, e3, { value: undefined, writable: true, enumerable: false, configurable: false });
        return;
      }
      const r = new URL(n3);
      if (r.protocol !== "http:" && r.protocol !== "https:")
        throw new TypeError(`Only http & https urls are allowed, received ${r.protocol}`);
      Object.defineProperty(globalThis, e3, { value: r, writable: true, enumerable: false, configurable: false });
    }
    return o4(t4, "setGlobalOrigin"), global$1 = { getGlobalOrigin: A, setGlobalOrigin: t4 }, global$1;
  }
  function requireDataUrl() {
    if (hasRequiredDataUrl)
      return dataUrl;
    hasRequiredDataUrl = 1;
    const e3 = require$$0__default, A = new TextEncoder, t4 = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, n3 = /[\u000A\u000D\u0009\u0020]/, r = /[\u0009\u000A\u000C\u000D\u0020]/g, s3 = /[\u0009\u0020-\u007E\u0080-\u00FF]/;
    function i4(g3) {
      e3(g3.protocol === "data:");
      let d3 = E4(g3, true);
      d3 = d3.slice(5);
      const F = { position: 0 };
      let N = C(",", d3, F);
      const u = N.length;
      if (N = M(N, true, true), F.position >= d3.length)
        return "failure";
      F.position++;
      const b = d3.slice(u + 1);
      let m3 = I(b);
      if (/;(\u0020){0,}base64$/i.test(N)) {
        const v3 = D(m3);
        if (m3 = c3(v3), m3 === "failure")
          return "failure";
        N = N.slice(0, -6), N = N.replace(/(\u0020)+$/, ""), N = N.slice(0, -1);
      }
      N.startsWith(";") && (N = "text/plain" + N);
      let T = L(N);
      return T === "failure" && (T = L("text/plain;charset=US-ASCII")), { mimeType: T, body: m3 };
    }
    o4(i4, "dataURLProcessor");
    function E4(g3, d3 = false) {
      if (!d3)
        return g3.href;
      const F = g3.href, N = g3.hash.length, u = N === 0 ? F : F.substring(0, F.length - N);
      return !N && F.endsWith("#") ? u.slice(0, -1) : u;
    }
    o4(E4, "URLSerializer");
    function Q(g3, d3, F) {
      let N = "";
      for (;F.position < d3.length && g3(d3[F.position]); )
        N += d3[F.position], F.position++;
      return N;
    }
    o4(Q, "collectASequenceOfCodePoints");
    function C(g3, d3, F) {
      const N = d3.indexOf(g3, F.position), u = F.position;
      return N === -1 ? (F.position = d3.length, d3.slice(u)) : (F.position = N, d3.slice(u, F.position));
    }
    o4(C, "collectASequenceOfCodePointsFast");
    function I(g3) {
      const d3 = A.encode(g3);
      return h4(d3);
    }
    o4(I, "stringPercentDecode");
    function a3(g3) {
      return g3 >= 48 && g3 <= 57 || g3 >= 65 && g3 <= 70 || g3 >= 97 && g3 <= 102;
    }
    o4(a3, "isHexCharByte");
    function f3(g3) {
      return g3 >= 48 && g3 <= 57 ? g3 - 48 : (g3 & 223) - 55;
    }
    o4(f3, "hexByteToNumber");
    function h4(g3) {
      const d3 = g3.length, F = new Uint8Array(d3);
      let N = 0;
      for (let u = 0;u < d3; ++u) {
        const b = g3[u];
        b !== 37 ? F[N++] = b : b === 37 && !(a3(g3[u + 1]) && a3(g3[u + 2])) ? F[N++] = 37 : (F[N++] = f3(g3[u + 1]) << 4 | f3(g3[u + 2]), u += 2);
      }
      return d3 === N ? F : F.subarray(0, N);
    }
    o4(h4, "percentDecode");
    function L(g3) {
      g3 = w(g3, true, true);
      const d3 = { position: 0 }, F = C("/", g3, d3);
      if (F.length === 0 || !t4.test(F) || d3.position > g3.length)
        return "failure";
      d3.position++;
      let N = C(";", g3, d3);
      if (N = w(N, false, true), N.length === 0 || !t4.test(N))
        return "failure";
      const u = F.toLowerCase(), b = N.toLowerCase(), m3 = { type: u, subtype: b, parameters: new Map, essence: `${u}/${b}` };
      for (;d3.position < g3.length; ) {
        d3.position++, Q((Z) => n3.test(Z), g3, d3);
        let T = Q((Z) => Z !== ";" && Z !== "=", g3, d3);
        if (T = T.toLowerCase(), d3.position < g3.length) {
          if (g3[d3.position] === ";")
            continue;
          d3.position++;
        }
        if (d3.position > g3.length)
          break;
        let v3 = null;
        if (g3[d3.position] === '"')
          v3 = l3(g3, d3, true), C(";", g3, d3);
        else if (v3 = C(";", g3, d3), v3 = w(v3, false, true), v3.length === 0)
          continue;
        T.length !== 0 && t4.test(T) && (v3.length === 0 || s3.test(v3)) && !m3.parameters.has(T) && m3.parameters.set(T, v3);
      }
      return m3;
    }
    o4(L, "parseMIMEType");
    function c3(g3) {
      g3 = g3.replace(r, "");
      let d3 = g3.length;
      if (d3 % 4 === 0 && g3.charCodeAt(d3 - 1) === 61 && (--d3, g3.charCodeAt(d3 - 1) === 61 && --d3), d3 % 4 === 1 || /[^+/0-9A-Za-z]/.test(g3.length === d3 ? g3 : g3.substring(0, d3)))
        return "failure";
      const F = Buffer.from(g3, "base64");
      return new Uint8Array(F.buffer, F.byteOffset, F.byteLength);
    }
    o4(c3, "forgivingBase64");
    function l3(g3, d3, F) {
      const N = d3.position;
      let u = "";
      for (e3(g3[d3.position] === '"'), d3.position++;u += Q((m3) => m3 !== '"' && m3 !== "\\", g3, d3), !(d3.position >= g3.length); ) {
        const b = g3[d3.position];
        if (d3.position++, b === "\\") {
          if (d3.position >= g3.length) {
            u += "\\";
            break;
          }
          u += g3[d3.position], d3.position++;
        } else {
          e3(b === '"');
          break;
        }
      }
      return F ? u : g3.slice(N, d3.position);
    }
    o4(l3, "collectAnHTTPQuotedString");
    function S(g3) {
      e3(g3 !== "failure");
      const { parameters: d3, essence: F } = g3;
      let N = F;
      for (let [u, b] of d3.entries())
        N += ";", N += u, N += "=", t4.test(b) || (b = b.replace(/(\\|")/g, "\\$1"), b = '"' + b, b += '"'), N += b;
      return N;
    }
    o4(S, "serializeAMimeType");
    function k3(g3) {
      return g3 === 13 || g3 === 10 || g3 === 9 || g3 === 32;
    }
    o4(k3, "isHTTPWhiteSpace");
    function w(g3, d3 = true, F = true) {
      return B(g3, d3, F, k3);
    }
    o4(w, "removeHTTPWhitespace");
    function U(g3) {
      return g3 === 13 || g3 === 10 || g3 === 9 || g3 === 12 || g3 === 32;
    }
    o4(U, "isASCIIWhitespace");
    function M(g3, d3 = true, F = true) {
      return B(g3, d3, F, U);
    }
    o4(M, "removeASCIIWhitespace");
    function B(g3, d3, F, N) {
      let u = 0, b = g3.length - 1;
      if (d3)
        for (;u < g3.length && N(g3.charCodeAt(u)); )
          u++;
      if (F)
        for (;b > 0 && N(g3.charCodeAt(b)); )
          b--;
      return u === 0 && b === g3.length - 1 ? g3 : g3.slice(u, b + 1);
    }
    o4(B, "removeChars");
    function D(g3) {
      const d3 = g3.length;
      if (65535 > d3)
        return String.fromCharCode.apply(null, g3);
      let F = "", N = 0, u = 65535;
      for (;N < d3; )
        N + u > d3 && (u = d3 - N), F += String.fromCharCode.apply(null, g3.subarray(N, N += u));
      return F;
    }
    o4(D, "isomorphicDecode");
    function G(g3) {
      switch (g3.essence) {
        case "application/ecmascript":
        case "application/javascript":
        case "application/x-ecmascript":
        case "application/x-javascript":
        case "text/ecmascript":
        case "text/javascript":
        case "text/javascript1.0":
        case "text/javascript1.1":
        case "text/javascript1.2":
        case "text/javascript1.3":
        case "text/javascript1.4":
        case "text/javascript1.5":
        case "text/jscript":
        case "text/livescript":
        case "text/x-ecmascript":
        case "text/x-javascript":
          return "text/javascript";
        case "application/json":
        case "text/json":
          return "application/json";
        case "image/svg+xml":
          return "image/svg+xml";
        case "text/xml":
        case "application/xml":
          return "application/xml";
      }
      return g3.subtype.endsWith("+json") ? "application/json" : g3.subtype.endsWith("+xml") ? "application/xml" : "";
    }
    return o4(G, "minimizeSupportedMimeType"), dataUrl = { dataURLProcessor: i4, URLSerializer: E4, collectASequenceOfCodePoints: Q, collectASequenceOfCodePointsFast: C, stringPercentDecode: I, parseMIMEType: L, collectAnHTTPQuotedString: l3, serializeAMimeType: S, removeChars: B, minimizeSupportedMimeType: G, HTTP_TOKEN_CODEPOINTS: t4, isomorphicDecode: D }, dataUrl;
  }
  function requireWebidl() {
    if (hasRequiredWebidl)
      return webidl_1;
    hasRequiredWebidl = 1;
    const { types: e3, inspect: A } = require$$0__default$1, { toUSVString: t4 } = util$m, n3 = {};
    return n3.converters = {}, n3.util = {}, n3.errors = {}, n3.errors.exception = function(r) {
      return new TypeError(`${r.header}: ${r.message}`);
    }, n3.errors.conversionFailed = function(r) {
      const s3 = r.types.length === 1 ? "" : " one of", i4 = `${r.argument} could not be converted to${s3}: ${r.types.join(", ")}.`;
      return n3.errors.exception({ header: r.prefix, message: i4 });
    }, n3.errors.invalidArgument = function(r) {
      return n3.errors.exception({ header: r.prefix, message: `"${r.value}" is an invalid ${r.type}.` });
    }, n3.brandCheck = function(r, s3, i4 = undefined) {
      if (i4?.strict !== false) {
        if (!(r instanceof s3))
          throw new TypeError("Illegal invocation");
      } else if (r?.[Symbol.toStringTag] !== s3.prototype[Symbol.toStringTag])
        throw new TypeError("Illegal invocation");
    }, n3.argumentLengthCheck = function({ length: r }, s3, i4) {
      if (r < s3)
        throw n3.errors.exception({ message: `${s3} argument${s3 !== 1 ? "s" : ""} required, but${r ? " only" : ""} ${r} found.`, ...i4 });
    }, n3.illegalConstructor = function() {
      throw n3.errors.exception({ header: "TypeError", message: "Illegal constructor" });
    }, n3.util.Type = function(r) {
      switch (typeof r) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object":
          return r === null ? "Null" : "Object";
      }
    }, n3.util.ConvertToInt = function(r, s3, i4, E4 = {}) {
      let Q, C;
      s3 === 64 ? (Q = Math.pow(2, 53) - 1, i4 === "unsigned" ? C = 0 : C = Math.pow(-2, 53) + 1) : i4 === "unsigned" ? (C = 0, Q = Math.pow(2, s3) - 1) : (C = Math.pow(-2, s3) - 1, Q = Math.pow(2, s3 - 1) - 1);
      let I = Number(r);
      if (I === 0 && (I = 0), E4.enforceRange === true) {
        if (Number.isNaN(I) || I === Number.POSITIVE_INFINITY || I === Number.NEGATIVE_INFINITY)
          throw n3.errors.exception({ header: "Integer conversion", message: `Could not convert ${n3.util.Stringify(r)} to an integer.` });
        if (I = n3.util.IntegerPart(I), I < C || I > Q)
          throw n3.errors.exception({ header: "Integer conversion", message: `Value must be between ${C}-${Q}, got ${I}.` });
        return I;
      }
      return !Number.isNaN(I) && E4.clamp === true ? (I = Math.min(Math.max(I, C), Q), Math.floor(I) % 2 === 0 ? I = Math.floor(I) : I = Math.ceil(I), I) : Number.isNaN(I) || I === 0 && Object.is(0, I) || I === Number.POSITIVE_INFINITY || I === Number.NEGATIVE_INFINITY ? 0 : (I = n3.util.IntegerPart(I), I = I % Math.pow(2, s3), i4 === "signed" && I >= Math.pow(2, s3) - 1 ? I - Math.pow(2, s3) : I);
    }, n3.util.IntegerPart = function(r) {
      const s3 = Math.floor(Math.abs(r));
      return r < 0 ? -1 * s3 : s3;
    }, n3.util.Stringify = function(r) {
      switch (n3.util.Type(r)) {
        case "Symbol":
          return `Symbol(${r.description})`;
        case "Object":
          return A(r);
        case "String":
          return `"${r}"`;
        default:
          return `${r}`;
      }
    }, n3.sequenceConverter = function(r) {
      return (s3, i4) => {
        if (n3.util.Type(s3) !== "Object")
          throw n3.errors.exception({ header: "Sequence", message: `Value of type ${n3.util.Type(s3)} is not an Object.` });
        const E4 = typeof i4 == "function" ? i4() : s3?.[Symbol.iterator]?.(), Q = [];
        if (E4 === undefined || typeof E4.next != "function")
          throw n3.errors.exception({ header: "Sequence", message: "Object is not an iterator." });
        for (;; ) {
          const { done: C, value: I } = E4.next();
          if (C)
            break;
          Q.push(r(I));
        }
        return Q;
      };
    }, n3.recordConverter = function(r, s3) {
      return (i4) => {
        if (n3.util.Type(i4) !== "Object")
          throw n3.errors.exception({ header: "Record", message: `Value of type ${n3.util.Type(i4)} is not an Object.` });
        const E4 = {};
        if (!e3.isProxy(i4)) {
          const C = [...Object.getOwnPropertyNames(i4), ...Object.getOwnPropertySymbols(i4)];
          for (const I of C) {
            const a3 = r(I), f3 = s3(i4[I]);
            E4[a3] = f3;
          }
          return E4;
        }
        const Q = Reflect.ownKeys(i4);
        for (const C of Q)
          if (Reflect.getOwnPropertyDescriptor(i4, C)?.enumerable) {
            const a3 = r(C), f3 = s3(i4[C]);
            E4[a3] = f3;
          }
        return E4;
      };
    }, n3.interfaceConverter = function(r) {
      return (s3, i4 = {}) => {
        if (i4.strict !== false && !(s3 instanceof r))
          throw n3.errors.exception({ header: r.name, message: `Expected ${n3.util.Stringify(s3)} to be an instance of ${r.name}.` });
        return s3;
      };
    }, n3.dictionaryConverter = function(r) {
      return (s3) => {
        const i4 = n3.util.Type(s3), E4 = {};
        if (i4 === "Null" || i4 === "Undefined")
          return E4;
        if (i4 !== "Object")
          throw n3.errors.exception({ header: "Dictionary", message: `Expected ${s3} to be one of: Null, Undefined, Object.` });
        for (const Q of r) {
          const { key: C, defaultValue: I, required: a3, converter: f3 } = Q;
          if (a3 === true && !Object.hasOwn(s3, C))
            throw n3.errors.exception({ header: "Dictionary", message: `Missing required key "${C}".` });
          let h4 = s3[C];
          const L = Object.hasOwn(Q, "defaultValue");
          if (L && h4 !== null && (h4 = h4 ?? I), a3 || L || h4 !== undefined) {
            if (h4 = f3(h4), Q.allowedValues && !Q.allowedValues.includes(h4))
              throw n3.errors.exception({ header: "Dictionary", message: `${h4} is not an accepted type. Expected one of ${Q.allowedValues.join(", ")}.` });
            E4[C] = h4;
          }
        }
        return E4;
      };
    }, n3.nullableConverter = function(r) {
      return (s3) => s3 === null ? s3 : r(s3);
    }, n3.converters.DOMString = function(r, s3 = {}) {
      if (r === null && s3.legacyNullToEmptyString)
        return "";
      if (typeof r == "symbol")
        throw new TypeError("Could not convert argument of type symbol to string.");
      return String(r);
    }, n3.converters.ByteString = function(r) {
      const s3 = n3.converters.DOMString(r);
      for (let i4 = 0;i4 < s3.length; i4++)
        if (s3.charCodeAt(i4) > 255)
          throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${i4} has a value of ${s3.charCodeAt(i4)} which is greater than 255.`);
      return s3;
    }, n3.converters.USVString = t4, n3.converters.boolean = function(r) {
      return !!r;
    }, n3.converters.any = function(r) {
      return r;
    }, n3.converters["long long"] = function(r) {
      return n3.util.ConvertToInt(r, 64, "signed");
    }, n3.converters["unsigned long long"] = function(r) {
      return n3.util.ConvertToInt(r, 64, "unsigned");
    }, n3.converters["unsigned long"] = function(r) {
      return n3.util.ConvertToInt(r, 32, "unsigned");
    }, n3.converters["unsigned short"] = function(r, s3) {
      return n3.util.ConvertToInt(r, 16, "unsigned", s3);
    }, n3.converters.ArrayBuffer = function(r, s3 = {}) {
      if (n3.util.Type(r) !== "Object" || !e3.isAnyArrayBuffer(r))
        throw n3.errors.conversionFailed({ prefix: n3.util.Stringify(r), argument: n3.util.Stringify(r), types: ["ArrayBuffer"] });
      if (s3.allowShared === false && e3.isSharedArrayBuffer(r))
        throw n3.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      if (r.resizable || r.growable)
        throw n3.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
      return r;
    }, n3.converters.TypedArray = function(r, s3, i4 = {}) {
      if (n3.util.Type(r) !== "Object" || !e3.isTypedArray(r) || r.constructor.name !== s3.name)
        throw n3.errors.conversionFailed({ prefix: `${s3.name}`, argument: n3.util.Stringify(r), types: [s3.name] });
      if (i4.allowShared === false && e3.isSharedArrayBuffer(r.buffer))
        throw n3.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      if (r.buffer.resizable || r.buffer.growable)
        throw n3.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
      return r;
    }, n3.converters.DataView = function(r, s3 = {}) {
      if (n3.util.Type(r) !== "Object" || !e3.isDataView(r))
        throw n3.errors.exception({ header: "DataView", message: "Object is not a DataView." });
      if (s3.allowShared === false && e3.isSharedArrayBuffer(r.buffer))
        throw n3.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      if (r.buffer.resizable || r.buffer.growable)
        throw n3.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
      return r;
    }, n3.converters.BufferSource = function(r, s3 = {}) {
      if (e3.isAnyArrayBuffer(r))
        return n3.converters.ArrayBuffer(r, { ...s3, allowShared: false });
      if (e3.isTypedArray(r))
        return n3.converters.TypedArray(r, r.constructor, { ...s3, allowShared: false });
      if (e3.isDataView(r))
        return n3.converters.DataView(r, s3, { ...s3, allowShared: false });
      throw new TypeError(`Could not convert ${n3.util.Stringify(r)} to a BufferSource.`);
    }, n3.converters["sequence<ByteString>"] = n3.sequenceConverter(n3.converters.ByteString), n3.converters["sequence<sequence<ByteString>>"] = n3.sequenceConverter(n3.converters["sequence<ByteString>"]), n3.converters["record<ByteString, ByteString>"] = n3.recordConverter(n3.converters.ByteString, n3.converters.ByteString), webidl_1 = { webidl: n3 }, webidl_1;
  }
  function requireUtil$5() {
    if (hasRequiredUtil$5)
      return util$j;
    hasRequiredUtil$5 = 1;
    const { Transform: e3 } = Stream__default, A = zlib__default, { redirectStatusSet: t4, referrerPolicySet: n3, badPortsSet: r } = requireConstants$2(), { getGlobalOrigin: s3 } = requireGlobal(), { collectASequenceOfCodePoints: i4, collectAnHTTPQuotedString: E4, removeChars: Q, parseMIMEType: C } = requireDataUrl(), { performance: I } = require$$5__default, { isBlobLike: a3, ReadableStreamFrom: f3, isValidHTTPToken: h4 } = util$m, L = require$$0__default, { isUint8Array: c3 } = require$$8__default$1, { webidl: l3 } = requireWebidl();
    let S = [], k3;
    try {
      k3 = import.meta.require("crypto");
      const y3 = ["sha256", "sha384", "sha512"];
      S = k3.getHashes().filter((Y) => y3.includes(Y));
    } catch {
    }
    function w(y3) {
      const Y = y3.urlList, W = Y.length;
      return W === 0 ? null : Y[W - 1].toString();
    }
    o4(w, "responseURL");
    function U(y3, Y) {
      if (!t4.has(y3.status))
        return null;
      let W = y3.headersList.get("location", true);
      return W !== null && N(W) && (M(W) || (W = B(W)), W = new URL(W, w(y3))), W && !W.hash && (W.hash = Y), W;
    }
    o4(U, "responseLocationURL");
    function M(y3) {
      for (const Y of y3) {
        const W = Y.charCodeAt(0);
        if (W >= 128 || W >= 0 && W <= 31 || W === 127)
          return false;
      }
      return true;
    }
    o4(M, "isValidEncodedURL");
    function B(y3) {
      return Buffer.from(y3, "binary").toString("utf8");
    }
    o4(B, "normalizeBinaryStringToUtf8");
    function D(y3) {
      return y3.urlList[y3.urlList.length - 1];
    }
    o4(D, "requestCurrentURL");
    function G(y3) {
      const Y = D(y3);
      return ZA(Y) && r.has(Y.port) ? "blocked" : "allowed";
    }
    o4(G, "requestBadPort");
    function g3(y3) {
      return y3 instanceof Error || y3?.constructor?.name === "Error" || y3?.constructor?.name === "DOMException";
    }
    o4(g3, "isErrorLike");
    function d3(y3) {
      for (let Y = 0;Y < y3.length; ++Y) {
        const W = y3.charCodeAt(Y);
        if (!(W === 9 || W >= 32 && W <= 126 || W >= 128 && W <= 255))
          return false;
      }
      return true;
    }
    o4(d3, "isValidReasonPhrase");
    const F = h4;
    function N(y3) {
      return !(y3.startsWith("	") || y3.startsWith(" ") || y3.endsWith("	") || y3.endsWith(" ") || y3.includes("\0") || y3.includes("\r") || y3.includes(`
`));
    }
    o4(N, "isValidHeaderValue");
    function u(y3, Y) {
      const { headersList: W } = Y, j = (W.get("referrer-policy", true) ?? "").split(",");
      let nA = "";
      if (j.length > 0)
        for (let R = j.length;R !== 0; R--) {
          const O = j[R - 1].trim();
          if (n3.has(O)) {
            nA = O;
            break;
          }
        }
      nA !== "" && (y3.referrerPolicy = nA);
    }
    o4(u, "setRequestReferrerPolicyOnRedirect");
    function b() {
      return "allowed";
    }
    o4(b, "crossOriginResourcePolicyCheck");
    function m3() {
      return "success";
    }
    o4(m3, "corsCheck");
    function T() {
      return "success";
    }
    o4(T, "TAOCheck");
    function v3(y3) {
      let Y = null;
      Y = y3.mode, y3.headersList.set("sec-fetch-mode", Y, true);
    }
    o4(v3, "appendFetchMetadata");
    function Z(y3) {
      let Y = y3.origin;
      if (y3.responseTainting === "cors" || y3.mode === "websocket")
        Y && y3.headersList.append("origin", Y, true);
      else if (y3.method !== "GET" && y3.method !== "HEAD") {
        switch (y3.referrerPolicy) {
          case "no-referrer":
            Y = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            y3.origin && ee(y3.origin) && !ee(D(y3)) && (Y = null);
            break;
          case "same-origin":
            yA(y3, D(y3)) || (Y = null);
            break;
        }
        Y && y3.headersList.append("origin", Y, true);
      }
    }
    o4(Z, "appendRequestOriginHeader");
    function P(y3, Y) {
      return y3;
    }
    o4(P, "coarsenTime");
    function AA(y3, Y, W) {
      return !y3?.startTime || y3.startTime < Y ? { domainLookupStartTime: Y, domainLookupEndTime: Y, connectionStartTime: Y, connectionEndTime: Y, secureConnectionStartTime: Y, ALPNNegotiatedProtocol: y3?.ALPNNegotiatedProtocol } : { domainLookupStartTime: P(y3.domainLookupStartTime), domainLookupEndTime: P(y3.domainLookupEndTime), connectionStartTime: P(y3.connectionStartTime), connectionEndTime: P(y3.connectionEndTime), secureConnectionStartTime: P(y3.secureConnectionStartTime), ALPNNegotiatedProtocol: y3.ALPNNegotiatedProtocol };
    }
    o4(AA, "clampAndCoarsenConnectionTimingInfo");
    function K(y3) {
      return P(I.now());
    }
    o4(K, "coarsenedSharedCurrentTime");
    function tA(y3) {
      return { startTime: y3.startTime ?? 0, redirectStartTime: 0, redirectEndTime: 0, postRedirectStartTime: y3.startTime ?? 0, finalServiceWorkerStartTime: 0, finalNetworkResponseStartTime: 0, finalNetworkRequestStartTime: 0, endTime: 0, encodedBodySize: 0, decodedBodySize: 0, finalConnectionTimingInfo: null };
    }
    o4(tA, "createOpaqueTimingInfo");
    function aA() {
      return { referrerPolicy: "strict-origin-when-cross-origin" };
    }
    o4(aA, "makePolicyContainer");
    function X(y3) {
      return { referrerPolicy: y3.referrerPolicy };
    }
    o4(X, "clonePolicyContainer");
    function $(y3) {
      const Y = y3.referrerPolicy;
      L(Y);
      let W = null;
      if (y3.referrer === "client") {
        const H = s3();
        if (!H || H.origin === "null")
          return "no-referrer";
        W = new URL(H);
      } else
        y3.referrer instanceof URL && (W = y3.referrer);
      let j = V2(W);
      const nA = V2(W, true);
      j.toString().length > 4096 && (j = nA);
      const R = yA(y3, j), O = q(j) && !q(y3.url);
      switch (Y) {
        case "origin":
          return nA ?? V2(W, true);
        case "unsafe-url":
          return j;
        case "same-origin":
          return R ? nA : "no-referrer";
        case "origin-when-cross-origin":
          return R ? j : nA;
        case "strict-origin-when-cross-origin": {
          const H = D(y3);
          return yA(j, H) ? j : q(j) && !q(H) ? "no-referrer" : nA;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return O ? "no-referrer" : nA;
      }
    }
    o4($, "determineRequestsReferrer");
    function V2(y3, Y) {
      return L(y3 instanceof URL), y3 = new URL(y3), y3.protocol === "file:" || y3.protocol === "about:" || y3.protocol === "blank:" ? "no-referrer" : (y3.username = "", y3.password = "", y3.hash = "", Y && (y3.pathname = "", y3.search = ""), y3);
    }
    o4(V2, "stripURLForReferrer");
    function q(y3) {
      if (!(y3 instanceof URL))
        return false;
      if (y3.href === "about:blank" || y3.href === "about:srcdoc" || y3.protocol === "data:" || y3.protocol === "file:")
        return true;
      return Y(y3.origin);
      function Y(W) {
        if (W == null || W === "null")
          return false;
        const j = new URL(W);
        return !!(j.protocol === "https:" || j.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(j.hostname) || j.hostname === "localhost" || j.hostname.includes("localhost.") || j.hostname.endsWith(".localhost"));
      }
    }
    o4(q, "isURLPotentiallyTrustworthy");
    function z(y3, Y) {
      if (k3 === undefined)
        return true;
      const W = iA(Y);
      if (W === "no metadata" || W.length === 0)
        return true;
      const j = gA(W), nA = BA(W, j);
      for (const R of nA) {
        const { algo: O, hash: H } = R;
        let J = k3.createHash(O).update(y3).digest("base64");
        if (J[J.length - 1] === "=" && (J[J.length - 2] === "=" ? J = J.slice(0, -2) : J = J.slice(0, -1)), sA(J, H))
          return true;
      }
      return false;
    }
    o4(z, "bytesMatch");
    const rA = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function iA(y3) {
      const Y = [];
      let W = true;
      for (const j of y3.split(" ")) {
        W = false;
        const nA = rA.exec(j);
        if (nA === null || nA.groups === undefined || nA.groups.algo === undefined)
          continue;
        const R = nA.groups.algo.toLowerCase();
        S.includes(R) && Y.push(nA.groups);
      }
      return W === true ? "no metadata" : Y;
    }
    o4(iA, "parseMetadata");
    function gA(y3) {
      let Y = y3[0].algo;
      if (Y[3] === "5")
        return Y;
      for (let W = 1;W < y3.length; ++W) {
        const j = y3[W];
        if (j.algo[3] === "5") {
          Y = "sha512";
          break;
        } else {
          if (Y[3] === "3")
            continue;
          j.algo[3] === "3" && (Y = "sha384");
        }
      }
      return Y;
    }
    o4(gA, "getStrongestMetadata");
    function BA(y3, Y) {
      if (y3.length === 1)
        return y3;
      let W = 0;
      for (let j = 0;j < y3.length; ++j)
        y3[j].algo === Y && (y3[W++] = y3[j]);
      return y3.length = W, y3;
    }
    o4(BA, "filterMetadataListByAlgorithm");
    function sA(y3, Y) {
      if (y3.length !== Y.length)
        return false;
      for (let W = 0;W < y3.length; ++W)
        if (y3[W] !== Y[W]) {
          if (y3[W] === "+" && Y[W] === "-" || y3[W] === "/" && Y[W] === "_")
            continue;
          return false;
        }
      return true;
    }
    o4(sA, "compareBase64Mixed");
    function eA(y3) {
    }
    o4(eA, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
    function yA(y3, Y) {
      return y3.origin === Y.origin && y3.origin === "null" || y3.protocol === Y.protocol && y3.hostname === Y.hostname && y3.port === Y.port;
    }
    o4(yA, "sameOrigin");
    function WA() {
      let y3, Y;
      return { promise: new Promise((j, nA) => {
        y3 = j, Y = nA;
      }), resolve: y3, reject: Y };
    }
    o4(WA, "createDeferredPromise");
    function wA(y3) {
      return y3.controller.state === "aborted";
    }
    o4(wA, "isAborted");
    function qA(y3) {
      return y3.controller.state === "aborted" || y3.controller.state === "terminated";
    }
    o4(qA, "isCancelled");
    const MA = { delete: "DELETE", DELETE: "DELETE", get: "GET", GET: "GET", head: "HEAD", HEAD: "HEAD", options: "OPTIONS", OPTIONS: "OPTIONS", post: "POST", POST: "POST", put: "PUT", PUT: "PUT" }, HA = { ...MA, patch: "patch", PATCH: "PATCH" };
    Object.setPrototypeOf(MA, null), Object.setPrototypeOf(HA, null);
    function pA(y3) {
      return MA[y3.toLowerCase()] ?? y3;
    }
    o4(pA, "normalizeMethod");
    function YA(y3) {
      const Y = JSON.stringify(y3);
      if (Y === undefined)
        throw new TypeError("Value is not JSON serializable");
      return L(typeof Y == "string"), Y;
    }
    o4(YA, "serializeJavascriptValueToJSONString");
    const UA = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function JA(y3, Y, W = 0, j = 1) {
      var R, O, H;
      const J = class J4 {
        constructor(x, QA) {
          CA(this, R, undefined);
          CA(this, O, undefined);
          CA(this, H, undefined);
          EA(this, R, x), EA(this, O, QA), EA(this, H, 0);
        }
        next() {
          if (typeof this != "object" || this === null || !yt(R, this))
            throw new TypeError(`'next' called on an object that does not implement interface ${y3} Iterator.`);
          const x = p3(this, H), QA = p3(this, R)[Y], lA = QA.length;
          if (x >= lA)
            return { value: undefined, done: true };
          const { [W]: uA, [j]: cA } = QA[x];
          EA(this, H, x + 1);
          let fA;
          switch (p3(this, O)) {
            case "key":
              fA = uA;
              break;
            case "value":
              fA = cA;
              break;
            case "key+value":
              fA = [uA, cA];
              break;
          }
          return { value: fA, done: false };
        }
      };
      R = new WeakMap, O = new WeakMap, H = new WeakMap, o4(J, "FastIterableIterator");
      let nA = J;
      return delete nA.prototype.constructor, Object.setPrototypeOf(nA.prototype, UA), Object.defineProperties(nA.prototype, { [Symbol.toStringTag]: { writable: false, enumerable: false, configurable: true, value: `${y3} Iterator` }, next: { writable: true, enumerable: true, configurable: true } }), function(_, x) {
        return new nA(_, x);
      };
    }
    o4(JA, "createIterator");
    function VA(y3, Y, W, j = 0, nA = 1) {
      const R = JA(y3, W, j, nA), O = { keys: { writable: true, enumerable: true, configurable: true, value: o4(function() {
        return l3.brandCheck(this, Y), R(this, "key");
      }, "keys") }, values: { writable: true, enumerable: true, configurable: true, value: o4(function() {
        return l3.brandCheck(this, Y), R(this, "value");
      }, "values") }, entries: { writable: true, enumerable: true, configurable: true, value: o4(function() {
        return l3.brandCheck(this, Y), R(this, "key+value");
      }, "entries") }, forEach: { writable: true, enumerable: true, configurable: true, value: o4(function(J, _ = globalThis) {
        if (l3.brandCheck(this, Y), l3.argumentLengthCheck(arguments, 1, { header: `${y3}.forEach` }), typeof J != "function")
          throw new TypeError(`Failed to execute 'forEach' on '${y3}': parameter 1 is not of type 'Function'.`);
        for (const { 0: x, 1: QA } of R(this, "key+value"))
          J.call(_, QA, x, this);
      }, "forEach") } };
      return Object.defineProperties(Y.prototype, { ...O, [Symbol.iterator]: { writable: true, enumerable: false, configurable: true, value: O.entries.value } });
    }
    o4(VA, "iteratorMixin");
    async function OA(y3, Y, W) {
      const j = Y, nA = W;
      let R;
      try {
        R = y3.stream.getReader();
      } catch (O) {
        nA(O);
        return;
      }
      try {
        const O = await PA(R);
        j(O);
      } catch (O) {
        nA(O);
      }
    }
    o4(OA, "fullyReadBody");
    function IA(y3) {
      return y3 instanceof ReadableStream || y3[Symbol.toStringTag] === "ReadableStream" && typeof y3.tee == "function";
    }
    o4(IA, "isReadableStreamLike");
    function hA(y3) {
      try {
        y3.close(), y3.byobRequest?.respond(0);
      } catch (Y) {
        if (!Y.message.includes("Controller is already closed") && !Y.message.includes("ReadableStream is already closed"))
          throw Y;
      }
    }
    o4(hA, "readableStreamClose");
    function SA(y3) {
      for (let Y = 0;Y < y3.length; Y++)
        L(y3.charCodeAt(Y) <= 255);
      return y3;
    }
    o4(SA, "isomorphicEncode");
    async function PA(y3) {
      const Y = [];
      let W = 0;
      for (;; ) {
        const { done: j, value: nA } = await y3.read();
        if (j)
          return Buffer.concat(Y, W);
        if (!c3(nA))
          throw new TypeError("Received non-Uint8Array chunk");
        Y.push(nA), W += nA.length;
      }
    }
    o4(PA, "readAllBytes");
    function Pe(y3) {
      L("protocol" in y3);
      const Y = y3.protocol;
      return Y === "about:" || Y === "blob:" || Y === "data:";
    }
    o4(Pe, "urlIsLocal");
    function ee(y3) {
      return typeof y3 == "string" ? y3.startsWith("https:") : y3.protocol === "https:";
    }
    o4(ee, "urlHasHttpsScheme");
    function ZA(y3) {
      L("protocol" in y3);
      const Y = y3.protocol;
      return Y === "http:" || Y === "https:";
    }
    o4(ZA, "urlIsHttpHttpsScheme");
    function XA(y3, Y) {
      const W = y3;
      if (!W.startsWith("bytes"))
        return "failure";
      const j = { position: 5 };
      if (Y && i4((J) => J === "	" || J === " ", W, j), W.charCodeAt(j.position) !== 61)
        return "failure";
      j.position++, Y && i4((J) => J === "	" || J === " ", W, j);
      const nA = i4((J) => {
        const _ = J.charCodeAt(0);
        return _ >= 48 && _ <= 57;
      }, W, j), R = nA.length ? Number(nA) : null;
      if (Y && i4((J) => J === "	" || J === " ", W, j), W.charCodeAt(j.position) !== 45)
        return "failure";
      j.position++, Y && i4((J) => J === "	" || J === " ", W, j);
      const O = i4((J) => {
        const _ = J.charCodeAt(0);
        return _ >= 48 && _ <= 57;
      }, W, j), H = O.length ? Number(O) : null;
      return j.position < W.length || H === null && R === null || R > H ? "failure" : { rangeStartValue: R, rangeEndValue: H };
    }
    o4(XA, "simpleRangeHeaderValue");
    function Ze(y3, Y, W) {
      let j = "bytes ";
      return j += SA(`${y3}`), j += "-", j += SA(`${Y}`), j += "/", j += SA(`${W}`), j;
    }
    o4(Ze, "buildContentRange");
    const vA = class vA2 extends e3 {
      _transform(Y, W, j) {
        if (!this._inflateStream) {
          if (Y.length === 0) {
            j();
            return;
          }
          this._inflateStream = (Y[0] & 15) === 8 ? A.createInflate() : A.createInflateRaw(), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (nA) => this.destroy(nA));
        }
        this._inflateStream.write(Y, W, j);
      }
      _final(Y) {
        this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), Y();
      }
    };
    o4(vA, "InflateStream");
    let KA = vA;
    function He() {
      return new KA;
    }
    o4(He, "createInflate");
    function te(y3) {
      let Y = null, W = null, j = null;
      const nA = re("content-type", y3);
      if (nA === null)
        return "failure";
      for (const R of nA) {
        const O = C(R);
        O === "failure" || O.essence === "*/*" || (j = O, j.essence !== W ? (Y = null, j.parameters.has("charset") && (Y = j.parameters.get("charset")), W = j.essence) : !j.parameters.has("charset") && Y !== null && j.parameters.set("charset", Y));
      }
      return j ?? "failure";
    }
    o4(te, "extractMimeType");
    function Ve(y3) {
      const Y = y3, W = { position: 0 }, j = [];
      let nA = "";
      for (;W.position < Y.length; ) {
        if (nA += i4((R) => R !== '"' && R !== ",", Y, W), W.position < Y.length)
          if (Y.charCodeAt(W.position) === 34) {
            if (nA += E4(Y, W), W.position < Y.length)
              continue;
          } else
            L(Y.charCodeAt(W.position) === 44), W.position++;
        nA = Q(nA, true, true, (R) => R === 9 || R === 32), j.push(nA), nA = "";
      }
      return j;
    }
    o4(Ve, "gettingDecodingSplitting");
    function re(y3, Y) {
      const W = Y.get(y3, true);
      return W === null ? null : Ve(W);
    }
    o4(re, "getDecodeSplit");
    const ve = new TextDecoder;
    function Xe(y3) {
      return y3.length === 0 ? "" : (y3[0] === 239 && y3[1] === 187 && y3[2] === 191 && (y3 = y3.subarray(3)), ve.decode(y3));
    }
    return o4(Xe, "utf8DecodeBytes"), util$j = { isAborted: wA, isCancelled: qA, createDeferredPromise: WA, ReadableStreamFrom: f3, tryUpgradeRequestToAPotentiallyTrustworthyURL: eA, clampAndCoarsenConnectionTimingInfo: AA, coarsenedSharedCurrentTime: K, determineRequestsReferrer: $, makePolicyContainer: aA, clonePolicyContainer: X, appendFetchMetadata: v3, appendRequestOriginHeader: Z, TAOCheck: T, corsCheck: m3, crossOriginResourcePolicyCheck: b, createOpaqueTimingInfo: tA, setRequestReferrerPolicyOnRedirect: u, isValidHTTPToken: h4, requestBadPort: G, requestCurrentURL: D, responseURL: w, responseLocationURL: U, isBlobLike: a3, isURLPotentiallyTrustworthy: q, isValidReasonPhrase: d3, sameOrigin: yA, normalizeMethod: pA, serializeJavascriptValueToJSONString: YA, iteratorMixin: VA, createIterator: JA, isValidHeaderName: F, isValidHeaderValue: N, isErrorLike: g3, fullyReadBody: OA, bytesMatch: z, isReadableStreamLike: IA, readableStreamClose: hA, isomorphicEncode: SA, urlIsLocal: Pe, urlHasHttpsScheme: ee, urlIsHttpHttpsScheme: ZA, readAllBytes: PA, normalizeMethodRecord: HA, simpleRangeHeaderValue: XA, buildContentRange: Ze, parseMetadata: iA, createInflate: He, extractMimeType: te, getDecodeSplit: re, utf8DecodeBytes: Xe }, util$j;
  }
  function requireSymbols$3() {
    return hasRequiredSymbols$3 || (hasRequiredSymbols$3 = 1, symbols$3 = { kUrl: Symbol("url"), kHeaders: Symbol("headers"), kSignal: Symbol("signal"), kState: Symbol("state"), kGuard: Symbol("guard"), kRealm: Symbol("realm"), kDispatcher: Symbol("dispatcher") }), symbols$3;
  }
  function requireFile() {
    if (hasRequiredFile)
      return file;
    hasRequiredFile = 1;
    const { EOL: e3 } = require$$0__default$4, { Blob: A, File: t4 } = require$$6__default, { types: n3 } = require$$0__default$1, { kState: r } = requireSymbols$3(), { isBlobLike: s3 } = requireUtil$5(), { webidl: i4 } = requireWebidl(), { parseMIMEType: E4, serializeAMimeType: Q } = requireDataUrl(), { kEnumerableProperty: C } = util$m, I = new TextEncoder, l3 = class l4 extends A {
      constructor(w, U, M = {}) {
        i4.argumentLengthCheck(arguments, 2, { header: "File constructor" }), w = i4.converters["sequence<BlobPart>"](w), U = i4.converters.USVString(U), M = i4.converters.FilePropertyBag(M);
        const B = U;
        let D = M.type, G;
        A: {
          if (D) {
            if (D = E4(D), D === "failure") {
              D = "";
              break A;
            }
            D = Q(D).toLowerCase();
          }
          G = M.lastModified;
        }
        super(h4(w, M), { type: D }), this[r] = { name: B, lastModified: G, type: D };
      }
      get name() {
        return i4.brandCheck(this, l4), this[r].name;
      }
      get lastModified() {
        return i4.brandCheck(this, l4), this[r].lastModified;
      }
      get type() {
        return i4.brandCheck(this, l4), this[r].type;
      }
    };
    o4(l3, "File");
    let a3 = l3;
    const S = class S2 {
      constructor(w, U, M = {}) {
        const B = U, D = M.type, G = M.lastModified ?? Date.now();
        this[r] = { blobLike: w, name: B, type: D, lastModified: G };
      }
      stream(...w) {
        return i4.brandCheck(this, S2), this[r].blobLike.stream(...w);
      }
      arrayBuffer(...w) {
        return i4.brandCheck(this, S2), this[r].blobLike.arrayBuffer(...w);
      }
      slice(...w) {
        return i4.brandCheck(this, S2), this[r].blobLike.slice(...w);
      }
      text(...w) {
        return i4.brandCheck(this, S2), this[r].blobLike.text(...w);
      }
      get size() {
        return i4.brandCheck(this, S2), this[r].blobLike.size;
      }
      get type() {
        return i4.brandCheck(this, S2), this[r].blobLike.type;
      }
      get name() {
        return i4.brandCheck(this, S2), this[r].name;
      }
      get lastModified() {
        return i4.brandCheck(this, S2), this[r].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    o4(S, "FileLike");
    let f3 = S;
    Object.defineProperties(a3.prototype, { [Symbol.toStringTag]: { value: "File", configurable: true }, name: C, lastModified: C }), i4.converters.Blob = i4.interfaceConverter(A), i4.converters.BlobPart = function(k3, w) {
      if (i4.util.Type(k3) === "Object") {
        if (s3(k3))
          return i4.converters.Blob(k3, { strict: false });
        if (ArrayBuffer.isView(k3) || n3.isAnyArrayBuffer(k3))
          return i4.converters.BufferSource(k3, w);
      }
      return i4.converters.USVString(k3, w);
    }, i4.converters["sequence<BlobPart>"] = i4.sequenceConverter(i4.converters.BlobPart), i4.converters.FilePropertyBag = i4.dictionaryConverter([{ key: "lastModified", converter: i4.converters["long long"], get defaultValue() {
      return Date.now();
    } }, { key: "type", converter: i4.converters.DOMString, defaultValue: "" }, { key: "endings", converter: (k3) => (k3 = i4.converters.DOMString(k3), k3 = k3.toLowerCase(), k3 !== "native" && (k3 = "transparent"), k3), defaultValue: "transparent" }]);
    function h4(k3, w) {
      const U = [];
      for (const M of k3)
        if (typeof M == "string") {
          let B = M;
          w.endings === "native" && (B = L(B)), U.push(I.encode(B));
        } else
          ArrayBuffer.isView(M) || n3.isArrayBuffer(M) ? M.buffer ? U.push(new Uint8Array(M.buffer, M.byteOffset, M.byteLength)) : U.push(new Uint8Array(M)) : s3(M) && U.push(M);
      return U;
    }
    o4(h4, "processBlobParts");
    function L(k3) {
      return k3.replace(/\r?\n/g, e3);
    }
    o4(L, "convertLineEndingsNative");
    function c3(k3) {
      return t4 && k3 instanceof t4 || k3 instanceof a3 || k3 && (typeof k3.stream == "function" || typeof k3.arrayBuffer == "function") && k3[Symbol.toStringTag] === "File";
    }
    return o4(c3, "isFileLike"), file = { File: a3, FileLike: f3, isFileLike: c3 }, file;
  }
  function requireFormdata() {
    if (hasRequiredFormdata)
      return formdata;
    hasRequiredFormdata = 1;
    const { isBlobLike: e3, iteratorMixin: A } = requireUtil$5(), { kState: t4 } = requireSymbols$3(), { kEnumerableProperty: n3 } = util$m, { File: r, FileLike: s3, isFileLike: i4 } = requireFile(), { webidl: E4 } = requireWebidl(), { File: Q } = require$$6__default, C = require$$0__default$1, I = Q ?? r, h4 = class h5 {
      constructor(c3) {
        if (c3 !== undefined)
          throw E4.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
        this[t4] = [];
      }
      append(c3, l3, S = undefined) {
        if (E4.brandCheck(this, h5), E4.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !e3(l3))
          throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
        c3 = E4.converters.USVString(c3), l3 = e3(l3) ? E4.converters.Blob(l3, { strict: false }) : E4.converters.USVString(l3), S = arguments.length === 3 ? E4.converters.USVString(S) : undefined;
        const k3 = f3(c3, l3, S);
        this[t4].push(k3);
      }
      delete(c3) {
        E4.brandCheck(this, h5), E4.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), c3 = E4.converters.USVString(c3), this[t4] = this[t4].filter((l3) => l3.name !== c3);
      }
      get(c3) {
        E4.brandCheck(this, h5), E4.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), c3 = E4.converters.USVString(c3);
        const l3 = this[t4].findIndex((S) => S.name === c3);
        return l3 === -1 ? null : this[t4][l3].value;
      }
      getAll(c3) {
        return E4.brandCheck(this, h5), E4.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), c3 = E4.converters.USVString(c3), this[t4].filter((l3) => l3.name === c3).map((l3) => l3.value);
      }
      has(c3) {
        return E4.brandCheck(this, h5), E4.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), c3 = E4.converters.USVString(c3), this[t4].findIndex((l3) => l3.name === c3) !== -1;
      }
      set(c3, l3, S = undefined) {
        if (E4.brandCheck(this, h5), E4.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !e3(l3))
          throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
        c3 = E4.converters.USVString(c3), l3 = e3(l3) ? E4.converters.Blob(l3, { strict: false }) : E4.converters.USVString(l3), S = arguments.length === 3 ? E4.converters.USVString(S) : undefined;
        const k3 = f3(c3, l3, S), w = this[t4].findIndex((U) => U.name === c3);
        w !== -1 ? this[t4] = [...this[t4].slice(0, w), k3, ...this[t4].slice(w + 1).filter((U) => U.name !== c3)] : this[t4].push(k3);
      }
      [C.inspect.custom](c3, l3) {
        const S = this[t4].reduce((w, U) => (w[U.name] ? Array.isArray(w[U.name]) ? w[U.name].push(U.value) : w[U.name] = [w[U.name], U.value] : w[U.name] = U.value, w), { __proto__: null });
        l3.depth ?? (l3.depth = c3), l3.colors ?? (l3.colors = true);
        const k3 = C.formatWithOptions(l3, S);
        return `FormData ${k3.slice(k3.indexOf("]") + 2)}`;
      }
    };
    o4(h4, "FormData");
    let a3 = h4;
    A("FormData", a3, t4, "name", "value"), Object.defineProperties(a3.prototype, { append: n3, delete: n3, get: n3, getAll: n3, has: n3, set: n3, [Symbol.toStringTag]: { value: "FormData", configurable: true } });
    function f3(L, c3, l3) {
      if (typeof c3 != "string") {
        if (i4(c3) || (c3 = c3 instanceof Blob ? new I([c3], "blob", { type: c3.type }) : new s3(c3, "blob", { type: c3.type })), l3 !== undefined) {
          const S = { type: c3.type, lastModified: c3.lastModified };
          c3 = Q && c3 instanceof Q || c3 instanceof r ? new I([c3], l3, S) : new s3(c3, l3, S);
        }
      }
      return { name: L, value: c3 };
    }
    return o4(f3, "makeEntry"), formdata = { FormData: a3, makeEntry: f3 }, formdata;
  }
  function requireFormdataParser() {
    if (hasRequiredFormdataParser)
      return formdataParser;
    hasRequiredFormdataParser = 1;
    const { toUSVString: e3, isUSVString: A, bufferToLowerCasedHeaderName: t4 } = util$m, { utf8DecodeBytes: n3 } = requireUtil$5(), { HTTP_TOKEN_CODEPOINTS: r, isomorphicDecode: s3 } = requireDataUrl(), { isFileLike: i4, File: E4 } = requireFile(), { makeEntry: Q } = requireFormdata(), C = require$$0__default, { File: I } = require$$6__default, a3 = globalThis.File ?? I ?? E4, f3 = Buffer.from('form-data; name="'), h4 = Buffer.from("; filename"), L = Buffer.from("--"), c3 = Buffer.from(`--\r
`);
    function l3(g3) {
      for (let d3 = 0;d3 < g3.length; ++d3)
        if (g3.charCodeAt(d3) & -128)
          return false;
      return true;
    }
    o4(l3, "isAsciiString");
    function S(g3) {
      const d3 = g3.length;
      if (d3 < 27 || d3 > 70)
        return false;
      for (let F = 0;F < d3; ++F) {
        const N = g3.charCodeAt(F);
        if (!(N >= 48 && N <= 57 || N >= 65 && N <= 90 || N >= 97 && N <= 122 || N === 39 || N === 45 || N === 95))
          return false;
      }
      return true;
    }
    o4(S, "validateBoundary");
    function k3(g3, d3 = "utf-8", F = false) {
      return F ? g3 = e3(g3) : (C(A(g3)), g3 = g3.replace(/\r\n?|\r?\n/g, `\r
`)), C(Buffer.isEncoding(d3)), g3 = g3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), Buffer.from(g3, d3);
    }
    o4(k3, "escapeFormDataName");
    function w(g3, d3) {
      C(d3 !== "failure" && d3.essence === "multipart/form-data");
      const F = d3.parameters.get("boundary");
      if (F === undefined)
        return "failure";
      const N = Buffer.from(`--${F}`, "utf8"), u = [], b = { position: 0 };
      for (g3[0] === 13 && g3[1] === 10 && (b.position += 2);; ) {
        if (g3.subarray(b.position, b.position + N.length).equals(N))
          b.position += N.length;
        else
          return "failure";
        if (b.position === g3.length - 2 && G(g3, L, b) || b.position === g3.length - 4 && G(g3, c3, b))
          return u;
        if (g3[b.position] !== 13 || g3[b.position + 1] !== 10)
          return "failure";
        b.position += 2;
        const m3 = U(g3, b);
        if (m3 === "failure")
          return "failure";
        let { name: T, filename: v3, contentType: Z, encoding: P } = m3;
        b.position += 2;
        let AA;
        {
          const tA = g3.indexOf(N.subarray(2), b.position);
          if (tA === -1)
            return "failure";
          AA = g3.subarray(b.position, tA - 4), b.position += AA.length, P === "base64" && (AA = Buffer.from(AA.toString(), "base64"));
        }
        if (g3[b.position] !== 13 || g3[b.position + 1] !== 10)
          return "failure";
        b.position += 2;
        let K;
        v3 !== null ? (Z ?? (Z = "text/plain"), l3(Z) || (Z = ""), K = new a3([AA], v3, { type: Z })) : K = n3(Buffer.from(AA)), C(A(T)), C(typeof K == "string" && A(K) || i4(K)), u.push(Q(T, K, v3));
      }
    }
    o4(w, "multipartFormDataParser");
    function U(g3, d3) {
      let F = null, N = null, u = null, b = null;
      for (;; ) {
        if (g3[d3.position] === 13 && g3[d3.position + 1] === 10)
          return F === null ? "failure" : { name: F, filename: N, contentType: u, encoding: b };
        let m3 = B((T) => T !== 10 && T !== 13 && T !== 58, g3, d3);
        if (m3 = D(m3, true, true, (T) => T === 9 || T === 32), !r.test(m3.toString()) || g3[d3.position] !== 58)
          return "failure";
        switch (d3.position++, B((T) => T === 32 || T === 9, g3, d3), t4(m3)) {
          case "content-disposition": {
            if (F = N = null, !G(g3, f3, d3) || (d3.position += 17, F = M(g3, d3), F === null))
              return "failure";
            if (G(g3, h4, d3)) {
              let T = d3.position + h4.length;
              if (g3[T] === 42 && (d3.position += 1, T += 1), g3[T] !== 61 || g3[T + 1] !== 34 || (d3.position += 12, N = M(g3, d3), N === null))
                return "failure";
            }
            break;
          }
          case "content-type": {
            let T = B((v3) => v3 !== 10 && v3 !== 13, g3, d3);
            T = D(T, false, true, (v3) => v3 === 9 || v3 === 32), u = s3(T);
            break;
          }
          case "content-transfer-encoding": {
            let T = B((v3) => v3 !== 10 && v3 !== 13, g3, d3);
            T = D(T, false, true, (v3) => v3 === 9 || v3 === 32), b = s3(T);
            break;
          }
          default:
            B((T) => T !== 10 && T !== 13, g3, d3);
        }
        if (g3[d3.position] !== 13 && g3[d3.position + 1] !== 10)
          return "failure";
        d3.position += 2;
      }
    }
    o4(U, "parseMultipartFormDataHeaders");
    function M(g3, d3) {
      C(g3[d3.position - 1] === 34);
      let F = B((N) => N !== 10 && N !== 13 && N !== 34, g3, d3);
      return g3[d3.position] !== 34 ? null : (d3.position++, F = new TextDecoder().decode(F).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), F);
    }
    o4(M, "parseMultipartFormDataName");
    function B(g3, d3, F) {
      let N = F.position;
      for (;N < d3.length && g3(d3[N]); )
        ++N;
      return d3.subarray(F.position, F.position = N);
    }
    o4(B, "collectASequenceOfBytes");
    function D(g3, d3, F, N) {
      let u = 0, b = g3.length - 1;
      if (d3)
        for (;u < g3.length && N(g3[u]); )
          u++;
      if (F)
        for (;b > 0 && N(g3[b]); )
          b--;
      return u === 0 && b === g3.length - 1 ? g3 : g3.subarray(u, b + 1);
    }
    o4(D, "removeChars");
    function G(g3, d3, F) {
      if (g3.length < d3.length)
        return false;
      for (let N = 0;N < d3.length; N++)
        if (d3[N] !== g3[F.position + N])
          return false;
      return true;
    }
    return o4(G, "bufferStartsWith"), formdataParser = { multipartFormDataParser: w, validateBoundary: S, escapeFormDataName: k3 }, formdataParser;
  }
  function requireBody() {
    if (hasRequiredBody)
      return body;
    hasRequiredBody = 1;
    const e3 = util$m, { ReadableStreamFrom: A, isBlobLike: t4, isReadableStreamLike: n3, readableStreamClose: r, createDeferredPromise: s3, fullyReadBody: i4, extractMimeType: E4, utf8DecodeBytes: Q } = requireUtil$5(), { FormData: C } = requireFormdata(), { kState: I } = requireSymbols$3(), { webidl: a3 } = requireWebidl(), { Blob: f3 } = require$$6__default, h4 = require$$0__default, { isErrored: L } = util$m, { isArrayBuffer: c3 } = require$$8__default$1, { serializeAMimeType: l3 } = requireDataUrl(), { multipartFormDataParser: S } = requireFormdataParser(), k3 = new TextEncoder;
    function w(u, b = false) {
      let m3 = null;
      u instanceof ReadableStream ? m3 = u : t4(u) ? m3 = u.stream() : m3 = new ReadableStream({ async pull(K) {
        const tA = typeof v3 == "string" ? k3.encode(v3) : v3;
        tA.byteLength && K.enqueue(tA), queueMicrotask(() => r(K));
      }, start() {
      }, type: "bytes" }), h4(n3(m3));
      let T = null, v3 = null, Z = null, P = null;
      if (typeof u == "string")
        v3 = u, P = "text/plain;charset=UTF-8";
      else if (u instanceof URLSearchParams)
        v3 = u.toString(), P = "application/x-www-form-urlencoded;charset=UTF-8";
      else if (c3(u))
        v3 = new Uint8Array(u.slice());
      else if (ArrayBuffer.isView(u))
        v3 = new Uint8Array(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      else if (e3.isFormDataLike(u)) {
        const K = `----formdata-undici-0${`${Math.floor(Math.random() * 100000000000)}`.padStart(11, "0")}`, tA = `--${K}\r
Content-Disposition: form-data`;
        /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
        const aA = o4((rA) => rA.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape"), X = o4((rA) => rA.replace(/\r?\n|\r/g, `\r
`), "normalizeLinefeeds"), $ = [], V2 = new Uint8Array([13, 10]);
        Z = 0;
        let q = false;
        for (const [rA, iA] of u)
          if (typeof iA == "string") {
            const gA = k3.encode(tA + `; name="${aA(X(rA))}"\r
\r
${X(iA)}\r
`);
            $.push(gA), Z += gA.byteLength;
          } else {
            const gA = k3.encode(`${tA}; name="${aA(X(rA))}"` + (iA.name ? `; filename="${aA(iA.name)}"` : "") + `\r
Content-Type: ${iA.type || "application/octet-stream"}\r
\r
`);
            $.push(gA, iA, V2), typeof iA.size == "number" ? Z += gA.byteLength + iA.size + V2.byteLength : q = true;
          }
        const z = k3.encode(`--${K}--`);
        $.push(z), Z += z.byteLength, q && (Z = null), v3 = u, T = o4(async function* () {
          for (const rA of $)
            rA.stream ? yield* rA.stream() : yield rA;
        }, "action"), P = `multipart/form-data; boundary=${K}`;
      } else if (t4(u))
        v3 = u, Z = u.size, u.type && (P = u.type);
      else if (typeof u[Symbol.asyncIterator] == "function") {
        if (b)
          throw new TypeError("keepalive");
        if (e3.isDisturbed(u) || u.locked)
          throw new TypeError("Response body object should not be disturbed or locked");
        m3 = u instanceof ReadableStream ? u : A(u);
      }
      if ((typeof v3 == "string" || e3.isBuffer(v3)) && (Z = Buffer.byteLength(v3)), T != null) {
        let K;
        m3 = new ReadableStream({ async start() {
          K = T(u)[Symbol.asyncIterator]();
        }, async pull(tA) {
          const { value: aA, done: X } = await K.next();
          if (X)
            queueMicrotask(() => {
              tA.close(), tA.byobRequest?.respond(0);
            });
          else if (!L(m3)) {
            const $ = new Uint8Array(aA);
            $.byteLength && tA.enqueue($);
          }
          return tA.desiredSize > 0;
        }, async cancel(tA) {
          await K.return();
        }, type: "bytes" });
      }
      return [{ stream: m3, source: v3, length: Z }, P];
    }
    o4(w, "extractBody");
    function U(u, b = false) {
      return u instanceof ReadableStream && (h4(!e3.isDisturbed(u), "The body has already been consumed."), h4(!u.locked, "The stream is locked.")), w(u, b);
    }
    o4(U, "safelyExtractBody");
    function M(u) {
      const [b, m3] = u.stream.tee();
      return u.stream = b, { stream: m3, length: u.length, source: u.source };
    }
    o4(M, "cloneBody");
    function B(u) {
      if (u.aborted)
        throw new DOMException("The operation was aborted.", "AbortError");
    }
    o4(B, "throwIfAborted");
    function D(u) {
      return { blob() {
        return g3(this, (m3) => {
          let T = N(this);
          return T === null ? T = "" : T && (T = l3(T)), new f3([m3], { type: T });
        }, u);
      }, arrayBuffer() {
        return g3(this, (m3) => new Uint8Array(m3).buffer, u);
      }, text() {
        return g3(this, Q, u);
      }, json() {
        return g3(this, F, u);
      }, formData() {
        return g3(this, (m3) => {
          const T = N(this);
          if (T !== null)
            switch (T.essence) {
              case "multipart/form-data": {
                const v3 = S(m3, T);
                if (v3 === "failure")
                  throw new TypeError("Failed to parse body as FormData.");
                const Z = new C;
                return Z[I] = v3, Z;
              }
              case "application/x-www-form-urlencoded": {
                const v3 = new URLSearchParams(m3.toString()), Z = new C;
                for (const [P, AA] of v3)
                  Z.append(P, AA);
                return Z;
              }
            }
          throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
        }, u);
      } };
    }
    o4(D, "bodyMixinMethods");
    function G(u) {
      Object.assign(u.prototype, D(u));
    }
    o4(G, "mixinBody");
    async function g3(u, b, m3) {
      if (a3.brandCheck(u, m3), B(u[I]), d3(u[I].body))
        throw new TypeError("Body is unusable");
      const T = s3(), v3 = o4((P) => T.reject(P), "errorSteps"), Z = o4((P) => {
        try {
          T.resolve(b(P));
        } catch (AA) {
          v3(AA);
        }
      }, "successSteps");
      return u[I].body == null ? (Z(new Uint8Array), T.promise) : (await i4(u[I].body, Z, v3), T.promise);
    }
    o4(g3, "consumeBody");
    function d3(u) {
      return u != null && (u.stream.locked || e3.isDisturbed(u.stream));
    }
    o4(d3, "bodyUnusable");
    function F(u) {
      return JSON.parse(Q(u));
    }
    o4(F, "parseJSONFromBytes");
    function N(u) {
      const b = u[I].headersList, m3 = E4(b);
      return m3 === "failure" ? null : m3;
    }
    return o4(N, "bodyMimeType"), body = { extractBody: w, safelyExtractBody: U, cloneBody: M, mixinBody: G }, body;
  }
  async function lazyllhttp() {
    const e3 = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : undefined;
    let A;
    try {
      A = await WebAssembly.compile(requireLlhttp_simdWasm());
    } catch {
      A = await WebAssembly.compile(e3 || requireLlhttpWasm());
    }
    return await WebAssembly.instantiate(A, { env: { wasm_on_url: (t4, n3, r) => 0, wasm_on_status: (t4, n3, r) => {
      assert$a.strictEqual(currentParser.ptr, t4);
      const s3 = n3 - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, s3, r)) || 0;
    }, wasm_on_message_begin: (t4) => (assert$a.strictEqual(currentParser.ptr, t4), currentParser.onMessageBegin() || 0), wasm_on_header_field: (t4, n3, r) => {
      assert$a.strictEqual(currentParser.ptr, t4);
      const s3 = n3 - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, s3, r)) || 0;
    }, wasm_on_header_value: (t4, n3, r) => {
      assert$a.strictEqual(currentParser.ptr, t4);
      const s3 = n3 - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, s3, r)) || 0;
    }, wasm_on_headers_complete: (t4, n3, r, s3) => (assert$a.strictEqual(currentParser.ptr, t4), currentParser.onHeadersComplete(n3, !!r, !!s3) || 0), wasm_on_body: (t4, n3, r) => {
      assert$a.strictEqual(currentParser.ptr, t4);
      const s3 = n3 - currentBufferPtr + currentBufferRef.byteOffset;
      return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, s3, r)) || 0;
    }, wasm_on_message_complete: (t4) => (assert$a.strictEqual(currentParser.ptr, t4), currentParser.onMessageComplete() || 0) } });
  }
  function onParserTimeout(e3) {
    const { socket: A, timeoutType: t4, client: n3 } = e3;
    t4 === TIMEOUT_HEADERS ? (!A[kWriting] || A.writableNeedDrain || n3[kRunning$5] > 1) && (assert$a(!e3.paused, "cannot be paused while waiting for headers"), util$i.destroy(A, new HeadersTimeoutError)) : t4 === TIMEOUT_BODY ? e3.paused || util$i.destroy(A, new BodyTimeoutError) : t4 === TIMEOUT_IDLE && (assert$a(n3[kRunning$5] === 0 && n3[kKeepAliveTimeoutValue$1]), util$i.destroy(A, new InformationalError$2("socket idle timeout")));
  }
  async function connectH1$1(e3, A) {
    e3[kSocket$1] = A, llhttpInstance || (llhttpInstance = await llhttpPromise, llhttpPromise = null), A[kNoRef] = false, A[kWriting] = false, A[kReset$1] = false, A[kBlocking] = false, A[kParser] = new Parser(e3, A, llhttpInstance), addListener(A, "error", function(n3) {
      const r = this[kParser];
      if (assert$a(n3.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), n3.code === "ECONNRESET" && r.statusCode && !r.shouldKeepAlive) {
        r.onMessageComplete();
        return;
      }
      this[kError$2] = n3, this[kClient$3][kOnError$2](n3);
    }), addListener(A, "readable", function() {
      const n3 = this[kParser];
      n3 && n3.readMore();
    }), addListener(A, "end", function() {
      const n3 = this[kParser];
      if (n3.statusCode && !n3.shouldKeepAlive) {
        n3.onMessageComplete();
        return;
      }
      util$i.destroy(this, new SocketError$3("other side closed", util$i.getSocketInfo(this)));
    }), addListener(A, "close", function() {
      const n3 = this[kClient$3], r = this[kParser];
      r && (!this[kError$2] && r.statusCode && !r.shouldKeepAlive && r.onMessageComplete(), this[kParser].destroy(), this[kParser] = null);
      const s3 = this[kError$2] || new SocketError$3("closed", util$i.getSocketInfo(this));
      if (n3[kSocket$1] = null, n3[kHTTPContext$1] = null, n3.destroyed) {
        assert$a(n3[kPending$4] === 0);
        const i4 = n3[kQueue$3].splice(n3[kRunningIdx$2]);
        for (let E4 = 0;E4 < i4.length; E4++) {
          const Q = i4[E4];
          util$i.errorRequest(n3, Q, s3);
        }
      } else if (n3[kRunning$5] > 0 && s3.code !== "UND_ERR_INFO") {
        const i4 = n3[kQueue$3][n3[kRunningIdx$2]];
        n3[kQueue$3][n3[kRunningIdx$2]++] = null, util$i.errorRequest(n3, i4, s3);
      }
      n3[kPendingIdx$2] = n3[kRunningIdx$2], assert$a(n3[kRunning$5] === 0), n3.emit("disconnect", n3[kUrl$4], [n3], s3), n3[kResume$3]();
    });
    let t4 = false;
    return A.on("close", () => {
      t4 = true;
    }), { version: "h1", defaultPipelining: 1, write(...n3) {
      return writeH1(e3, ...n3);
    }, resume() {
      resumeH1(e3);
    }, destroy(n3, r) {
      t4 ? queueMicrotask(r) : A.destroy(n3).on("close", r);
    }, get destroyed() {
      return A.destroyed;
    }, busy(n3) {
      return !!(A[kWriting] || A[kReset$1] || A[kBlocking] || n3 && (e3[kRunning$5] > 0 && !n3.idempotent || e3[kRunning$5] > 0 && (n3.upgrade || n3.method === "CONNECT") || e3[kRunning$5] > 0 && util$i.bodyLength(n3.body) !== 0 && (util$i.isStream(n3.body) || util$i.isAsyncIterable(n3.body) || util$i.isFormDataLike(n3.body))));
    } };
  }
  function resumeH1(e3) {
    const A = e3[kSocket$1];
    if (A && !A.destroyed) {
      if (e3[kSize$4] === 0 ? !A[kNoRef] && A.unref && (A.unref(), A[kNoRef] = true) : A[kNoRef] && A.ref && (A.ref(), A[kNoRef] = false), e3[kSize$4] === 0)
        A[kParser].timeoutType !== TIMEOUT_IDLE && A[kParser].setTimeout(e3[kKeepAliveTimeoutValue$1], TIMEOUT_IDLE);
      else if (e3[kRunning$5] > 0 && A[kParser].statusCode < 200 && A[kParser].timeoutType !== TIMEOUT_HEADERS) {
        const t4 = e3[kQueue$3][e3[kRunningIdx$2]], n3 = t4.headersTimeout != null ? t4.headersTimeout : e3[kHeadersTimeout$1];
        A[kParser].setTimeout(n3, TIMEOUT_HEADERS);
      }
    }
  }
  function shouldSendContentLength$1(e3) {
    return e3 !== "GET" && e3 !== "HEAD" && e3 !== "OPTIONS" && e3 !== "TRACE" && e3 !== "CONNECT";
  }
  function writeH1(e3, A) {
    const { method: t4, path: n3, host: r, upgrade: s3, blocking: i4, reset: E4 } = A;
    let { body: Q, headers: C, contentLength: I } = A;
    const a3 = t4 === "PUT" || t4 === "POST" || t4 === "PATCH";
    if (util$i.isFormDataLike(Q)) {
      extractBody || (extractBody = requireBody().extractBody);
      const [l3, S] = extractBody(Q);
      A.contentType == null && C.push("content-type", S), Q = l3.stream, I = l3.length;
    } else
      util$i.isBlobLike(Q) && A.contentType == null && Q.type && C.push("content-type", Q.type);
    Q && typeof Q.read == "function" && Q.read(0);
    const f3 = util$i.bodyLength(Q);
    if (I = f3 ?? I, I === null && (I = A.contentLength), I === 0 && !a3 && (I = null), shouldSendContentLength$1(t4) && I > 0 && A.contentLength !== null && A.contentLength !== I) {
      if (e3[kStrictContentLength$2])
        return util$i.errorRequest(e3, A, new RequestContentLengthMismatchError$1), false;
      process.emitWarning(new RequestContentLengthMismatchError$1);
    }
    const h4 = e3[kSocket$1], L = o4((l3) => {
      A.aborted || A.completed || (util$i.errorRequest(e3, A, l3 || new RequestAbortedError$5), util$i.destroy(Q), util$i.destroy(h4, new InformationalError$2("aborted")));
    }, "abort");
    try {
      A.onConnect(L);
    } catch (l3) {
      util$i.errorRequest(e3, A, l3);
    }
    if (A.aborted)
      return false;
    t4 === "HEAD" && (h4[kReset$1] = true), (s3 || t4 === "CONNECT") && (h4[kReset$1] = true), E4 != null && (h4[kReset$1] = E4), e3[kMaxRequests$1] && h4[kCounter$1]++ >= e3[kMaxRequests$1] && (h4[kReset$1] = true), i4 && (h4[kBlocking] = true);
    let c3 = `${t4} ${n3} HTTP/1.1\r
`;
    if (typeof r == "string" ? c3 += `host: ${r}\r
` : c3 += e3[kHostHeader$1], s3 ? c3 += `connection: upgrade\r
upgrade: ${s3}\r
` : e3[kPipelining$1] && !h4[kReset$1] ? c3 += `connection: keep-alive\r
` : c3 += `connection: close\r
`, Array.isArray(C))
      for (let l3 = 0;l3 < C.length; l3 += 2) {
        const S = C[l3 + 0], k3 = C[l3 + 1];
        if (Array.isArray(k3))
          for (let w = 0;w < k3.length; w++)
            c3 += `${S}: ${k3[w]}\r
`;
        else
          c3 += `${S}: ${k3}\r
`;
      }
    return channels$1.sendHeaders.hasSubscribers && channels$1.sendHeaders.publish({ request: A, headers: c3, socket: h4 }), !Q || f3 === 0 ? writeBuffer({ abort: L, body: null, client: e3, request: A, socket: h4, contentLength: I, header: c3, expectsPayload: a3 }) : util$i.isBuffer(Q) ? writeBuffer({ abort: L, body: Q, client: e3, request: A, socket: h4, contentLength: I, header: c3, expectsPayload: a3 }) : util$i.isBlobLike(Q) ? typeof Q.stream == "function" ? writeIterable$1({ abort: L, body: Q.stream(), client: e3, request: A, socket: h4, contentLength: I, header: c3, expectsPayload: a3 }) : writeBlob$1({ abort: L, body: Q, client: e3, request: A, socket: h4, contentLength: I, header: c3, expectsPayload: a3 }) : util$i.isStream(Q) ? writeStream$1({ abort: L, body: Q, client: e3, request: A, socket: h4, contentLength: I, header: c3, expectsPayload: a3 }) : util$i.isIterable(Q) ? writeIterable$1({ abort: L, body: Q, client: e3, request: A, socket: h4, contentLength: I, header: c3, expectsPayload: a3 }) : assert$a(false), true;
  }
  function writeStream$1({ abort: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    assert$a(s3 !== 0 || t4[kRunning$5] === 0, "stream body cannot be pipelined");
    let Q = false;
    const C = new AsyncWriter({ abort: e3, socket: r, request: n3, contentLength: s3, client: t4, expectsPayload: E4, header: i4 }), I = o4(function(L) {
      if (!Q)
        try {
          !C.write(L) && this.pause && this.pause();
        } catch (c3) {
          util$i.destroy(this, c3);
        }
    }, "onData"), a3 = o4(function() {
      Q || A.resume && A.resume();
    }, "onDrain"), f3 = o4(function() {
      if (queueMicrotask(() => {
        A.removeListener("error", h4);
      }), !Q) {
        const L = new RequestAbortedError$5;
        queueMicrotask(() => h4(L));
      }
    }, "onClose"), h4 = o4(function(L) {
      if (!Q) {
        if (Q = true, assert$a(r.destroyed || r[kWriting] && t4[kRunning$5] <= 1), r.off("drain", a3).off("error", h4), A.removeListener("data", I).removeListener("end", h4).removeListener("close", f3), !L)
          try {
            C.end();
          } catch (c3) {
            L = c3;
          }
        C.destroy(L), L && (L.code !== "UND_ERR_INFO" || L.message !== "reset") ? util$i.destroy(A, L) : util$i.destroy(A);
      }
    }, "onFinished");
    A.on("data", I).on("end", h4).on("error", h4).on("close", f3), A.resume && A.resume(), r.on("drain", a3).on("error", h4), A.errorEmitted ?? A.errored ? setImmediate(() => h4(A.errored)) : (A.endEmitted ?? A.readableEnded) && setImmediate(() => h4(null)), (A.closeEmitted ?? A.closed) && setImmediate(f3);
  }
  async function writeBuffer({ abort: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    try {
      A ? util$i.isBuffer(A) && (assert$a(s3 === A.byteLength, "buffer body must have content length"), r.cork(), r.write(`${i4}content-length: ${s3}\r
\r
`, "latin1"), r.write(A), r.uncork(), n3.onBodySent(A), E4 || (r[kReset$1] = true)) : s3 === 0 ? r.write(`${i4}content-length: 0\r
\r
`, "latin1") : (assert$a(s3 === null, "no body must not have content length"), r.write(`${i4}\r
`, "latin1")), n3.onRequestSent(), t4[kResume$3]();
    } catch (Q) {
      e3(Q);
    }
  }
  async function writeBlob$1({ abort: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    assert$a(s3 === A.size, "blob body must have content length");
    try {
      if (s3 != null && s3 !== A.size)
        throw new RequestContentLengthMismatchError$1;
      const Q = Buffer.from(await A.arrayBuffer());
      r.cork(), r.write(`${i4}content-length: ${s3}\r
\r
`, "latin1"), r.write(Q), r.uncork(), n3.onBodySent(Q), n3.onRequestSent(), E4 || (r[kReset$1] = true), t4[kResume$3]();
    } catch (Q) {
      e3(Q);
    }
  }
  async function writeIterable$1({ abort: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    assert$a(s3 !== 0 || t4[kRunning$5] === 0, "iterator body cannot be pipelined");
    let Q = null;
    function C() {
      if (Q) {
        const f3 = Q;
        Q = null, f3();
      }
    }
    o4(C, "onDrain");
    const I = o4(() => new Promise((f3, h4) => {
      assert$a(Q === null), r[kError$2] ? h4(r[kError$2]) : Q = f3;
    }), "waitForDrain");
    r.on("close", C).on("drain", C);
    const a3 = new AsyncWriter({ abort: e3, socket: r, request: n3, contentLength: s3, client: t4, expectsPayload: E4, header: i4 });
    try {
      for await (const f3 of A) {
        if (r[kError$2])
          throw r[kError$2];
        a3.write(f3) || await I();
      }
      a3.end();
    } catch (f3) {
      a3.destroy(f3);
    } finally {
      r.off("close", C).off("drain", C);
    }
  }
  function parseH2Headers(e3) {
    const A = [];
    for (const [t4, n3] of Object.entries(e3))
      if (Array.isArray(n3))
        for (const r of n3)
          A.push(Buffer.from(t4), Buffer.from(r));
      else
        A.push(Buffer.from(t4), Buffer.from(n3));
    return A;
  }
  async function connectH2$1(e3, A) {
    e3[kSocket] = A, h2ExperimentalWarned || (h2ExperimentalWarned = true, process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" }));
    const t4 = http2.connect(e3[kUrl$3], { createConnection: () => A, peerMaxConcurrentStreams: e3[kMaxConcurrentStreams$1] });
    t4[kOpenStreams] = 0, t4[kClient$2] = e3, t4[kSocket] = A, util$h.addListener(t4, "error", onHttp2SessionError), util$h.addListener(t4, "frameError", onHttp2FrameError), util$h.addListener(t4, "end", onHttp2SessionEnd), util$h.addListener(t4, "goaway", onHTTP2GoAway), util$h.addListener(t4, "close", function() {
      const { [kClient$2]: r } = this, s3 = this[kSocket][kError$1] || new SocketError$2("closed", util$h.getSocketInfo(this));
      r[kSocket] = null, r[kHTTP2Session] = null, assert$9(r[kPending$3] === 0);
      const i4 = r[kQueue$2].splice(r[kRunningIdx$1]);
      for (let E4 = 0;E4 < i4.length; E4++) {
        const Q = i4[E4];
        util$h.errorRequest(r, Q, s3);
      }
      r[kPendingIdx$1] = r[kRunningIdx$1], assert$9(r[kRunning$4] === 0), r.emit("disconnect", r[kUrl$3], [r], s3), r[kResume$2]();
    }), t4.unref(), e3[kHTTP2Session] = t4, A[kHTTP2Session] = t4, util$h.addListener(A, "error", function(r) {
      assert$9(r.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kError$1] = r, this[kClient$2][kOnError$1](r);
    }), util$h.addListener(A, "end", function() {
      util$h.destroy(this, new SocketError$2("other side closed", util$h.getSocketInfo(this)));
    });
    let n3 = false;
    return A.on("close", () => {
      n3 = true;
    }), { version: "h2", defaultPipelining: 1 / 0, write(...r) {
      writeH2(e3, ...r);
    }, resume() {
    }, destroy(r, s3) {
      t4.destroy(r), n3 ? queueMicrotask(s3) : A.destroy(r).on("close", s3);
    }, get destroyed() {
      return A.destroyed;
    }, busy() {
      return false;
    } };
  }
  function onHttp2SessionError(e3) {
    assert$9(e3.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kSocket][kError$1] = e3, this[kClient$2][kOnError$1](e3);
  }
  function onHttp2FrameError(e3, A, t4) {
    if (t4 === 0) {
      const n3 = new InformationalError$1(`HTTP/2: "frameError" received - type ${e3}, code ${A}`);
      this[kSocket][kError$1] = n3, this[kClient$2][kOnError$1](n3);
    }
  }
  function onHttp2SessionEnd() {
    const e3 = new SocketError$2("other side closed", util$h.getSocketInfo(this[kSocket]));
    this.destroy(e3), util$h.destroy(this[kSocket], e3);
  }
  function onHTTP2GoAway(e3) {
    const A = new InformationalError$1(`HTTP/2: "GOAWAY" frame received with code ${e3}`);
    this[kSocket][kError$1] = A, this[kClient$2][kOnError$1](A), this.unref(), this.destroy(), util$h.destroy(this[kSocket], A);
  }
  function shouldSendContentLength(e3) {
    return e3 !== "GET" && e3 !== "HEAD" && e3 !== "OPTIONS" && e3 !== "TRACE" && e3 !== "CONNECT";
  }
  function writeH2(e3, A) {
    const t4 = e3[kHTTP2Session], { body: n3, method: r, path: s3, host: i4, upgrade: E4, expectContinue: Q, signal: C, headers: I } = A;
    if (E4)
      return util$h.errorRequest(e3, A, new Error("Upgrade not supported for H2")), false;
    if (A.aborted)
      return false;
    const a3 = {};
    for (let w = 0;w < I.length; w += 2) {
      const U = I[w + 0], M = I[w + 1];
      if (Array.isArray(M))
        for (let B = 0;B < M.length; B++)
          a3[U] ? a3[U] += `,${M[B]}` : a3[U] = M[B];
      else
        a3[U] = M;
    }
    let f3;
    const { hostname: h4, port: L } = e3[kUrl$3];
    a3[HTTP2_HEADER_AUTHORITY] = i4 || `${h4}${L ? `:${L}` : ""}`, a3[HTTP2_HEADER_METHOD] = r;
    try {
      A.onConnect((w) => {
        A.aborted || A.completed || (w = w || new RequestAbortedError$4, f3 != null && (util$h.destroy(f3, w), t4[kOpenStreams] -= 1, t4[kOpenStreams] === 0 && t4.unref()), util$h.errorRequest(e3, A, w));
      });
    } catch (w) {
      util$h.errorRequest(e3, A, w);
    }
    if (r === "CONNECT")
      return t4.ref(), f3 = t4.request(a3, { endStream: false, signal: C }), f3.id && !f3.pending ? (A.onUpgrade(null, null, f3), ++t4[kOpenStreams]) : f3.once("ready", () => {
        A.onUpgrade(null, null, f3), ++t4[kOpenStreams];
      }), f3.once("close", () => {
        t4[kOpenStreams] -= 1, t4[kOpenStreams] === 0 && t4.unref();
      }), true;
    a3[HTTP2_HEADER_PATH] = s3, a3[HTTP2_HEADER_SCHEME] = "https";
    const c3 = r === "PUT" || r === "POST" || r === "PATCH";
    n3 && typeof n3.read == "function" && n3.read(0);
    let l3 = util$h.bodyLength(n3);
    if (l3 == null && (l3 = A.contentLength), (l3 === 0 || !c3) && (l3 = null), shouldSendContentLength(r) && l3 > 0 && A.contentLength != null && A.contentLength !== l3) {
      if (e3[kStrictContentLength$1])
        return util$h.errorRequest(e3, A, new RequestContentLengthMismatchError), false;
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    l3 != null && (assert$9(n3, "no body must not have content length"), a3[HTTP2_HEADER_CONTENT_LENGTH] = `${l3}`), t4.ref();
    const S = r === "GET" || r === "HEAD" || n3 === null;
    return Q ? (a3[HTTP2_HEADER_EXPECT] = "100-continue", f3 = t4.request(a3, { endStream: S, signal: C }), f3.once("continue", k3)) : (f3 = t4.request(a3, { endStream: S, signal: C }), k3()), ++t4[kOpenStreams], f3.once("response", (w) => {
      const { [HTTP2_HEADER_STATUS]: U, ...M } = w;
      if (A.onResponseStarted(), A.aborted || A.completed) {
        const B = new RequestAbortedError$4;
        util$h.errorRequest(e3, A, B), util$h.destroy(f3, B);
        return;
      }
      A.onHeaders(Number(U), parseH2Headers(M), f3.resume.bind(f3), "") === false && f3.pause(), f3.on("data", (B) => {
        A.onData(B) === false && f3.pause();
      });
    }), f3.once("end", () => {
      if (f3.state?.state == null || f3.state.state < 6) {
        A.onComplete([]);
        return;
      }
      t4[kOpenStreams] -= 1, t4[kOpenStreams] === 0 && t4.unref();
      const w = new InformationalError$1("HTTP/2: stream half-closed (remote)");
      util$h.errorRequest(e3, A, w), util$h.destroy(f3, w);
    }), f3.once("close", () => {
      t4[kOpenStreams] -= 1, t4[kOpenStreams] === 0 && t4.unref();
    }), f3.once("error", function(w) {
      e3[kHTTP2Session] && !e3[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (t4[kOpenStreams] -= 1, util$h.errorRequest(e3, A, w), util$h.destroy(f3, w));
    }), f3.once("frameError", (w, U) => {
      const M = new InformationalError$1(`HTTP/2: "frameError" received - type ${w}, code ${U}`);
      util$h.errorRequest(e3, A, M), e3[kHTTP2Session] && !e3[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (t4[kOpenStreams] -= 1, util$h.destroy(f3, M));
    }), true;
    function k3() {
      n3 ? util$h.isBuffer(n3) ? (assert$9(l3 === n3.byteLength, "buffer body must have content length"), f3.cork(), f3.write(n3), f3.uncork(), f3.end(), A.onBodySent(n3), A.onRequestSent()) : util$h.isBlobLike(n3) ? typeof n3.stream == "function" ? writeIterable({ client: e3, request: A, contentLength: l3, h2stream: f3, expectsPayload: c3, body: n3.stream(), socket: e3[kSocket], header: "" }) : writeBlob({ body: n3, client: e3, request: A, contentLength: l3, expectsPayload: c3, h2stream: f3, header: "", socket: e3[kSocket] }) : util$h.isStream(n3) ? writeStream({ body: n3, client: e3, request: A, contentLength: l3, expectsPayload: c3, socket: e3[kSocket], h2stream: f3, header: "" }) : util$h.isIterable(n3) ? writeIterable({ body: n3, client: e3, request: A, contentLength: l3, expectsPayload: c3, header: "", h2stream: f3, socket: e3[kSocket] }) : assert$9(false) : A.onRequestSent();
    }
    o4(k3, "writeBodyH2");
  }
  function writeStream({ h2stream: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    assert$9(s3 !== 0 || t4[kRunning$4] === 0, "stream body cannot be pipelined");
    const Q = pipeline$1(A, e3, (I) => {
      I ? (util$h.destroy(A, I), util$h.destroy(e3, I)) : n3.onRequestSent();
    });
    Q.on("data", C), Q.once("end", () => {
      Q.removeListener("data", C), util$h.destroy(Q);
    });
    function C(I) {
      n3.onBodySent(I);
    }
    o4(C, "onPipeData");
  }
  async function writeBlob({ h2stream: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    assert$9(s3 === A.size, "blob body must have content length");
    try {
      if (s3 != null && s3 !== A.size)
        throw new RequestContentLengthMismatchError;
      const Q = Buffer.from(await A.arrayBuffer());
      e3.cork(), e3.write(Q), e3.uncork(), n3.onBodySent(Q), n3.onRequestSent(), E4 || (r[kReset] = true), t4[kResume$2]();
    } catch {
      util$h.destroy(e3);
    }
  }
  async function writeIterable({ h2stream: e3, body: A, client: t4, request: n3, socket: r, contentLength: s3, header: i4, expectsPayload: E4 }) {
    assert$9(s3 !== 0 || t4[kRunning$4] === 0, "iterator body cannot be pipelined");
    let Q = null;
    function C() {
      if (Q) {
        const a3 = Q;
        Q = null, a3();
      }
    }
    o4(C, "onDrain");
    const I = o4(() => new Promise((a3, f3) => {
      assert$9(Q === null), r[kError$1] ? f3(r[kError$1]) : Q = a3;
    }), "waitForDrain");
    e3.on("close", C).on("drain", C);
    try {
      for await (const a3 of A) {
        if (r[kError$1])
          throw r[kError$1];
        const f3 = e3.write(a3);
        n3.onBodySent(a3), f3 || await I();
      }
    } catch (a3) {
      e3.destroy(a3);
    } finally {
      n3.onRequestSent(), e3.end(), e3.off("close", C).off("drain", C);
    }
  }
  function parseLocation(e3, A) {
    if (redirectableStatusCodes.indexOf(e3) === -1)
      return null;
    for (let t4 = 0;t4 < A.length; t4 += 2)
      if (A[t4].length === 8 && util$g.headerNameToString(A[t4]) === "location")
        return A[t4 + 1];
  }
  function shouldRemoveHeader(e3, A, t4) {
    if (e3.length === 4)
      return util$g.headerNameToString(e3) === "host";
    if (A && util$g.headerNameToString(e3).startsWith("content-"))
      return true;
    if (t4 && (e3.length === 13 || e3.length === 6 || e3.length === 19)) {
      const n3 = util$g.headerNameToString(e3);
      return n3 === "authorization" || n3 === "cookie" || n3 === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(e3, A, t4) {
    const n3 = [];
    if (Array.isArray(e3))
      for (let r = 0;r < e3.length; r += 2)
        shouldRemoveHeader(e3[r], A, t4) || n3.push(e3[r], e3[r + 1]);
    else if (e3 && typeof e3 == "object")
      for (const r of Object.keys(e3))
        shouldRemoveHeader(r, A, t4) || n3.push(r, e3[r]);
    else
      assert$8(e3 == null, "headers must be an object or an array");
    return n3;
  }
  function createRedirectInterceptor$2({ maxRedirections: e3 }) {
    return (A) => o4(function(n3, r) {
      const { maxRedirections: s3 = e3 } = n3;
      if (!s3)
        return A(n3, r);
      const i4 = new RedirectHandler(A, s3, n3, r);
      return n3 = { ...n3, maxRedirections: 0 }, A(n3, i4);
    }, "Intercept");
  }
  function getPipelining(e3) {
    return e3[kPipelining] ?? e3[kHTTPContext]?.defaultPipelining ?? 1;
  }
  function onError(e3, A) {
    if (e3[kRunning$3] === 0 && A.code !== "UND_ERR_INFO" && A.code !== "UND_ERR_SOCKET") {
      assert$7(e3[kPendingIdx] === e3[kRunningIdx]);
      const t4 = e3[kQueue$1].splice(e3[kRunningIdx]);
      for (let n3 = 0;n3 < t4.length; n3++) {
        const r = t4[n3];
        util$f.errorRequest(e3, r, A);
      }
      assert$7(e3[kSize$3] === 0);
    }
  }
  async function connect$1(e3) {
    assert$7(!e3[kConnecting]), assert$7(!e3[kHTTPContext]);
    let { host: A, hostname: t4, protocol: n3, port: r } = e3[kUrl$2];
    if (t4[0] === "[") {
      const s3 = t4.indexOf("]");
      assert$7(s3 !== -1);
      const i4 = t4.substring(1, s3);
      assert$7(net.isIP(i4)), t4 = i4;
    }
    e3[kConnecting] = true, channels.beforeConnect.hasSubscribers && channels.beforeConnect.publish({ connectParams: { host: A, hostname: t4, protocol: n3, port: r, version: e3[kHTTPContext]?.version, servername: e3[kServerName], localAddress: e3[kLocalAddress] }, connector: e3[kConnector] });
    try {
      const s3 = await new Promise((i4, E4) => {
        e3[kConnector]({ host: A, hostname: t4, protocol: n3, port: r, servername: e3[kServerName], localAddress: e3[kLocalAddress] }, (Q, C) => {
          Q ? E4(Q) : i4(C);
        });
      });
      if (e3.destroyed) {
        util$f.destroy(s3.on("error", () => {
        }), new ClientDestroyedError);
        return;
      }
      assert$7(s3);
      try {
        e3[kHTTPContext] = s3.alpnProtocol === "h2" ? await connectH2(e3, s3) : await connectH1(e3, s3);
      } catch (i4) {
        throw s3.destroy().on("error", () => {
        }), i4;
      }
      e3[kConnecting] = false, s3[kCounter] = 0, s3[kMaxRequests] = e3[kMaxRequests], s3[kClient$1] = e3, s3[kError] = null, channels.connected.hasSubscribers && channels.connected.publish({ connectParams: { host: A, hostname: t4, protocol: n3, port: r, version: e3[kHTTPContext]?.version, servername: e3[kServerName], localAddress: e3[kLocalAddress] }, connector: e3[kConnector], socket: s3 }), e3.emit("connect", e3[kUrl$2], [e3]);
    } catch (s3) {
      if (e3.destroyed)
        return;
      if (e3[kConnecting] = false, channels.connectError.hasSubscribers && channels.connectError.publish({ connectParams: { host: A, hostname: t4, protocol: n3, port: r, version: e3[kHTTPContext]?.version, servername: e3[kServerName], localAddress: e3[kLocalAddress] }, connector: e3[kConnector], error: s3 }), s3.code === "ERR_TLS_CERT_ALTNAME_INVALID")
        for (assert$7(e3[kRunning$3] === 0);e3[kPending$2] > 0 && e3[kQueue$1][e3[kPendingIdx]].servername === e3[kServerName]; ) {
          const i4 = e3[kQueue$1][e3[kPendingIdx]++];
          util$f.errorRequest(e3, i4, s3);
        }
      else
        onError(e3, s3);
      e3.emit("connectionError", e3[kUrl$2], [e3], s3);
    }
    e3[kResume$1]();
  }
  function emitDrain(e3) {
    e3[kNeedDrain$2] = 0, e3.emit("drain", e3[kUrl$2], [e3]);
  }
  function resume(e3, A) {
    e3[kResuming] !== 2 && (e3[kResuming] = 2, _resume(e3, A), e3[kResuming] = 0, e3[kRunningIdx] > 256 && (e3[kQueue$1].splice(0, e3[kRunningIdx]), e3[kPendingIdx] -= e3[kRunningIdx], e3[kRunningIdx] = 0));
  }
  function _resume(e3, A) {
    for (;; ) {
      if (e3.destroyed) {
        assert$7(e3[kPending$2] === 0);
        return;
      }
      if (e3[kClosedResolve$1] && !e3[kSize$3]) {
        e3[kClosedResolve$1](), e3[kClosedResolve$1] = null;
        return;
      }
      if (e3[kHTTPContext] && e3[kHTTPContext].resume(), e3[kBusy$1])
        e3[kNeedDrain$2] = 2;
      else if (e3[kNeedDrain$2] === 2) {
        A ? (e3[kNeedDrain$2] = 1, queueMicrotask(() => emitDrain(e3))) : emitDrain(e3);
        continue;
      }
      if (e3[kPending$2] === 0 || e3[kRunning$3] >= (getPipelining(e3) || 1))
        return;
      const t4 = e3[kQueue$1][e3[kPendingIdx]];
      if (e3[kUrl$2].protocol === "https:" && e3[kServerName] !== t4.servername) {
        if (e3[kRunning$3] > 0)
          return;
        e3[kServerName] = t4.servername, e3[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          e3[kHTTPContext] = null, resume(e3);
        });
      }
      if (e3[kConnecting])
        return;
      if (!e3[kHTTPContext]) {
        connect$1(e3);
        return;
      }
      if (e3[kHTTPContext].destroyed || e3[kHTTPContext].busy(t4))
        return;
      !t4.aborted && e3[kHTTPContext].write(t4) ? e3[kPendingIdx]++ : e3[kQueue$1].splice(e3[kPendingIdx], 1);
    }
  }
  function defaultFactory$2(e3, A) {
    return new Client$2(e3, A);
  }
  function defaultFactory$1(e3, A) {
    return A && A.connections === 1 ? new Client$1(e3, A) : new Pool$2(e3, A);
  }
  function defaultProtocolPort(e3) {
    return e3 === "https:" ? 443 : 80;
  }
  function defaultFactory(e3, A) {
    return new Pool$1(e3, A);
  }
  function buildHeaders(e3) {
    if (Array.isArray(e3)) {
      const A = {};
      for (let t4 = 0;t4 < e3.length; t4 += 2)
        A[e3[t4]] = e3[t4 + 1];
      return A;
    }
    return e3;
  }
  function throwIfProxyAuthIsSent(e3) {
    if (e3 && Object.keys(e3).find((t4) => t4.toLowerCase() === "proxy-authorization"))
      throw new InvalidArgumentError$b("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  function isLocked(e3) {
    return e3[kBody] && e3[kBody].locked === true || e3[kConsume];
  }
  function isUnusable(e3) {
    return util$c.isDisturbed(e3) || isLocked(e3);
  }
  async function consume(e3, A) {
    return assert$6(!e3[kConsume]), new Promise((t4, n3) => {
      if (isUnusable(e3)) {
        const r = e3._readableState;
        r.destroyed && r.closeEmitted === false ? e3.on("error", (s3) => {
          n3(s3);
        }).on("close", () => {
          n3(new TypeError("unusable"));
        }) : n3(r.errored ?? new TypeError("unusable"));
      } else
        queueMicrotask(() => {
          e3[kConsume] = { type: A, stream: e3, resolve: t4, reject: n3, length: 0, body: [] }, e3.on("error", function(r) {
            consumeFinish(this[kConsume], r);
          }).on("close", function() {
            this[kConsume].body !== null && consumeFinish(this[kConsume], new RequestAbortedError$2);
          }), consumeStart(e3[kConsume]);
        });
    });
  }
  function consumeStart(e3) {
    if (e3.body === null)
      return;
    const { _readableState: A } = e3.stream;
    if (A.bufferIndex) {
      const t4 = A.bufferIndex, n3 = A.buffer.length;
      for (let r = t4;r < n3; r++)
        consumePush(e3, A.buffer[r]);
    } else
      for (const t4 of A.buffer)
        consumePush(e3, t4);
    for (A.endEmitted ? consumeEnd(this[kConsume]) : e3.stream.on("end", function() {
      consumeEnd(this[kConsume]);
    }), e3.stream.resume();e3.stream.read() != null; )
      ;
  }
  function chunksDecode$1(e3, A) {
    if (e3.length === 0 || A === 0)
      return "";
    const t4 = e3.length === 1 ? e3[0] : Buffer.concat(e3, A), n3 = t4.length, r = n3 > 2 && t4[0] === 239 && t4[1] === 187 && t4[2] === 191 ? 3 : 0;
    return t4.utf8Slice(r, n3);
  }
  function consumeEnd(e3) {
    const { type: A, body: t4, resolve: n3, stream: r, length: s3 } = e3;
    try {
      if (A === "text")
        n3(chunksDecode$1(t4, s3));
      else if (A === "json")
        n3(JSON.parse(chunksDecode$1(t4, s3)));
      else if (A === "arrayBuffer") {
        const i4 = new Uint8Array(s3);
        let E4 = 0;
        for (const Q of t4)
          i4.set(Q, E4), E4 += Q.byteLength;
        n3(i4.buffer);
      } else
        A === "blob" && n3(new Blob(t4, { type: r[kContentType] }));
      consumeFinish(e3);
    } catch (i4) {
      r.destroy(i4);
    }
  }
  function consumePush(e3, A) {
    e3.length += A.length, e3.body.push(A);
  }
  function consumeFinish(e3, A) {
    e3.body !== null && (A ? e3.reject(A) : e3.resolve(), e3.type = null, e3.stream = null, e3.resolve = null, e3.reject = null, e3.length = 0, e3.body = null);
  }
  async function getResolveErrorBodyCallback$2({ callback: e3, body: A, contentType: t4, statusCode: n3, statusMessage: r, headers: s3 }) {
    assert$5(A);
    let i4 = [], E4 = 0;
    for await (const a3 of A)
      if (i4.push(a3), E4 += a3.length, E4 > CHUNK_LIMIT) {
        i4 = null;
        break;
      }
    const Q = `Response status code ${n3}${r ? `: ${r}` : ""}`;
    if (n3 === 204 || !t4 || !i4) {
      queueMicrotask(() => e3(new ResponseStatusCodeError(Q, n3, s3)));
      return;
    }
    const C = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    let I;
    try {
      isContentTypeApplicationJson(t4) ? I = JSON.parse(chunksDecode(i4, E4)) : isContentTypeText(t4) && (I = chunksDecode(i4, E4));
    } catch {
    } finally {
      Error.stackTraceLimit = C;
    }
    queueMicrotask(() => e3(new ResponseStatusCodeError(Q, n3, s3, I)));
  }
  function abort(e3) {
    e3.abort ? e3.abort(e3[kSignal]?.reason) : e3.reason = e3[kSignal]?.reason ?? new RequestAbortedError$1, removeSignal$5(e3);
  }
  function addSignal$5(e3, A) {
    if (e3.reason = null, e3[kSignal] = null, e3[kListener] = null, !!A) {
      if (A.aborted) {
        abort(e3);
        return;
      }
      e3[kSignal] = A, e3[kListener] = () => {
        abort(e3);
      }, addAbortListener(e3[kSignal], e3[kListener]);
    }
  }
  function removeSignal$5(e3) {
    e3[kSignal] && (("removeEventListener" in e3[kSignal]) ? e3[kSignal].removeEventListener("abort", e3[kListener]) : e3[kSignal].removeListener("abort", e3[kListener]), e3[kSignal] = null, e3[kListener] = null);
  }
  function request$1(e3, A) {
    if (A === undefined)
      return new Promise((t4, n3) => {
        request$1.call(this, e3, (r, s3) => r ? n3(r) : t4(s3));
      });
    try {
      this.dispatch(e3, new RequestHandler(e3, A));
    } catch (t4) {
      if (typeof A != "function")
        throw t4;
      const n3 = e3?.opaque;
      queueMicrotask(() => A(t4, { opaque: n3 }));
    }
  }
  function stream(e3, A, t4) {
    if (t4 === undefined)
      return new Promise((n3, r) => {
        stream.call(this, e3, A, (s3, i4) => s3 ? r(s3) : n3(i4));
      });
    try {
      this.dispatch(e3, new StreamHandler(e3, A, t4));
    } catch (n3) {
      if (typeof t4 != "function")
        throw n3;
      const r = e3?.opaque;
      queueMicrotask(() => t4(n3, { opaque: r }));
    }
  }
  function pipeline(e3, A) {
    try {
      const t4 = new PipelineHandler(e3, A);
      return this.dispatch({ ...e3, body: t4.req }, t4), t4.ret;
    } catch (t4) {
      return new PassThrough().destroy(t4);
    }
  }
  function upgrade(e3, A) {
    if (A === undefined)
      return new Promise((t4, n3) => {
        upgrade.call(this, e3, (r, s3) => r ? n3(r) : t4(s3));
      });
    try {
      const t4 = new UpgradeHandler(e3, A);
      this.dispatch({ ...e3, method: e3.method || "GET", upgrade: e3.protocol || "Websocket" }, t4);
    } catch (t4) {
      if (typeof A != "function")
        throw t4;
      const n3 = e3?.opaque;
      queueMicrotask(() => A(t4, { opaque: n3 }));
    }
  }
  function connect(e3, A) {
    if (A === undefined)
      return new Promise((t4, n3) => {
        connect.call(this, e3, (r, s3) => r ? n3(r) : t4(s3));
      });
    try {
      const t4 = new ConnectHandler(e3, A);
      this.dispatch({ ...e3, method: "CONNECT" }, t4);
    } catch (t4) {
      if (typeof A != "function")
        throw t4;
      const n3 = e3?.opaque;
      queueMicrotask(() => A(t4, { opaque: n3 }));
    }
  }
  function matchValue(e3, A) {
    return typeof e3 == "string" ? e3 === A : e3 instanceof RegExp ? e3.test(A) : typeof e3 == "function" ? e3(A) === true : false;
  }
  function lowerCaseEntries(e3) {
    return Object.fromEntries(Object.entries(e3).map(([A, t4]) => [A.toLocaleLowerCase(), t4]));
  }
  function getHeaderByName(e3, A) {
    if (Array.isArray(e3)) {
      for (let t4 = 0;t4 < e3.length; t4 += 2)
        if (e3[t4].toLocaleLowerCase() === A.toLocaleLowerCase())
          return e3[t4 + 1];
      return;
    } else
      return typeof e3.get == "function" ? e3.get(A) : lowerCaseEntries(e3)[A.toLocaleLowerCase()];
  }
  function buildHeadersFromArray(e3) {
    const A = e3.slice(), t4 = [];
    for (let n3 = 0;n3 < A.length; n3 += 2)
      t4.push([A[n3], A[n3 + 1]]);
    return Object.fromEntries(t4);
  }
  function matchHeaders(e3, A) {
    if (typeof e3.headers == "function")
      return Array.isArray(A) && (A = buildHeadersFromArray(A)), e3.headers(A ? lowerCaseEntries(A) : {});
    if (typeof e3.headers > "u")
      return true;
    if (typeof A != "object" || typeof e3.headers != "object")
      return false;
    for (const [t4, n3] of Object.entries(e3.headers)) {
      const r = getHeaderByName(A, t4);
      if (!matchValue(n3, r))
        return false;
    }
    return true;
  }
  function safeUrl(e3) {
    if (typeof e3 != "string")
      return e3;
    const A = e3.split("?");
    if (A.length !== 2)
      return e3;
    const t4 = new URLSearchParams(A.pop());
    return t4.sort(), [...A, t4.toString()].join("?");
  }
  function matchKey(e3, { path: A, method: t4, body: n3, headers: r }) {
    const s3 = matchValue(e3.path, A), i4 = matchValue(e3.method, t4), E4 = typeof e3.body < "u" ? matchValue(e3.body, n3) : true, Q = matchHeaders(e3, r);
    return s3 && i4 && E4 && Q;
  }
  function getResponseData$1(e3) {
    return Buffer.isBuffer(e3) ? e3 : typeof e3 == "object" ? JSON.stringify(e3) : e3.toString();
  }
  function getMockDispatch(e3, A) {
    const t4 = A.query ? buildURL$1(A.path, A.query) : A.path, n3 = typeof t4 == "string" ? safeUrl(t4) : t4;
    let r = e3.filter(({ consumed: s3 }) => !s3).filter(({ path: s3 }) => matchValue(safeUrl(s3), n3));
    if (r.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${n3}'`);
    if (r = r.filter(({ method: s3 }) => matchValue(s3, A.method)), r.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${A.method}' on path '${n3}'`);
    if (r = r.filter(({ body: s3 }) => typeof s3 < "u" ? matchValue(s3, A.body) : true), r.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${A.body}' on path '${n3}'`);
    if (r = r.filter((s3) => matchHeaders(s3, A.headers)), r.length === 0) {
      const s3 = typeof A.headers == "object" ? JSON.stringify(A.headers) : A.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${s3}' on path '${n3}'`);
    }
    return r[0];
  }
  function addMockDispatch$1(e3, A, t4) {
    const n3 = { timesInvoked: 0, times: 1, persist: false, consumed: false }, r = typeof t4 == "function" ? { callback: t4 } : { ...t4 }, s3 = { ...n3, ...A, pending: true, data: { error: null, ...r } };
    return e3.push(s3), s3;
  }
  function deleteMockDispatch(e3, A) {
    const t4 = e3.findIndex((n3) => n3.consumed ? matchKey(n3, A) : false);
    t4 !== -1 && e3.splice(t4, 1);
  }
  function buildKey$1(e3) {
    const { path: A, method: t4, body: n3, headers: r, query: s3 } = e3;
    return { path: A, method: t4, body: n3, headers: r, query: s3 };
  }
  function generateKeyValues(e3) {
    const A = Object.keys(e3), t4 = [];
    for (let n3 = 0;n3 < A.length; ++n3) {
      const r = A[n3], s3 = e3[r], i4 = Buffer.from(`${r}`);
      if (Array.isArray(s3))
        for (let E4 = 0;E4 < s3.length; ++E4)
          t4.push(i4, Buffer.from(`${s3[E4]}`));
      else
        t4.push(i4, Buffer.from(`${s3}`));
    }
    return t4;
  }
  function getStatusText(e3) {
    return STATUS_CODES[e3] || "unknown";
  }
  async function getResponse(e3) {
    const A = [];
    for await (const t4 of e3)
      A.push(t4);
    return Buffer.concat(A).toString("utf8");
  }
  function mockDispatch(e3, A) {
    const t4 = buildKey$1(e3), n3 = getMockDispatch(this[kDispatches$3], t4);
    n3.timesInvoked++, n3.data.callback && (n3.data = { ...n3.data, ...n3.data.callback(e3) });
    const { data: { statusCode: r, data: s3, headers: i4, trailers: E4, error: Q }, delay: C, persist: I } = n3, { timesInvoked: a3, times: f3 } = n3;
    if (n3.consumed = !I && a3 >= f3, n3.pending = a3 < f3, Q !== null)
      return deleteMockDispatch(this[kDispatches$3], t4), A.onError(Q), true;
    typeof C == "number" && C > 0 ? setTimeout(() => {
      h4(this[kDispatches$3]);
    }, C) : h4(this[kDispatches$3]);
    function h4(c3, l3 = s3) {
      const S = Array.isArray(e3.headers) ? buildHeadersFromArray(e3.headers) : e3.headers, k3 = typeof l3 == "function" ? l3({ ...e3, headers: S }) : l3;
      if (isPromise(k3)) {
        k3.then((B) => h4(c3, B));
        return;
      }
      const w = getResponseData$1(k3), U = generateKeyValues(i4), M = generateKeyValues(E4);
      A.onConnect?.((B) => A.onError(B), null), A.onHeaders?.(r, U, L, getStatusText(r)), A.onData?.(Buffer.from(w)), A.onComplete?.(M), deleteMockDispatch(c3, t4);
    }
    o4(h4, "handleReply");
    function L() {
    }
    return o4(L, "resume"), true;
  }
  function buildMockDispatch$2() {
    const e3 = this[kMockAgent$2], A = this[kOrigin$2], t4 = this[kOriginalDispatch$2];
    return o4(function(r, s3) {
      if (e3.isMockActive)
        try {
          mockDispatch.call(this, r, s3);
        } catch (i4) {
          if (i4 instanceof MockNotMatchedError) {
            const E4 = e3[kGetNetConnect]();
            if (E4 === false)
              throw new MockNotMatchedError(`${i4.message}: subsequent request to origin ${A} was not allowed (net.connect disabled)`);
            if (checkNetConnect(E4, A))
              t4.call(this, r, s3);
            else
              throw new MockNotMatchedError(`${i4.message}: subsequent request to origin ${A} was not allowed (net.connect is not enabled for this origin)`);
          } else
            throw i4;
        }
      else
        t4.call(this, r, s3);
    }, "dispatch");
  }
  function checkNetConnect(e3, A) {
    const t4 = new URL(A);
    return e3 === true ? true : !!(Array.isArray(e3) && e3.some((n3) => matchValue(n3, t4.host)));
  }
  function buildMockOptions(e3) {
    if (e3) {
      const { agent: A, ...t4 } = e3;
      return t4;
    }
  }
  function setGlobalDispatcher$1(e3) {
    if (!e3 || typeof e3.dispatch != "function")
      throw new InvalidArgumentError$1("Argument agent must implement Agent");
    Object.defineProperty(globalThis, globalDispatcher, { value: e3, writable: true, enumerable: false, configurable: false });
  }
  function getGlobalDispatcher$1() {
    return globalThis[globalDispatcher];
  }
  function requireHeaders() {
    if (hasRequiredHeaders)
      return headers;
    hasRequiredHeaders = 1;
    const { kHeadersList: e3, kConstruct: A } = symbols$4, { kGuard: t4 } = requireSymbols$3(), { kEnumerableProperty: n3 } = util$m, { iteratorMixin: r, isValidHeaderName: s3, isValidHeaderValue: i4 } = requireUtil$5(), { webidl: E4 } = requireWebidl(), Q = require$$0__default, C = require$$0__default$1, I = Symbol("headers map"), a3 = Symbol("headers map sorted");
    function f3(M) {
      return M === 10 || M === 13 || M === 9 || M === 32;
    }
    o4(f3, "isHTTPWhiteSpaceCharCode");
    function h4(M) {
      let B = 0, D = M.length;
      for (;D > B && f3(M.charCodeAt(D - 1)); )
        --D;
      for (;D > B && f3(M.charCodeAt(B)); )
        ++B;
      return B === 0 && D === M.length ? M : M.substring(B, D);
    }
    o4(h4, "headerValueNormalize");
    function L(M, B) {
      if (Array.isArray(B))
        for (let D = 0;D < B.length; ++D) {
          const G = B[D];
          if (G.length !== 2)
            throw E4.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${G.length}.` });
          c3(M, G[0], G[1]);
        }
      else if (typeof B == "object" && B !== null) {
        const D = Object.keys(B);
        for (let G = 0;G < D.length; ++G)
          c3(M, D[G], B[D[G]]);
      } else
        throw E4.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
    }
    o4(L, "fill");
    function c3(M, B, D) {
      if (D = h4(D), s3(B)) {
        if (!i4(D))
          throw E4.errors.invalidArgument({ prefix: "Headers.append", value: D, type: "header value" });
      } else
        throw E4.errors.invalidArgument({ prefix: "Headers.append", value: B, type: "header name" });
      if (M[t4] === "immutable")
        throw new TypeError("immutable");
      return M[t4], M[e3].append(B, D, false);
    }
    o4(c3, "appendHeader");
    function l3(M, B) {
      return M[0] < B[0] ? -1 : 1;
    }
    o4(l3, "compareHeaderName");
    const w = class w4 {
      constructor(B) {
        NA(this, "cookies", null);
        B instanceof w4 ? (this[I] = new Map(B[I]), this[a3] = B[a3], this.cookies = B.cookies === null ? null : [...B.cookies]) : (this[I] = new Map(B), this[a3] = null);
      }
      contains(B, D) {
        return this[I].has(D ? B : B.toLowerCase());
      }
      clear() {
        this[I].clear(), this[a3] = null, this.cookies = null;
      }
      append(B, D, G) {
        this[a3] = null;
        const g3 = G ? B : B.toLowerCase(), d3 = this[I].get(g3);
        if (d3) {
          const F = g3 === "cookie" ? "; " : ", ";
          this[I].set(g3, { name: d3.name, value: `${d3.value}${F}${D}` });
        } else
          this[I].set(g3, { name: B, value: D });
        g3 === "set-cookie" && (this.cookies ?? (this.cookies = [])).push(D);
      }
      set(B, D, G) {
        this[a3] = null;
        const g3 = G ? B : B.toLowerCase();
        g3 === "set-cookie" && (this.cookies = [D]), this[I].set(g3, { name: B, value: D });
      }
      delete(B, D) {
        this[a3] = null, D || (B = B.toLowerCase()), B === "set-cookie" && (this.cookies = null), this[I].delete(B);
      }
      get(B, D) {
        return this[I].get(D ? B : B.toLowerCase())?.value ?? null;
      }
      *[Symbol.iterator]() {
        for (const { 0: B, 1: { value: D } } of this[I])
          yield [B, D];
      }
      get entries() {
        const B = {};
        if (this[I].size)
          for (const { name: D, value: G } of this[I].values())
            B[D] = G;
        return B;
      }
      toSortedArray() {
        const B = this[I].size, D = new Array(B);
        if (B <= 32) {
          if (B === 0)
            return D;
          const G = this[I][Symbol.iterator](), g3 = G.next().value;
          D[0] = [g3[0], g3[1].value], Q(g3[1].value !== null);
          for (let d3 = 1, F = 0, N = 0, u = 0, b = 0, m3, T;d3 < B; ++d3) {
            for (T = G.next().value, m3 = D[d3] = [T[0], T[1].value], Q(m3[1] !== null), u = 0, N = d3;u < N; )
              b = u + (N - u >> 1), D[b][0] <= m3[0] ? u = b + 1 : N = b;
            if (d3 !== b) {
              for (F = d3;F > u; )
                D[F] = D[--F];
              D[u] = m3;
            }
          }
          if (!G.next().done)
            throw new TypeError("Unreachable");
          return D;
        } else {
          let G = 0;
          for (const { 0: g3, 1: { value: d3 } } of this[I])
            D[G++] = [g3, d3], Q(d3 !== null);
          return D.sort(l3);
        }
      }
    };
    o4(w, "HeadersList");
    let S = w;
    const U = class U2 {
      constructor(B = undefined) {
        B !== A && (this[e3] = new S, this[t4] = "none", B !== undefined && (B = E4.converters.HeadersInit(B), L(this, B)));
      }
      append(B, D) {
        return E4.brandCheck(this, U2), E4.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), B = E4.converters.ByteString(B), D = E4.converters.ByteString(D), c3(this, B, D);
      }
      delete(B) {
        if (E4.brandCheck(this, U2), E4.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), B = E4.converters.ByteString(B), !s3(B))
          throw E4.errors.invalidArgument({ prefix: "Headers.delete", value: B, type: "header name" });
        if (this[t4] === "immutable")
          throw new TypeError("immutable");
        this[t4], this[e3].contains(B, false) && this[e3].delete(B, false);
      }
      get(B) {
        if (E4.brandCheck(this, U2), E4.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), B = E4.converters.ByteString(B), !s3(B))
          throw E4.errors.invalidArgument({ prefix: "Headers.get", value: B, type: "header name" });
        return this[e3].get(B, false);
      }
      has(B) {
        if (E4.brandCheck(this, U2), E4.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), B = E4.converters.ByteString(B), !s3(B))
          throw E4.errors.invalidArgument({ prefix: "Headers.has", value: B, type: "header name" });
        return this[e3].contains(B, false);
      }
      set(B, D) {
        if (E4.brandCheck(this, U2), E4.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), B = E4.converters.ByteString(B), D = E4.converters.ByteString(D), D = h4(D), s3(B)) {
          if (!i4(D))
            throw E4.errors.invalidArgument({ prefix: "Headers.set", value: D, type: "header value" });
        } else
          throw E4.errors.invalidArgument({ prefix: "Headers.set", value: B, type: "header name" });
        if (this[t4] === "immutable")
          throw new TypeError("immutable");
        this[t4], this[e3].set(B, D, false);
      }
      getSetCookie() {
        E4.brandCheck(this, U2);
        const B = this[e3].cookies;
        return B ? [...B] : [];
      }
      get [a3]() {
        if (this[e3][a3])
          return this[e3][a3];
        const B = [], D = this[e3].toSortedArray(), G = this[e3].cookies;
        if (G === null || G.length === 1)
          return this[e3][a3] = D;
        for (let g3 = 0;g3 < D.length; ++g3) {
          const { 0: d3, 1: F } = D[g3];
          if (d3 === "set-cookie")
            for (let N = 0;N < G.length; ++N)
              B.push([d3, G[N]]);
          else
            B.push([d3, F]);
        }
        return this[e3][a3] = B;
      }
      [C.inspect.custom](B, D) {
        return D.depth ?? (D.depth = B), `Headers ${C.formatWithOptions(D, this[e3].entries)}`;
      }
    };
    o4(U, "Headers");
    let k3 = U;
    return Object.defineProperty(k3.prototype, C.inspect.custom, { enumerable: false }), r("Headers", k3, a3, 0, 1), Object.defineProperties(k3.prototype, { append: n3, delete: n3, get: n3, has: n3, set: n3, getSetCookie: n3, [Symbol.toStringTag]: { value: "Headers", configurable: true } }), E4.converters.HeadersInit = function(M) {
      if (E4.util.Type(M) === "Object") {
        const B = Reflect.get(M, Symbol.iterator);
        return typeof B == "function" ? E4.converters["sequence<sequence<ByteString>>"](M, B.bind(M)) : E4.converters["record<ByteString, ByteString>"](M);
      }
      throw E4.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
    }, headers = { fill: L, compareHeaderName: l3, Headers: k3, HeadersList: S }, headers;
  }
  function requireResponse() {
    if (hasRequiredResponse)
      return response;
    hasRequiredResponse = 1;
    const { Headers: e3, HeadersList: A, fill: t4 } = requireHeaders(), { extractBody: n3, cloneBody: r, mixinBody: s3 } = requireBody(), i4 = util$m, E4 = require$$0__default$1, { kEnumerableProperty: Q } = i4, { isValidReasonPhrase: C, isCancelled: I, isAborted: a3, isBlobLike: f3, serializeJavascriptValueToJSONString: h4, isErrorLike: L, isomorphicEncode: c3 } = requireUtil$5(), { redirectStatusSet: l3, nullBodyStatus: S } = requireConstants$2(), { kState: k3, kHeaders: w, kGuard: U, kRealm: M } = requireSymbols$3(), { webidl: B } = requireWebidl(), { FormData: D } = requireFormdata(), { getGlobalOrigin: G } = requireGlobal(), { URLSerializer: g3 } = requireDataUrl(), { kHeadersList: d3, kConstruct: F } = symbols$4, N = require$$0__default, { types: u } = require$$0__default$1, b = new TextEncoder("utf-8"), $ = class $2 {
      static error() {
        const q = { settingsObject: {} };
        return X(Z(), "immutable", q);
      }
      static json(q, z = {}) {
        B.argumentLengthCheck(arguments, 1, { header: "Response.json" }), z !== null && (z = B.converters.ResponseInit(z));
        const rA = b.encode(h4(q)), iA = n3(rA), gA = { settingsObject: {} }, BA = X(v3({}), "response", gA);
        return aA(BA, z, { body: iA[0], type: "application/json" }), BA;
      }
      static redirect(q, z = 302) {
        const rA = { settingsObject: {} };
        B.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), q = B.converters.USVString(q), z = B.converters["unsigned short"](z);
        let iA;
        try {
          iA = new URL(q, G());
        } catch (sA) {
          throw new TypeError(`Failed to parse URL from ${q}`, { cause: sA });
        }
        if (!l3.has(z))
          throw new RangeError(`Invalid status code ${z}`);
        const gA = X(v3({}), "immutable", rA);
        gA[k3].status = z;
        const BA = c3(g3(iA));
        return gA[k3].headersList.append("location", BA, true), gA;
      }
      constructor(q = null, z = {}) {
        if (q === F)
          return;
        q !== null && (q = B.converters.BodyInit(q)), z = B.converters.ResponseInit(z), this[M] = { settingsObject: {} }, this[k3] = v3({}), this[w] = new e3(F), this[w][U] = "response", this[w][d3] = this[k3].headersList, this[w][M] = this[M];
        let rA = null;
        if (q != null) {
          const [iA, gA] = n3(q);
          rA = { body: iA, type: gA };
        }
        aA(this, z, rA);
      }
      get type() {
        return B.brandCheck(this, $2), this[k3].type;
      }
      get url() {
        B.brandCheck(this, $2);
        const q = this[k3].urlList, z = q[q.length - 1] ?? null;
        return z === null ? "" : g3(z, true);
      }
      get redirected() {
        return B.brandCheck(this, $2), this[k3].urlList.length > 1;
      }
      get status() {
        return B.brandCheck(this, $2), this[k3].status;
      }
      get ok() {
        return B.brandCheck(this, $2), this[k3].status >= 200 && this[k3].status <= 299;
      }
      get statusText() {
        return B.brandCheck(this, $2), this[k3].statusText;
      }
      get headers() {
        return B.brandCheck(this, $2), this[w];
      }
      get body() {
        return B.brandCheck(this, $2), this[k3].body ? this[k3].body.stream : null;
      }
      get bodyUsed() {
        return B.brandCheck(this, $2), !!this[k3].body && i4.isDisturbed(this[k3].body.stream);
      }
      clone() {
        if (B.brandCheck(this, $2), this.bodyUsed || this.body?.locked)
          throw B.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
        const q = T(this[k3]);
        return X(q, this[w][U], this[M]);
      }
      [E4.inspect.custom](q, z) {
        z.depth === null && (z.depth = 2), z.colors ?? (z.colors = true);
        const rA = { status: this.status, statusText: this.statusText, headers: this.headers, body: this.body, bodyUsed: this.bodyUsed, ok: this.ok, redirected: this.redirected, type: this.type, url: this.url };
        return `Response ${E4.formatWithOptions(z, rA)}`;
      }
    };
    o4($, "Response");
    let m3 = $;
    s3(m3), Object.defineProperties(m3.prototype, { type: Q, url: Q, status: Q, ok: Q, redirected: Q, statusText: Q, headers: Q, clone: Q, body: Q, bodyUsed: Q, [Symbol.toStringTag]: { value: "Response", configurable: true } }), Object.defineProperties(m3, { json: Q, redirect: Q, error: Q });
    function T(V2) {
      if (V2.internalResponse)
        return K(T(V2.internalResponse), V2.type);
      const q = v3({ ...V2, body: null });
      return V2.body != null && (q.body = r(V2.body)), q;
    }
    o4(T, "cloneResponse");
    function v3(V2) {
      return { aborted: false, rangeRequested: false, timingAllowPassed: false, requestIncludesCredentials: false, type: "default", status: 200, timingInfo: null, cacheState: "", statusText: "", ...V2, headersList: V2?.headersList ? new A(V2?.headersList) : new A, urlList: V2?.urlList ? [...V2.urlList] : [] };
    }
    o4(v3, "makeResponse");
    function Z(V2) {
      const q = L(V2);
      return v3({ type: "error", status: 0, error: q ? V2 : new Error(V2 && String(V2)), aborted: V2 && V2.name === "AbortError" });
    }
    o4(Z, "makeNetworkError");
    function P(V2) {
      return V2.type === "error" && V2.status === 0;
    }
    o4(P, "isNetworkError");
    function AA(V2, q) {
      return q = { internalResponse: V2, ...q }, new Proxy(V2, { get(z, rA) {
        return rA in q ? q[rA] : z[rA];
      }, set(z, rA, iA) {
        return N(!(rA in q)), z[rA] = iA, true;
      } });
    }
    o4(AA, "makeFilteredResponse");
    function K(V2, q) {
      if (q === "basic")
        return AA(V2, { type: "basic", headersList: V2.headersList });
      if (q === "cors")
        return AA(V2, { type: "cors", headersList: V2.headersList });
      if (q === "opaque")
        return AA(V2, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
      if (q === "opaqueredirect")
        return AA(V2, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
      N(false);
    }
    o4(K, "filterResponse");
    function tA(V2, q = null) {
      return N(I(V2)), a3(V2) ? Z(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: q })) : Z(Object.assign(new DOMException("Request was cancelled."), { cause: q }));
    }
    o4(tA, "makeAppropriateNetworkError");
    function aA(V2, q, z) {
      if (q.status !== null && (q.status < 200 || q.status > 599))
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      if ("statusText" in q && q.statusText != null && !C(String(q.statusText)))
        throw new TypeError("Invalid statusText");
      if ("status" in q && q.status != null && (V2[k3].status = q.status), "statusText" in q && q.statusText != null && (V2[k3].statusText = q.statusText), "headers" in q && q.headers != null && t4(V2[w], q.headers), z) {
        if (S.includes(V2.status))
          throw B.errors.exception({ header: "Response constructor", message: `Invalid response status code ${V2.status}` });
        V2[k3].body = z.body, z.type != null && !V2[k3].headersList.contains("content-type", true) && V2[k3].headersList.append("content-type", z.type, true);
      }
    }
    o4(aA, "initializeResponse");
    function X(V2, q, z) {
      const rA = new m3(F);
      return rA[k3] = V2, rA[M] = z, rA[w] = new e3(F), rA[w][d3] = V2.headersList, rA[w][U] = q, rA[w][M] = z, rA;
    }
    return o4(X, "fromInnerResponse"), B.converters.ReadableStream = B.interfaceConverter(ReadableStream), B.converters.FormData = B.interfaceConverter(D), B.converters.URLSearchParams = B.interfaceConverter(URLSearchParams), B.converters.XMLHttpRequestBodyInit = function(V2) {
      return typeof V2 == "string" ? B.converters.USVString(V2) : f3(V2) ? B.converters.Blob(V2, { strict: false }) : ArrayBuffer.isView(V2) || u.isArrayBuffer(V2) ? B.converters.BufferSource(V2) : i4.isFormDataLike(V2) ? B.converters.FormData(V2, { strict: false }) : V2 instanceof URLSearchParams ? B.converters.URLSearchParams(V2) : B.converters.DOMString(V2);
    }, B.converters.BodyInit = function(V2) {
      return V2 instanceof ReadableStream ? B.converters.ReadableStream(V2) : V2?.[Symbol.asyncIterator] ? V2 : B.converters.XMLHttpRequestBodyInit(V2);
    }, B.converters.ResponseInit = B.dictionaryConverter([{ key: "status", converter: B.converters["unsigned short"], defaultValue: 200 }, { key: "statusText", converter: B.converters.ByteString, defaultValue: "" }, { key: "headers", converter: B.converters.HeadersInit }]), response = { isNetworkError: P, makeNetworkError: Z, makeResponse: v3, makeAppropriateNetworkError: tA, filterResponse: K, Response: m3, cloneResponse: T, fromInnerResponse: X }, response;
  }
  function requireDispatcherWeakref() {
    if (hasRequiredDispatcherWeakref)
      return dispatcherWeakref;
    hasRequiredDispatcherWeakref = 1;
    const { kConnected: e3, kSize: A } = symbols$4, r = class r3 {
      constructor(E4) {
        this.value = E4;
      }
      deref() {
        return this.value[e3] === 0 && this.value[A] === 0 ? undefined : this.value;
      }
    };
    o4(r, "CompatWeakRef");
    let t4 = r;
    const s3 = class s4 {
      constructor(E4) {
        this.finalizer = E4;
      }
      register(E4, Q) {
        E4.on && E4.on("disconnect", () => {
          E4[e3] === 0 && E4[A] === 0 && this.finalizer(Q);
        });
      }
      unregister(E4) {
      }
    };
    o4(s3, "CompatFinalizer");
    let n3 = s3;
    return dispatcherWeakref = o4(function() {
      return process.env.NODE_V8_COVERAGE ? { WeakRef: t4, FinalizationRegistry: n3 } : { WeakRef, FinalizationRegistry };
    }, "dispatcherWeakref"), dispatcherWeakref;
  }
  function requireRequest() {
    if (hasRequiredRequest)
      return request;
    hasRequiredRequest = 1;
    const { extractBody: e3, mixinBody: A, cloneBody: t4 } = requireBody(), { Headers: n3, fill: r, HeadersList: s3 } = requireHeaders(), { FinalizationRegistry: i4 } = requireDispatcherWeakref()(), E4 = util$m, Q = require$$0__default$1, { isValidHTTPToken: C, sameOrigin: I, normalizeMethod: a3, makePolicyContainer: f3, normalizeMethodRecord: h4 } = requireUtil$5(), { forbiddenMethodsSet: L, corsSafeListedMethodsSet: c3, referrerPolicy: l3, requestRedirect: S, requestMode: k3, requestCredentials: w, requestCache: U, requestDuplex: M } = requireConstants$2(), { kEnumerableProperty: B } = E4, { kHeaders: D, kSignal: G, kState: g3, kGuard: d3, kRealm: F, kDispatcher: N } = requireSymbols$3(), { webidl: u } = requireWebidl(), { getGlobalOrigin: b } = requireGlobal(), { URLSerializer: m3 } = requireDataUrl(), { kHeadersList: T, kConstruct: v3 } = symbols$4, Z = require$$0__default, { getMaxListeners: P, setMaxListeners: AA, getEventListeners: K, defaultMaxListeners: tA } = require$$0__default$3, aA = Symbol("abortController"), X = new i4(({ signal: gA, abort: BA }) => {
      gA.removeEventListener("abort", BA);
    });
    let $ = false;
    const iA = class iA2 {
      constructor(BA, sA = {}) {
        if (BA === v3)
          return;
        u.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), BA = u.converters.RequestInfo(BA), sA = u.converters.RequestInit(sA), this[F] = { settingsObject: { baseUrl: b(), get origin() {
          return this.baseUrl?.origin;
        }, policyContainer: f3() } };
        let eA = null, yA = null;
        const WA = this[F].settingsObject.baseUrl;
        let wA = null;
        if (typeof BA == "string") {
          this[N] = sA.dispatcher;
          let IA;
          try {
            IA = new URL(BA, WA);
          } catch (hA) {
            throw new TypeError("Failed to parse URL from " + BA, { cause: hA });
          }
          if (IA.username || IA.password)
            throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + BA);
          eA = q({ urlList: [IA] }), yA = "cors";
        } else
          this[N] = sA.dispatcher || BA[N], Z(BA instanceof iA2), eA = BA[g3], wA = BA[G];
        const qA = this[F].settingsObject.origin;
        let MA = "client";
        if (eA.window?.constructor?.name === "EnvironmentSettingsObject" && I(eA.window, qA) && (MA = eA.window), sA.window != null)
          throw new TypeError(`'window' option '${MA}' must be null`);
        "window" in sA && (MA = "no-window"), eA = q({ method: eA.method, headersList: eA.headersList, unsafeRequest: eA.unsafeRequest, client: this[F].settingsObject, window: MA, priority: eA.priority, origin: eA.origin, referrer: eA.referrer, referrerPolicy: eA.referrerPolicy, mode: eA.mode, credentials: eA.credentials, cache: eA.cache, redirect: eA.redirect, integrity: eA.integrity, keepalive: eA.keepalive, reloadNavigation: eA.reloadNavigation, historyNavigation: eA.historyNavigation, urlList: [...eA.urlList] });
        const HA = Object.keys(sA).length !== 0;
        if (HA && (eA.mode === "navigate" && (eA.mode = "same-origin"), eA.reloadNavigation = false, eA.historyNavigation = false, eA.origin = "client", eA.referrer = "client", eA.referrerPolicy = "", eA.url = eA.urlList[eA.urlList.length - 1], eA.urlList = [eA.url]), sA.referrer !== undefined) {
          const IA = sA.referrer;
          if (IA === "")
            eA.referrer = "no-referrer";
          else {
            let hA;
            try {
              hA = new URL(IA, WA);
            } catch (SA) {
              throw new TypeError(`Referrer "${IA}" is not a valid URL.`, { cause: SA });
            }
            hA.protocol === "about:" && hA.hostname === "client" || qA && !I(hA, this[F].settingsObject.baseUrl) ? eA.referrer = "client" : eA.referrer = hA;
          }
        }
        sA.referrerPolicy !== undefined && (eA.referrerPolicy = sA.referrerPolicy);
        let pA;
        if (sA.mode !== undefined ? pA = sA.mode : pA = yA, pA === "navigate")
          throw u.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
        if (pA != null && (eA.mode = pA), sA.credentials !== undefined && (eA.credentials = sA.credentials), sA.cache !== undefined && (eA.cache = sA.cache), eA.cache === "only-if-cached" && eA.mode !== "same-origin")
          throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
        if (sA.redirect !== undefined && (eA.redirect = sA.redirect), sA.integrity != null && (eA.integrity = String(sA.integrity)), sA.keepalive !== undefined && (eA.keepalive = !!sA.keepalive), sA.method !== undefined) {
          let IA = sA.method;
          const hA = h4[IA];
          if (hA !== undefined)
            eA.method = hA;
          else {
            if (!C(IA))
              throw new TypeError(`'${IA}' is not a valid HTTP method.`);
            if (L.has(IA.toUpperCase()))
              throw new TypeError(`'${IA}' HTTP method is unsupported.`);
            IA = a3(IA), eA.method = IA;
          }
          !$ && eA.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" }), $ = true);
        }
        sA.signal !== undefined && (wA = sA.signal), this[g3] = eA;
        const YA = new AbortController;
        if (this[G] = YA.signal, this[G][F] = this[F], wA != null) {
          if (!wA || typeof wA.aborted != "boolean" || typeof wA.addEventListener != "function")
            throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
          if (wA.aborted)
            YA.abort(wA.reason);
          else {
            this[aA] = YA;
            const IA = new WeakRef(YA), hA = o4(function() {
              const SA = IA.deref();
              SA !== undefined && (X.unregister(hA), this.removeEventListener("abort", hA), SA.abort(this.reason));
            }, "abort");
            try {
              (typeof P == "function" && P(wA) === tA || K(wA, "abort").length >= tA) && AA(100, wA);
            } catch {
            }
            E4.addAbortListener(wA, hA), X.register(YA, { signal: wA, abort: hA }, hA);
          }
        }
        if (this[D] = new n3(v3), this[D][T] = eA.headersList, this[D][d3] = "request", this[D][F] = this[F], pA === "no-cors") {
          if (!c3.has(eA.method))
            throw new TypeError(`'${eA.method} is unsupported in no-cors mode.`);
          this[D][d3] = "request-no-cors";
        }
        if (HA) {
          const IA = this[D][T], hA = sA.headers !== undefined ? sA.headers : new s3(IA);
          if (IA.clear(), hA instanceof s3) {
            for (const [SA, PA] of hA)
              IA.append(SA, PA);
            IA.cookies = hA.cookies;
          } else
            r(this[D], hA);
        }
        const UA = BA instanceof iA2 ? BA[g3].body : null;
        if ((sA.body != null || UA != null) && (eA.method === "GET" || eA.method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        let JA = null;
        if (sA.body != null) {
          const [IA, hA] = e3(sA.body, eA.keepalive);
          JA = IA, hA && !this[D][T].contains("content-type", true) && this[D].append("content-type", hA);
        }
        const VA = JA ?? UA;
        if (VA != null && VA.source == null) {
          if (JA != null && sA.duplex == null)
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          if (eA.mode !== "same-origin" && eA.mode !== "cors")
            throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
          eA.useCORSPreflightFlag = true;
        }
        let OA = VA;
        if (JA == null && UA != null) {
          if (E4.isDisturbed(UA.stream) || UA.stream.locked)
            throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
          const IA = new TransformStream;
          UA.stream.pipeThrough(IA), OA = { source: UA.source, length: UA.length, stream: IA.readable };
        }
        this[g3].body = OA;
      }
      get method() {
        return u.brandCheck(this, iA2), this[g3].method;
      }
      get url() {
        return u.brandCheck(this, iA2), m3(this[g3].url);
      }
      get headers() {
        return u.brandCheck(this, iA2), this[D];
      }
      get destination() {
        return u.brandCheck(this, iA2), this[g3].destination;
      }
      get referrer() {
        return u.brandCheck(this, iA2), this[g3].referrer === "no-referrer" ? "" : this[g3].referrer === "client" ? "about:client" : this[g3].referrer.toString();
      }
      get referrerPolicy() {
        return u.brandCheck(this, iA2), this[g3].referrerPolicy;
      }
      get mode() {
        return u.brandCheck(this, iA2), this[g3].mode;
      }
      get credentials() {
        return this[g3].credentials;
      }
      get cache() {
        return u.brandCheck(this, iA2), this[g3].cache;
      }
      get redirect() {
        return u.brandCheck(this, iA2), this[g3].redirect;
      }
      get integrity() {
        return u.brandCheck(this, iA2), this[g3].integrity;
      }
      get keepalive() {
        return u.brandCheck(this, iA2), this[g3].keepalive;
      }
      get isReloadNavigation() {
        return u.brandCheck(this, iA2), this[g3].reloadNavigation;
      }
      get isHistoryNavigation() {
        return u.brandCheck(this, iA2), this[g3].historyNavigation;
      }
      get signal() {
        return u.brandCheck(this, iA2), this[G];
      }
      get body() {
        return u.brandCheck(this, iA2), this[g3].body ? this[g3].body.stream : null;
      }
      get bodyUsed() {
        return u.brandCheck(this, iA2), !!this[g3].body && E4.isDisturbed(this[g3].body.stream);
      }
      get duplex() {
        return u.brandCheck(this, iA2), "half";
      }
      clone() {
        if (u.brandCheck(this, iA2), this.bodyUsed || this.body?.locked)
          throw new TypeError("unusable");
        const BA = z(this[g3]), sA = new AbortController;
        return this.signal.aborted ? sA.abort(this.signal.reason) : E4.addAbortListener(this.signal, () => {
          sA.abort(this.signal.reason);
        }), rA(BA, sA.signal, this[D][d3], this[F]);
      }
      [Q.inspect.custom](BA, sA) {
        sA.depth === null && (sA.depth = 2), sA.colors ?? (sA.colors = true);
        const eA = { method: this.method, url: this.url, headers: this.headers, destination: this.destination, referrer: this.referrer, referrerPolicy: this.referrerPolicy, mode: this.mode, credentials: this.credentials, cache: this.cache, redirect: this.redirect, integrity: this.integrity, keepalive: this.keepalive, isReloadNavigation: this.isReloadNavigation, isHistoryNavigation: this.isHistoryNavigation, signal: this.signal };
        return `Request ${Q.formatWithOptions(sA, eA)}`;
      }
    };
    o4(iA, "Request");
    let V2 = iA;
    A(V2);
    function q(gA) {
      const BA = { method: "GET", localURLsOnly: false, unsafeRequest: false, body: null, client: null, reservedClient: null, replacesClientId: "", window: "client", keepalive: false, serviceWorkers: "all", initiator: "", destination: "", priority: null, origin: "client", policyContainer: "client", referrer: "client", referrerPolicy: "", mode: "no-cors", useCORSPreflightFlag: false, credentials: "same-origin", useCredentials: false, cache: "default", redirect: "follow", integrity: "", cryptoGraphicsNonceMetadata: "", parserMetadata: "", reloadNavigation: false, historyNavigation: false, userActivation: false, taintedOrigin: false, redirectCount: 0, responseTainting: "basic", preventNoCacheCacheControlHeaderModification: false, done: false, timingAllowFailed: false, ...gA, headersList: gA.headersList ? new s3(gA.headersList) : new s3 };
      return BA.url = BA.urlList[0], BA;
    }
    o4(q, "makeRequest");
    function z(gA) {
      const BA = q({ ...gA, body: null });
      return gA.body != null && (BA.body = t4(gA.body)), BA;
    }
    o4(z, "cloneRequest");
    function rA(gA, BA, sA, eA) {
      const yA = new V2(v3);
      return yA[g3] = gA, yA[F] = eA, yA[G] = BA, yA[G][F] = eA, yA[D] = new n3(v3), yA[D][T] = gA.headersList, yA[D][d3] = sA, yA[D][F] = eA, yA;
    }
    return o4(rA, "fromInnerRequest"), Object.defineProperties(V2.prototype, { method: B, url: B, headers: B, redirect: B, clone: B, signal: B, duplex: B, destination: B, body: B, bodyUsed: B, isHistoryNavigation: B, isReloadNavigation: B, keepalive: B, integrity: B, cache: B, credentials: B, attribute: B, referrerPolicy: B, referrer: B, mode: B, [Symbol.toStringTag]: { value: "Request", configurable: true } }), u.converters.Request = u.interfaceConverter(V2), u.converters.RequestInfo = function(gA) {
      return typeof gA == "string" ? u.converters.USVString(gA) : gA instanceof V2 ? u.converters.Request(gA) : u.converters.USVString(gA);
    }, u.converters.AbortSignal = u.interfaceConverter(AbortSignal), u.converters.RequestInit = u.dictionaryConverter([{ key: "method", converter: u.converters.ByteString }, { key: "headers", converter: u.converters.HeadersInit }, { key: "body", converter: u.nullableConverter(u.converters.BodyInit) }, { key: "referrer", converter: u.converters.USVString }, { key: "referrerPolicy", converter: u.converters.DOMString, allowedValues: l3 }, { key: "mode", converter: u.converters.DOMString, allowedValues: k3 }, { key: "credentials", converter: u.converters.DOMString, allowedValues: w }, { key: "cache", converter: u.converters.DOMString, allowedValues: U }, { key: "redirect", converter: u.converters.DOMString, allowedValues: S }, { key: "integrity", converter: u.converters.DOMString }, { key: "keepalive", converter: u.converters.boolean }, { key: "signal", converter: u.nullableConverter((gA) => u.converters.AbortSignal(gA, { strict: false })) }, { key: "window", converter: u.converters.any }, { key: "duplex", converter: u.converters.DOMString, allowedValues: M }, { key: "dispatcher", converter: u.converters.any }]), request = { Request: V2, makeRequest: q, fromInnerRequest: rA, cloneRequest: z }, request;
  }
  function requireFetch() {
    if (hasRequiredFetch)
      return fetch_1;
    hasRequiredFetch = 1;
    const { makeNetworkError: e3, makeAppropriateNetworkError: A, filterResponse: t4, makeResponse: n3, fromInnerResponse: r } = requireResponse(), { HeadersList: s3 } = requireHeaders(), { Request: i4, cloneRequest: E4 } = requireRequest(), Q = zlib__default, { bytesMatch: C, makePolicyContainer: I, clonePolicyContainer: a3, requestBadPort: f3, TAOCheck: h4, appendRequestOriginHeader: L, responseLocationURL: c3, requestCurrentURL: l3, setRequestReferrerPolicyOnRedirect: S, tryUpgradeRequestToAPotentiallyTrustworthyURL: k3, createOpaqueTimingInfo: w, appendFetchMetadata: U, corsCheck: M, crossOriginResourcePolicyCheck: B, determineRequestsReferrer: D, coarsenedSharedCurrentTime: G, createDeferredPromise: g3, isBlobLike: d3, sameOrigin: F, isCancelled: N, isAborted: u, isErrorLike: b, fullyReadBody: m3, readableStreamClose: T, isomorphicEncode: v3, urlIsLocal: Z, urlIsHttpHttpsScheme: P, urlHasHttpsScheme: AA, clampAndCoarsenConnectionTimingInfo: K, simpleRangeHeaderValue: tA, buildContentRange: aA, createInflate: X, extractMimeType: $ } = requireUtil$5(), { kState: V2, kDispatcher: q } = requireSymbols$3(), z = require$$0__default, { safelyExtractBody: rA, extractBody: iA } = requireBody(), { redirectStatusSet: gA, nullBodyStatus: BA, safeMethodsSet: sA, requestBodyHeader: eA, subresourceSet: yA } = requireConstants$2(), WA = require$$0__default$3, { Readable: wA, pipeline: qA } = Stream__default, { addAbortListener: MA, isErrored: HA, isReadable: pA, nodeMajor: YA, nodeMinor: UA, bufferToLowerCasedHeaderName: JA } = util$m, { dataURLProcessor: VA, serializeAMimeType: OA, minimizeSupportedMimeType: IA } = requireDataUrl(), { getGlobalDispatcher: hA } = global2, { webidl: SA } = requireWebidl(), { STATUS_CODES: PA } = http__default, Pe = ["GET", "HEAD"], ee = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici";
    let ZA;
    const nA = class nA2 extends WA {
      constructor(O) {
        super(), this.dispatcher = O, this.connection = null, this.dump = false, this.state = "ongoing";
      }
      terminate(O) {
        this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(O), this.emit("terminated", O));
      }
      abort(O) {
        this.state === "ongoing" && (this.state = "aborted", O || (O = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = O, this.connection?.destroy(O), this.emit("terminated", O));
      }
    };
    o4(nA, "Fetch");
    let XA = nA;
    function Ze(R, O = undefined) {
      SA.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const H = g3();
      let J;
      try {
        J = new i4(R, O);
      } catch (oA) {
        return H.reject(oA), H.promise;
      }
      const _ = J[V2];
      if (J.signal.aborted)
        return te(H, _, null, J.signal.reason), H.promise;
      _.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (_.serviceWorkers = "none");
      let QA = null;
      const lA = null;
      let uA = false, cA = null;
      return MA(J.signal, () => {
        uA = true, z(cA != null), cA.abort(J.signal.reason), te(H, _, QA, J.signal.reason);
      }), cA = Ve({ request: _, processResponseEndOfBody: o4((oA) => KA(oA, "fetch"), "handleFetchDone"), processResponse: o4((oA) => {
        if (!uA) {
          if (oA.aborted) {
            te(H, _, QA, cA.serializedAbortReason);
            return;
          }
          if (oA.type === "error") {
            H.reject(new TypeError("fetch failed", { cause: oA.error }));
            return;
          }
          QA = r(oA, "immutable", lA), H.resolve(QA);
        }
      }, "processResponse"), dispatcher: J[q] }), H.promise;
    }
    o4(Ze, "fetch");
    function KA(R, O = "other") {
      if (R.type === "error" && R.aborted || !R.urlList?.length)
        return;
      const H = R.urlList[0];
      let { timingInfo: J, cacheState: _ } = R;
      P(H) && J !== null && (R.timingAllowPassed || (J = w({ startTime: J.startTime }), _ = ""), J.endTime = G(), R.timingInfo = J, He(J, H.href, O, globalThis, _));
    }
    o4(KA, "finalizeAndReportTiming");
    const He = YA > 18 || YA === 18 && UA >= 2 ? performance.markResourceTiming : () => {
    };
    function te(R, O, H, J) {
      if (R.reject(J), O.body != null && pA(O.body?.stream) && O.body.stream.cancel(J).catch((x) => {
        if (x.code !== "ERR_INVALID_STATE")
          throw x;
      }), H == null)
        return;
      const _ = H[V2];
      _.body != null && pA(_.body?.stream) && _.body.stream.cancel(J).catch((x) => {
        if (x.code !== "ERR_INVALID_STATE")
          throw x;
      });
    }
    o4(te, "abortFetch");
    function Ve({ request: R, processRequestBodyChunkLength: O, processRequestEndOfBody: H, processResponse: J, processResponseEndOfBody: _, processResponseConsumeBody: x, useParallelQueue: QA = false, dispatcher: lA = hA() }) {
      z(lA);
      let uA = null, cA = false;
      R.client != null && (uA = R.client.globalObject, cA = R.client.crossOriginIsolatedCapability);
      const fA = G(cA), mA = w({ startTime: fA }), oA = { controller: new XA(lA), request: R, timingInfo: mA, processRequestBodyChunkLength: O, processRequestEndOfBody: H, processResponse: J, processResponseConsumeBody: x, processResponseEndOfBody: _, taskDestination: uA, crossOriginIsolatedCapability: cA };
      return z(!R.body || R.body.stream), R.window === "client" && (R.window = R.client?.globalObject?.constructor?.name === "Window" ? R.client : "no-window"), R.origin === "client" && (R.origin = R.client?.origin), R.policyContainer === "client" && (R.client != null ? R.policyContainer = a3(R.client.policyContainer) : R.policyContainer = I()), R.headersList.contains("accept", true) || R.headersList.append("accept", "*/*", true), R.headersList.contains("accept-language", true) || R.headersList.append("accept-language", "*", true), R.priority, yA.has(R.destination), re(oA).catch((RA) => {
        oA.controller.terminate(RA);
      }), oA.controller;
    }
    o4(Ve, "fetching");
    async function re(R, O = false) {
      const H = R.request;
      let J = null;
      if (H.localURLsOnly && !Z(l3(H)) && (J = e3("local URLs only")), k3(H), f3(H) === "blocked" && (J = e3("bad port")), H.referrerPolicy === "" && (H.referrerPolicy = H.policyContainer.referrerPolicy), H.referrer !== "no-referrer" && (H.referrer = D(H)), J === null && (J = await (async () => {
        const x = l3(H);
        return F(x, H.url) && H.responseTainting === "basic" || x.protocol === "data:" || H.mode === "navigate" || H.mode === "websocket" ? (H.responseTainting = "basic", await ve(R)) : H.mode === "same-origin" ? e3('request mode cannot be "same-origin"') : H.mode === "no-cors" ? H.redirect !== "follow" ? e3('redirect mode cannot be "follow" for "no-cors" request') : (H.responseTainting = "opaque", await ve(R)) : P(l3(H)) ? (H.responseTainting = "cors", await y3(R)) : e3("URL scheme must be a HTTP(S) scheme");
      })()), O)
        return J;
      J.status !== 0 && !J.internalResponse && (H.responseTainting, H.responseTainting === "basic" ? J = t4(J, "basic") : H.responseTainting === "cors" ? J = t4(J, "cors") : H.responseTainting === "opaque" ? J = t4(J, "opaque") : z(false));
      let _ = J.status === 0 ? J : J.internalResponse;
      if (_.urlList.length === 0 && _.urlList.push(...H.urlList), H.timingAllowFailed || (J.timingAllowPassed = true), J.type === "opaque" && _.status === 206 && _.rangeRequested && !H.headers.contains("range", true) && (J = _ = e3()), J.status !== 0 && (H.method === "HEAD" || H.method === "CONNECT" || BA.includes(_.status)) && (_.body = null, R.controller.dump = true), H.integrity) {
        const x = o4((lA) => vA(R, e3(lA)), "processBodyError");
        if (H.responseTainting === "opaque" || J.body == null) {
          x(J.error);
          return;
        }
        const QA = o4((lA) => {
          if (!C(lA, H.integrity)) {
            x("integrity mismatch");
            return;
          }
          J.body = rA(lA)[0], vA(R, J);
        }, "processBody");
        await m3(J.body, QA, x);
      } else
        vA(R, J);
    }
    o4(re, "mainFetch");
    function ve(R) {
      if (N(R) && R.request.redirectCount === 0)
        return Promise.resolve(A(R));
      const { request: O } = R, { protocol: H } = l3(O);
      switch (H) {
        case "about:":
          return Promise.resolve(e3("about scheme is not supported"));
        case "blob:": {
          ZA || (ZA = require$$6__default.resolveObjectURL);
          const J = l3(O);
          if (J.search.length !== 0)
            return Promise.resolve(e3("NetworkError when attempting to fetch resource."));
          const _ = ZA(J.toString());
          if (O.method !== "GET" || !d3(_))
            return Promise.resolve(e3("invalid method"));
          const x = n3(), QA = _.size, lA = v3(`${QA}`), uA = _.type;
          if (O.headersList.contains("range", true)) {
            x.rangeRequested = true;
            const cA = O.headersList.get("range", true), fA = tA(cA, true);
            if (fA === "failure")
              return Promise.resolve(e3("failed to fetch the data URL"));
            let { rangeStartValue: mA, rangeEndValue: oA } = fA;
            if (mA === null)
              mA = QA - oA, oA = mA + oA - 1;
            else {
              if (mA >= QA)
                return Promise.resolve(e3("Range start is greater than the blob's size."));
              (oA === null || oA >= QA) && (oA = QA - 1);
            }
            const RA = _.slice(mA, oA, uA), bA = iA(RA);
            x.body = bA[0];
            const dA = v3(`${RA.size}`), GA = aA(mA, oA, QA);
            x.status = 206, x.statusText = "Partial Content", x.headersList.set("content-length", dA, true), x.headersList.set("content-type", uA, true), x.headersList.set("content-range", GA, true);
          } else {
            const cA = iA(_);
            x.statusText = "OK", x.body = cA[0], x.headersList.set("content-length", lA, true), x.headersList.set("content-type", uA, true);
          }
          return Promise.resolve(x);
        }
        case "data:": {
          const J = l3(O), _ = VA(J);
          if (_ === "failure")
            return Promise.resolve(e3("failed to fetch the data URL"));
          const x = OA(_.mimeType);
          return Promise.resolve(n3({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: x }]], body: rA(_.body)[0] }));
        }
        case "file:":
          return Promise.resolve(e3("not implemented... yet..."));
        case "http:":
        case "https:":
          return y3(R).catch((J) => e3(J));
        default:
          return Promise.resolve(e3("unknown scheme"));
      }
    }
    o4(ve, "schemeFetch");
    function Xe(R, O) {
      R.request.done = true, R.processResponseDone != null && queueMicrotask(() => R.processResponseDone(O));
    }
    o4(Xe, "finalizeResponse");
    function vA(R, O) {
      let H = R.timingInfo;
      const J = o4(() => {
        const x = Date.now();
        R.request.destination === "document" && (R.controller.fullTimingInfo = H), R.controller.reportTimingSteps = () => {
          if (R.request.url.protocol !== "https:")
            return;
          H.endTime = x;
          let lA = O.cacheState;
          const uA = O.bodyInfo;
          O.timingAllowPassed || (H = w(H), lA = "");
          let cA = 0;
          if (R.request.mode !== "navigator" || !O.hasCrossOriginRedirects) {
            cA = O.status;
            const fA = $(O.headersList);
            fA !== "failure" && (uA.contentType = IA(fA));
          }
          R.request.initiatorType != null && He(H, R.request.url.href, R.request.initiatorType, globalThis, lA, uA, cA);
        };
        const QA = o4(() => {
          R.request.done = true, R.processResponseEndOfBody != null && queueMicrotask(() => R.processResponseEndOfBody(O)), R.request.initiatorType != null && R.controller.reportTimingSteps();
        }, "processResponseEndOfBodyTask");
        queueMicrotask(() => QA());
      }, "processResponseEndOfBody");
      R.processResponse != null && queueMicrotask(() => R.processResponse(O));
      const _ = O.type === "error" ? O : O.internalResponse ?? O;
      if (_.body == null)
        J();
      else {
        const x = new TransformStream({ start() {
        }, transform(lA, uA) {
          uA.enqueue(lA);
        }, flush: J });
        _.body.stream.pipeThrough(x);
        const QA = new ReadableStream({ readableStream: x.readable, async start() {
          this._bodyReader = this.readableStream.getReader();
        }, async pull(lA) {
          for (;lA.desiredSize >= 0; ) {
            const { done: uA, value: cA } = await this._bodyReader.read();
            if (uA) {
              queueMicrotask(() => T(lA));
              break;
            }
            lA.enqueue(cA);
          }
        }, type: "bytes" });
        _.body.stream = QA;
      }
    }
    o4(vA, "fetchFinale");
    async function y3(R) {
      const O = R.request;
      let H = null, J = null;
      const _ = R.timingInfo;
      if (O.serviceWorkers, H === null) {
        if (O.redirect === "follow" && (O.serviceWorkers = "none"), J = H = await W(R), O.responseTainting === "cors" && M(O, H) === "failure")
          return e3("cors failure");
        h4(O, H) === "failure" && (O.timingAllowFailed = true);
      }
      return (O.responseTainting === "opaque" || H.type === "opaque") && B(O.origin, O.client, O.destination, J) === "blocked" ? e3("blocked") : (gA.has(J.status) && (O.redirect !== "manual" && R.controller.connection.destroy(undefined, false), O.redirect === "error" ? H = e3("unexpected redirect") : O.redirect === "manual" ? H = J : O.redirect === "follow" ? H = await Y(R, H) : z(false)), H.timingInfo = _, H);
    }
    o4(y3, "httpFetch");
    function Y(R, O) {
      const H = R.request, J = O.internalResponse ? O.internalResponse : O;
      let _;
      try {
        if (_ = c3(J, l3(H).hash), _ == null)
          return O;
      } catch (QA) {
        return Promise.resolve(e3(QA));
      }
      if (!P(_))
        return Promise.resolve(e3("URL scheme must be a HTTP(S) scheme"));
      if (H.redirectCount === 20)
        return Promise.resolve(e3("redirect count exceeded"));
      if (H.redirectCount += 1, H.mode === "cors" && (_.username || _.password) && !F(H, _))
        return Promise.resolve(e3('cross origin not allowed for request mode "cors"'));
      if (H.responseTainting === "cors" && (_.username || _.password))
        return Promise.resolve(e3('URL cannot contain credentials for request mode "cors"'));
      if (J.status !== 303 && H.body != null && H.body.source == null)
        return Promise.resolve(e3());
      if ([301, 302].includes(J.status) && H.method === "POST" || J.status === 303 && !Pe.includes(H.method)) {
        H.method = "GET", H.body = null;
        for (const QA of eA)
          H.headersList.delete(QA);
      }
      F(l3(H), _) || (H.headersList.delete("authorization", true), H.headersList.delete("proxy-authorization", true), H.headersList.delete("cookie", true), H.headersList.delete("host", true)), H.body != null && (z(H.body.source != null), H.body = rA(H.body.source)[0]);
      const x = R.timingInfo;
      return x.redirectEndTime = x.postRedirectStartTime = G(R.crossOriginIsolatedCapability), x.redirectStartTime === 0 && (x.redirectStartTime = x.startTime), H.urlList.push(_), S(H, J), re(R, true);
    }
    o4(Y, "httpRedirectFetch");
    async function W(R, O = false, H = false) {
      const J = R.request;
      let _ = null, x = null, QA = null;
      J.window === "no-window" && J.redirect === "error" ? (_ = R, x = J) : (x = E4(J), _ = { ...R }, _.request = x);
      const lA = J.credentials === "include" || J.credentials === "same-origin" && J.responseTainting === "basic", uA = x.body ? x.body.length : null;
      let cA = null;
      if (x.body == null && ["POST", "PUT"].includes(x.method) && (cA = "0"), uA != null && (cA = v3(`${uA}`)), cA != null && x.headersList.append("content-length", cA, true), uA != null && x.keepalive, x.referrer instanceof URL && x.headersList.append("referer", v3(x.referrer.href), true), L(x), U(x), x.headersList.contains("user-agent", true) || x.headersList.append("user-agent", ee), x.cache === "default" && (x.headersList.contains("if-modified-since", true) || x.headersList.contains("if-none-match", true) || x.headersList.contains("if-unmodified-since", true) || x.headersList.contains("if-match", true) || x.headersList.contains("if-range", true)) && (x.cache = "no-store"), x.cache === "no-cache" && !x.preventNoCacheCacheControlHeaderModification && !x.headersList.contains("cache-control", true) && x.headersList.append("cache-control", "max-age=0", true), (x.cache === "no-store" || x.cache === "reload") && (x.headersList.contains("pragma", true) || x.headersList.append("pragma", "no-cache", true), x.headersList.contains("cache-control", true) || x.headersList.append("cache-control", "no-cache", true)), x.headersList.contains("range", true) && x.headersList.append("accept-encoding", "identity", true), x.headersList.contains("accept-encoding", true) || (AA(l3(x)) ? x.headersList.append("accept-encoding", "br, gzip, deflate", true) : x.headersList.append("accept-encoding", "gzip, deflate", true)), x.headersList.delete("host", true), x.cache = "no-store", x.mode !== "no-store" && x.mode, QA == null) {
        if (x.mode === "only-if-cached")
          return e3("only if cached");
        const fA = await j(_, lA, H);
        !sA.has(x.method) && fA.status >= 200 && fA.status <= 399, QA == null && (QA = fA);
      }
      if (QA.urlList = [...x.urlList], x.headersList.contains("range", true) && (QA.rangeRequested = true), QA.requestIncludesCredentials = lA, QA.status === 407)
        return J.window === "no-window" ? e3() : N(R) ? A(R) : e3("proxy authentication required");
      if (QA.status === 421 && !H && (J.body == null || J.body.source != null)) {
        if (N(R))
          return A(R);
        R.controller.connection.destroy(), QA = await W(R, O, true);
      }
      return QA;
    }
    o4(W, "httpNetworkOrCacheFetch");
    async function j(R, O = false, H = false) {
      z(!R.controller.connection || R.controller.connection.destroyed), R.controller.connection = { abort: null, destroyed: false, destroy(oA, RA = true) {
        this.destroyed || (this.destroyed = true, RA && this.abort?.(oA ?? new DOMException("The operation was aborted.", "AbortError")));
      } };
      const J = R.request;
      let _ = null;
      const x = R.timingInfo;
      J.cache = "no-store", J.mode;
      let QA = null;
      if (J.body == null && R.processRequestEndOfBody)
        queueMicrotask(() => R.processRequestEndOfBody());
      else if (J.body != null) {
        const oA = o4(async function* (dA) {
          N(R) || (yield dA, R.processRequestBodyChunkLength?.(dA.byteLength));
        }, "processBodyChunk"), RA = o4(() => {
          N(R) || R.processRequestEndOfBody && R.processRequestEndOfBody();
        }, "processEndOfBody"), bA = o4((dA) => {
          N(R) || (dA.name === "AbortError" ? R.controller.abort() : R.controller.terminate(dA));
        }, "processBodyError");
        QA = async function* () {
          try {
            for await (const dA of J.body.stream)
              yield* oA(dA);
            RA();
          } catch (dA) {
            bA(dA);
          }
        }();
      }
      try {
        const { body: oA, status: RA, statusText: bA, headersList: dA, socket: GA } = await mA({ body: QA });
        if (GA)
          _ = n3({ status: RA, statusText: bA, headersList: dA, socket: GA });
        else {
          const DA = oA[Symbol.asyncIterator]();
          R.controller.next = () => DA.next(), _ = n3({ status: RA, statusText: bA, headersList: dA });
        }
      } catch (oA) {
        return oA.name === "AbortError" ? (R.controller.connection.destroy(), A(R, oA)) : e3(oA);
      }
      const lA = o4(async () => {
        await R.controller.resume();
      }, "pullAlgorithm"), uA = o4((oA) => {
        R.controller.abort(oA);
      }, "cancelAlgorithm"), cA = new ReadableStream({ async start(oA) {
        R.controller.controller = oA;
      }, async pull(oA) {
        await lA();
      }, async cancel(oA) {
        await uA(oA);
      }, type: "bytes" });
      _.body = { stream: cA, source: null, length: null }, R.controller.onAborted = fA, R.controller.on("terminated", fA), R.controller.resume = async () => {
        for (;; ) {
          let oA, RA;
          try {
            const { done: dA, value: GA } = await R.controller.next();
            if (u(R))
              break;
            oA = dA ? undefined : GA;
          } catch (dA) {
            R.controller.ended && !x.encodedBodySize ? oA = undefined : (oA = dA, RA = true);
          }
          if (oA === undefined) {
            T(R.controller.controller), Xe(R, _);
            return;
          }
          if (x.decodedBodySize += oA?.byteLength ?? 0, RA) {
            R.controller.terminate(oA);
            return;
          }
          const bA = new Uint8Array(oA);
          if (bA.byteLength && R.controller.controller.enqueue(bA), HA(cA)) {
            R.controller.terminate();
            return;
          }
          if (R.controller.controller.desiredSize <= 0)
            return;
        }
      };
      function fA(oA) {
        u(R) ? (_.aborted = true, pA(cA) && R.controller.controller.error(R.controller.serializedAbortReason)) : pA(cA) && R.controller.controller.error(new TypeError("terminated", { cause: b(oA) ? oA : undefined })), R.controller.connection.destroy();
      }
      return o4(fA, "onAborted"), _;
      function mA({ body: oA }) {
        const RA = l3(J), bA = R.controller.dispatcher;
        return new Promise((dA, GA) => bA.dispatch({ path: RA.pathname + RA.search, origin: RA.origin, method: J.method, body: bA.isMockActive ? J.body && (J.body.source || J.body.stream) : oA, headers: J.headersList.entries, maxRedirections: 0, upgrade: J.mode === "websocket" ? "websocket" : undefined }, { body: null, abort: null, onConnect(DA) {
          const { connection: FA } = R.controller;
          x.finalConnectionTimingInfo = K(undefined, x.postRedirectStartTime, R.crossOriginIsolatedCapability), FA.destroyed ? DA(new DOMException("The operation was aborted.", "AbortError")) : (R.controller.on("terminated", DA), this.abort = FA.abort = DA), x.finalNetworkRequestStartTime = G(R.crossOriginIsolatedCapability);
        }, onResponseStarted() {
          x.finalNetworkResponseStartTime = G(R.crossOriginIsolatedCapability);
        }, onHeaders(DA, FA, Ke, xe) {
          if (DA < 200)
            return;
          let TA = [], ft = "";
          const We = new s3;
          if (Array.isArray(FA)) {
            for (let LA = 0;LA < FA.length; LA += 2)
              We.append(JA(FA[LA]), FA[LA + 1].toString("latin1"), true);
            const jA = We.get("content-encoding", true);
            jA && (TA = jA.toLowerCase().split(",").map((LA) => LA.trim())), ft = We.get("location", true);
          }
          this.body = new wA({ read: Ke });
          const zA = [], Nt = ft && J.redirect === "follow" && gA.has(DA);
          if (J.method !== "HEAD" && J.method !== "CONNECT" && !BA.includes(DA) && !Nt)
            for (let jA = 0;jA < TA.length; ++jA) {
              const LA = TA[jA];
              if (LA === "x-gzip" || LA === "gzip")
                zA.push(Q.createGunzip({ flush: Q.constants.Z_SYNC_FLUSH, finishFlush: Q.constants.Z_SYNC_FLUSH }));
              else if (LA === "deflate")
                zA.push(X());
              else if (LA === "br")
                zA.push(Q.createBrotliDecompress());
              else {
                zA.length = 0;
                break;
              }
            }
          return dA({ status: DA, statusText: xe, headersList: We, body: zA.length ? qA(this.body, ...zA, () => {
          }) : this.body.on("error", () => {
          }) }), true;
        }, onData(DA) {
          if (R.controller.dump)
            return;
          const FA = DA;
          return x.encodedBodySize += FA.byteLength, this.body.push(FA);
        }, onComplete() {
          this.abort && R.controller.off("terminated", this.abort), R.controller.onAborted && R.controller.off("terminated", R.controller.onAborted), R.controller.ended = true, this.body.push(null);
        }, onError(DA) {
          this.abort && R.controller.off("terminated", this.abort), this.body?.destroy(DA), R.controller.terminate(DA), GA(DA);
        }, onUpgrade(DA, FA, Ke) {
          if (DA !== 101)
            return;
          const xe = new s3;
          for (let TA = 0;TA < FA.length; TA += 2)
            xe.append(JA(FA[TA]), FA[TA + 1].toString("latin1"), true);
          return dA({ status: DA, statusText: PA[DA], headersList: xe, socket: Ke }), true;
        } }));
      }
      o4(mA, "dispatch");
    }
    return o4(j, "httpNetworkFetch"), fetch_1 = { fetch: Ze, Fetch: XA, fetching: Ve, finalizeAndReportTiming: KA }, fetch_1;
  }
  function requireSymbols$2() {
    return hasRequiredSymbols$2 || (hasRequiredSymbols$2 = 1, symbols$2 = { kState: Symbol("FileReader state"), kResult: Symbol("FileReader result"), kError: Symbol("FileReader error"), kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"), kEvents: Symbol("FileReader events"), kAborted: Symbol("FileReader aborted") }), symbols$2;
  }
  function requireProgressevent() {
    if (hasRequiredProgressevent)
      return progressevent;
    hasRequiredProgressevent = 1;
    const { webidl: e3 } = requireWebidl(), A = Symbol("ProgressEvent state"), n3 = class n4 extends Event {
      constructor(s3, i4 = {}) {
        s3 = e3.converters.DOMString(s3), i4 = e3.converters.ProgressEventInit(i4 ?? {}), super(s3, i4), this[A] = { lengthComputable: i4.lengthComputable, loaded: i4.loaded, total: i4.total };
      }
      get lengthComputable() {
        return e3.brandCheck(this, n4), this[A].lengthComputable;
      }
      get loaded() {
        return e3.brandCheck(this, n4), this[A].loaded;
      }
      get total() {
        return e3.brandCheck(this, n4), this[A].total;
      }
    };
    o4(n3, "ProgressEvent");
    let t4 = n3;
    return e3.converters.ProgressEventInit = e3.dictionaryConverter([{ key: "lengthComputable", converter: e3.converters.boolean, defaultValue: false }, { key: "loaded", converter: e3.converters["unsigned long long"], defaultValue: 0 }, { key: "total", converter: e3.converters["unsigned long long"], defaultValue: 0 }, { key: "bubbles", converter: e3.converters.boolean, defaultValue: false }, { key: "cancelable", converter: e3.converters.boolean, defaultValue: false }, { key: "composed", converter: e3.converters.boolean, defaultValue: false }]), progressevent = { ProgressEvent: t4 }, progressevent;
  }
  function requireEncoding() {
    if (hasRequiredEncoding)
      return encoding;
    hasRequiredEncoding = 1;
    function e3(A) {
      if (!A)
        return "failure";
      switch (A.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    return o4(e3, "getEncoding"), encoding = { getEncoding: e3 }, encoding;
  }
  function requireUtil$4() {
    if (hasRequiredUtil$4)
      return util$5;
    hasRequiredUtil$4 = 1;
    const { kState: e3, kError: A, kResult: t4, kAborted: n3, kLastProgressEventFired: r } = requireSymbols$2(), { ProgressEvent: s3 } = requireProgressevent(), { getEncoding: i4 } = requireEncoding(), { serializeAMimeType: E4, parseMIMEType: Q } = requireDataUrl(), { types: C } = require$$0__default$1, { StringDecoder: I } = require$$5__default$2, { btoa: a3 } = require$$6__default, f3 = { enumerable: true, writable: false, configurable: false };
    function h4(w, U, M, B) {
      if (w[e3] === "loading")
        throw new DOMException("Invalid state", "InvalidStateError");
      w[e3] = "loading", w[t4] = null, w[A] = null;
      const G = U.stream().getReader(), g3 = [];
      let d3 = G.read(), F = true;
      (async () => {
        for (;!w[n3]; )
          try {
            const { done: N, value: u } = await d3;
            if (F && !w[n3] && queueMicrotask(() => {
              L("loadstart", w);
            }), F = false, !N && C.isUint8Array(u))
              g3.push(u), (w[r] === undefined || Date.now() - w[r] >= 50) && !w[n3] && (w[r] = Date.now(), queueMicrotask(() => {
                L("progress", w);
              })), d3 = G.read();
            else if (N) {
              queueMicrotask(() => {
                w[e3] = "done";
                try {
                  const b = c3(g3, M, U.type, B);
                  if (w[n3])
                    return;
                  w[t4] = b, L("load", w);
                } catch (b) {
                  w[A] = b, L("error", w);
                }
                w[e3] !== "loading" && L("loadend", w);
              });
              break;
            }
          } catch (N) {
            if (w[n3])
              return;
            queueMicrotask(() => {
              w[e3] = "done", w[A] = N, L("error", w), w[e3] !== "loading" && L("loadend", w);
            });
            break;
          }
      })();
    }
    o4(h4, "readOperation");
    function L(w, U) {
      const M = new s3(w, { bubbles: false, cancelable: false });
      U.dispatchEvent(M);
    }
    o4(L, "fireAProgressEvent");
    function c3(w, U, M, B) {
      switch (U) {
        case "DataURL": {
          let D = "data:";
          const G = Q(M || "application/octet-stream");
          G !== "failure" && (D += E4(G)), D += ";base64,";
          const g3 = new I("latin1");
          for (const d3 of w)
            D += a3(g3.write(d3));
          return D += a3(g3.end()), D;
        }
        case "Text": {
          let D = "failure";
          if (B && (D = i4(B)), D === "failure" && M) {
            const G = Q(M);
            G !== "failure" && (D = i4(G.parameters.get("charset")));
          }
          return D === "failure" && (D = "UTF-8"), l3(w, D);
        }
        case "ArrayBuffer":
          return k3(w).buffer;
        case "BinaryString": {
          let D = "";
          const G = new I("latin1");
          for (const g3 of w)
            D += G.write(g3);
          return D += G.end(), D;
        }
      }
    }
    o4(c3, "packageData");
    function l3(w, U) {
      const M = k3(w), B = S(M);
      let D = 0;
      B !== null && (U = B, D = B === "UTF-8" ? 3 : 2);
      const G = M.slice(D);
      return new TextDecoder(U).decode(G);
    }
    o4(l3, "decode");
    function S(w) {
      const [U, M, B] = w;
      return U === 239 && M === 187 && B === 191 ? "UTF-8" : U === 254 && M === 255 ? "UTF-16BE" : U === 255 && M === 254 ? "UTF-16LE" : null;
    }
    o4(S, "BOMSniffing");
    function k3(w) {
      const U = w.reduce((B, D) => B + D.byteLength, 0);
      let M = 0;
      return w.reduce((B, D) => (B.set(D, M), M += D.byteLength, B), new Uint8Array(U));
    }
    return o4(k3, "combineByteSequences"), util$5 = { staticPropertyDescriptors: f3, readOperation: h4, fireAProgressEvent: L }, util$5;
  }
  function requireFilereader() {
    if (hasRequiredFilereader)
      return filereader;
    hasRequiredFilereader = 1;
    const { staticPropertyDescriptors: e3, readOperation: A, fireAProgressEvent: t4 } = requireUtil$4(), { kState: n3, kError: r, kResult: s3, kEvents: i4, kAborted: E4 } = requireSymbols$2(), { webidl: Q } = requireWebidl(), { kEnumerableProperty: C } = util$m, a3 = class a4 extends EventTarget {
      constructor() {
        super(), this[n3] = "empty", this[s3] = null, this[r] = null, this[i4] = { loadend: null, error: null, abort: null, load: null, progress: null, loadstart: null };
      }
      readAsArrayBuffer(h4) {
        Q.brandCheck(this, a4), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), h4 = Q.converters.Blob(h4, { strict: false }), A(this, h4, "ArrayBuffer");
      }
      readAsBinaryString(h4) {
        Q.brandCheck(this, a4), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), h4 = Q.converters.Blob(h4, { strict: false }), A(this, h4, "BinaryString");
      }
      readAsText(h4, L = undefined) {
        Q.brandCheck(this, a4), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), h4 = Q.converters.Blob(h4, { strict: false }), L !== undefined && (L = Q.converters.DOMString(L)), A(this, h4, "Text", L);
      }
      readAsDataURL(h4) {
        Q.brandCheck(this, a4), Q.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), h4 = Q.converters.Blob(h4, { strict: false }), A(this, h4, "DataURL");
      }
      abort() {
        if (this[n3] === "empty" || this[n3] === "done") {
          this[s3] = null;
          return;
        }
        this[n3] === "loading" && (this[n3] = "done", this[s3] = null), this[E4] = true, t4("abort", this), this[n3] !== "loading" && t4("loadend", this);
      }
      get readyState() {
        switch (Q.brandCheck(this, a4), this[n3]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      get result() {
        return Q.brandCheck(this, a4), this[s3];
      }
      get error() {
        return Q.brandCheck(this, a4), this[r];
      }
      get onloadend() {
        return Q.brandCheck(this, a4), this[i4].loadend;
      }
      set onloadend(h4) {
        Q.brandCheck(this, a4), this[i4].loadend && this.removeEventListener("loadend", this[i4].loadend), typeof h4 == "function" ? (this[i4].loadend = h4, this.addEventListener("loadend", h4)) : this[i4].loadend = null;
      }
      get onerror() {
        return Q.brandCheck(this, a4), this[i4].error;
      }
      set onerror(h4) {
        Q.brandCheck(this, a4), this[i4].error && this.removeEventListener("error", this[i4].error), typeof h4 == "function" ? (this[i4].error = h4, this.addEventListener("error", h4)) : this[i4].error = null;
      }
      get onloadstart() {
        return Q.brandCheck(this, a4), this[i4].loadstart;
      }
      set onloadstart(h4) {
        Q.brandCheck(this, a4), this[i4].loadstart && this.removeEventListener("loadstart", this[i4].loadstart), typeof h4 == "function" ? (this[i4].loadstart = h4, this.addEventListener("loadstart", h4)) : this[i4].loadstart = null;
      }
      get onprogress() {
        return Q.brandCheck(this, a4), this[i4].progress;
      }
      set onprogress(h4) {
        Q.brandCheck(this, a4), this[i4].progress && this.removeEventListener("progress", this[i4].progress), typeof h4 == "function" ? (this[i4].progress = h4, this.addEventListener("progress", h4)) : this[i4].progress = null;
      }
      get onload() {
        return Q.brandCheck(this, a4), this[i4].load;
      }
      set onload(h4) {
        Q.brandCheck(this, a4), this[i4].load && this.removeEventListener("load", this[i4].load), typeof h4 == "function" ? (this[i4].load = h4, this.addEventListener("load", h4)) : this[i4].load = null;
      }
      get onabort() {
        return Q.brandCheck(this, a4), this[i4].abort;
      }
      set onabort(h4) {
        Q.brandCheck(this, a4), this[i4].abort && this.removeEventListener("abort", this[i4].abort), typeof h4 == "function" ? (this[i4].abort = h4, this.addEventListener("abort", h4)) : this[i4].abort = null;
      }
    };
    o4(a3, "FileReader");
    let I = a3;
    return I.EMPTY = I.prototype.EMPTY = 0, I.LOADING = I.prototype.LOADING = 1, I.DONE = I.prototype.DONE = 2, Object.defineProperties(I.prototype, { EMPTY: e3, LOADING: e3, DONE: e3, readAsArrayBuffer: C, readAsBinaryString: C, readAsText: C, readAsDataURL: C, abort: C, readyState: C, result: C, error: C, onloadstart: C, onprogress: C, onload: C, onabort: C, onerror: C, onloadend: C, [Symbol.toStringTag]: { value: "FileReader", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(I, { EMPTY: e3, LOADING: e3, DONE: e3 }), filereader = { FileReader: I }, filereader;
  }
  function requireSymbols$1() {
    return hasRequiredSymbols$1 || (hasRequiredSymbols$1 = 1, symbols$1 = { kConstruct: symbols$4.kConstruct }), symbols$1;
  }
  function requireUtil$3() {
    if (hasRequiredUtil$3)
      return util$4;
    hasRequiredUtil$3 = 1;
    const e3 = require$$0__default, { URLSerializer: A } = requireDataUrl(), { isValidHeaderName: t4 } = requireUtil$5();
    function n3(s3, i4, E4 = false) {
      const Q = A(s3, E4), C = A(i4, E4);
      return Q === C;
    }
    o4(n3, "urlEquals");
    function r(s3) {
      e3(s3 !== null);
      const i4 = [];
      for (let E4 of s3.split(","))
        E4 = E4.trim(), t4(E4) && i4.push(E4);
      return i4;
    }
    return o4(r, "getFieldValues"), util$4 = { urlEquals: n3, getFieldValues: r }, util$4;
  }
  function requireCache() {
    var w, U, qe, B, $A, G, wt, d3, je;
    if (hasRequiredCache)
      return cache;
    hasRequiredCache = 1;
    const { kConstruct: e3 } = requireSymbols$1(), { urlEquals: A, getFieldValues: t4 } = requireUtil$3(), { kEnumerableProperty: n3, isDisturbed: r } = util$m, { webidl: s3 } = requireWebidl(), { Response: i4, cloneResponse: E4, fromInnerResponse: Q } = requireResponse(), { Request: C, fromInnerRequest: I } = requireRequest(), { kState: a3 } = requireSymbols$3(), { fetching: f3 } = requireFetch(), { urlIsHttpHttpsScheme: h4, createDeferredPromise: L, readAllBytes: c3 } = requireUtil$5(), l3 = require$$0__default, N = class N4 {
      constructor() {
        CA(this, U);
        CA(this, B);
        CA(this, G);
        CA(this, d3);
        CA(this, w, undefined);
        arguments[0] !== e3 && s3.illegalConstructor(), EA(this, w, arguments[1]);
      }
      async match(b, m3 = {}) {
        s3.brandCheck(this, N4), s3.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), b = s3.converters.RequestInfo(b), m3 = s3.converters.CacheQueryOptions(m3);
        const T = kA(this, d3, je).call(this, b, m3, 1);
        if (T.length !== 0)
          return T[0];
      }
      async matchAll(b = undefined, m3 = {}) {
        return s3.brandCheck(this, N4), b !== undefined && (b = s3.converters.RequestInfo(b)), m3 = s3.converters.CacheQueryOptions(m3), kA(this, d3, je).call(this, b, m3);
      }
      async add(b) {
        s3.brandCheck(this, N4), s3.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), b = s3.converters.RequestInfo(b);
        const m3 = [b];
        return await this.addAll(m3);
      }
      async addAll(b) {
        s3.brandCheck(this, N4), s3.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        const m3 = [], T = [];
        for (let X of b) {
          if (X === undefined)
            throw s3.errors.conversionFailed({ prefix: "Cache.addAll", argument: "Argument 1", types: ["undefined is not allowed"] });
          if (X = s3.converters.RequestInfo(X), typeof X == "string")
            continue;
          const $ = X[a3];
          if (!h4($.url) || $.method !== "GET")
            throw s3.errors.exception({ header: "Cache.addAll", message: "Expected http/s scheme when method is not GET." });
        }
        const v3 = [];
        for (const X of b) {
          const $ = new C(X)[a3];
          if (!h4($.url))
            throw s3.errors.exception({ header: "Cache.addAll", message: "Expected http/s scheme." });
          $.initiator = "fetch", $.destination = "subresource", T.push($);
          const V2 = L();
          v3.push(f3({ request: $, processResponse(q) {
            if (q.type === "error" || q.status === 206 || q.status < 200 || q.status > 299)
              V2.reject(s3.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
            else if (q.headersList.contains("vary")) {
              const z = t4(q.headersList.get("vary"));
              for (const rA of z)
                if (rA === "*") {
                  V2.reject(s3.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                  for (const iA of v3)
                    iA.abort();
                  return;
                }
            }
          }, processResponseEndOfBody(q) {
            if (q.aborted) {
              V2.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            V2.resolve(q);
          } })), m3.push(V2.promise);
        }
        const P = await Promise.all(m3), AA = [];
        let K = 0;
        for (const X of P) {
          const $ = { type: "put", request: T[K], response: X };
          AA.push($), K++;
        }
        const tA = L();
        let aA = null;
        try {
          kA(this, U, qe).call(this, AA);
        } catch (X) {
          aA = X;
        }
        return queueMicrotask(() => {
          aA === null ? tA.resolve(undefined) : tA.reject(aA);
        }), tA.promise;
      }
      async put(b, m3) {
        s3.brandCheck(this, N4), s3.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), b = s3.converters.RequestInfo(b), m3 = s3.converters.Response(m3);
        let T = null;
        if (b instanceof C ? T = b[a3] : T = new C(b)[a3], !h4(T.url) || T.method !== "GET")
          throw s3.errors.exception({ header: "Cache.put", message: "Expected an http/s scheme when method is not GET" });
        const v3 = m3[a3];
        if (v3.status === 206)
          throw s3.errors.exception({ header: "Cache.put", message: "Got 206 status" });
        if (v3.headersList.contains("vary")) {
          const $ = t4(v3.headersList.get("vary"));
          for (const V2 of $)
            if (V2 === "*")
              throw s3.errors.exception({ header: "Cache.put", message: "Got * vary field value" });
        }
        if (v3.body && (r(v3.body.stream) || v3.body.stream.locked))
          throw s3.errors.exception({ header: "Cache.put", message: "Response body is locked or disturbed" });
        const Z = E4(v3), P = L();
        if (v3.body != null) {
          const V2 = v3.body.stream.getReader();
          c3(V2).then(P.resolve, P.reject);
        } else
          P.resolve(undefined);
        const AA = [], K = { type: "put", request: T, response: Z };
        AA.push(K);
        const tA = await P.promise;
        Z.body != null && (Z.body.source = tA);
        const aA = L();
        let X = null;
        try {
          kA(this, U, qe).call(this, AA);
        } catch ($) {
          X = $;
        }
        return queueMicrotask(() => {
          X === null ? aA.resolve() : aA.reject(X);
        }), aA.promise;
      }
      async delete(b, m3 = {}) {
        s3.brandCheck(this, N4), s3.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), b = s3.converters.RequestInfo(b), m3 = s3.converters.CacheQueryOptions(m3);
        let T = null;
        if (b instanceof C) {
          if (T = b[a3], T.method !== "GET" && !m3.ignoreMethod)
            return false;
        } else
          l3(typeof b == "string"), T = new C(b)[a3];
        const v3 = [], Z = { type: "delete", request: T, options: m3 };
        v3.push(Z);
        const P = L();
        let AA = null, K;
        try {
          K = kA(this, U, qe).call(this, v3);
        } catch (tA) {
          AA = tA;
        }
        return queueMicrotask(() => {
          AA === null ? P.resolve(!!K?.length) : P.reject(AA);
        }), P.promise;
      }
      async keys(b = undefined, m3 = {}) {
        s3.brandCheck(this, N4), b !== undefined && (b = s3.converters.RequestInfo(b)), m3 = s3.converters.CacheQueryOptions(m3);
        let T = null;
        if (b !== undefined)
          if (b instanceof C) {
            if (T = b[a3], T.method !== "GET" && !m3.ignoreMethod)
              return [];
          } else
            typeof b == "string" && (T = new C(b)[a3]);
        const v3 = L(), Z = [];
        if (b === undefined)
          for (const P of p3(this, w))
            Z.push(P[0]);
        else {
          const P = kA(this, B, $A).call(this, T, m3);
          for (const AA of P)
            Z.push(AA[0]);
        }
        return queueMicrotask(() => {
          const P = [];
          for (const AA of Z) {
            const K = I(AA, new AbortController().signal, "immutable", { settingsObject: AA.client });
            P.push(K);
          }
          v3.resolve(Object.freeze(P));
        }), v3.promise;
      }
    };
    w = new WeakMap, U = new WeakSet, qe = o4(function(b) {
      const m3 = p3(this, w), T = [...m3], v3 = [], Z = [];
      try {
        for (const P of b) {
          if (P.type !== "delete" && P.type !== "put")
            throw s3.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
          if (P.type === "delete" && P.response != null)
            throw s3.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
          if (kA(this, B, $A).call(this, P.request, P.options, v3).length)
            throw new DOMException("???", "InvalidStateError");
          let AA;
          if (P.type === "delete") {
            if (AA = kA(this, B, $A).call(this, P.request, P.options), AA.length === 0)
              return [];
            for (const K of AA) {
              const tA = m3.indexOf(K);
              l3(tA !== -1), m3.splice(tA, 1);
            }
          } else if (P.type === "put") {
            if (P.response == null)
              throw s3.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
            const K = P.request;
            if (!h4(K.url))
              throw s3.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
            if (K.method !== "GET")
              throw s3.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
            if (P.options != null)
              throw s3.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
            AA = kA(this, B, $A).call(this, P.request);
            for (const tA of AA) {
              const aA = m3.indexOf(tA);
              l3(aA !== -1), m3.splice(aA, 1);
            }
            m3.push([P.request, P.response]), v3.push([P.request, P.response]);
          }
          Z.push([P.request, P.response]);
        }
        return Z;
      } catch (P) {
        throw p3(this, w).length = 0, EA(this, w, T), P;
      }
    }, "#batchCacheOperations"), B = new WeakSet, $A = o4(function(b, m3, T) {
      const v3 = [], Z = T ?? p3(this, w);
      for (const P of Z) {
        const [AA, K] = P;
        kA(this, G, wt).call(this, b, AA, K, m3) && v3.push(P);
      }
      return v3;
    }, "#queryCache"), G = new WeakSet, wt = o4(function(b, m3, T = null, v3) {
      const Z = new URL(b.url), P = new URL(m3.url);
      if (v3?.ignoreSearch && (P.search = "", Z.search = ""), !A(Z, P, true))
        return false;
      if (T == null || v3?.ignoreVary || !T.headersList.contains("vary"))
        return true;
      const AA = t4(T.headersList.get("vary"));
      for (const K of AA) {
        if (K === "*")
          return false;
        const tA = m3.headersList.get(K), aA = b.headersList.get(K);
        if (tA !== aA)
          return false;
      }
      return true;
    }, "#requestMatchesCachedItem"), d3 = new WeakSet, je = o4(function(b, m3, T = 1 / 0) {
      let v3 = null;
      if (b !== undefined)
        if (b instanceof C) {
          if (v3 = b[a3], v3.method !== "GET" && !m3.ignoreMethod)
            return [];
        } else
          typeof b == "string" && (v3 = new C(b)[a3]);
      const Z = [];
      if (b === undefined)
        for (const AA of p3(this, w))
          Z.push(AA[1]);
      else {
        const AA = kA(this, B, $A).call(this, v3, m3);
        for (const K of AA)
          Z.push(K[1]);
      }
      const P = [];
      for (const AA of Z) {
        const K = Q(AA, "immutable", { settingsObject: {} });
        if (P.push(K.clone()), P.length >= T)
          break;
      }
      return Object.freeze(P);
    }, "#internalMatchAll"), o4(N, "Cache");
    let S = N;
    Object.defineProperties(S.prototype, { [Symbol.toStringTag]: { value: "Cache", configurable: true }, match: n3, matchAll: n3, add: n3, addAll: n3, put: n3, delete: n3, keys: n3 });
    const k3 = [{ key: "ignoreSearch", converter: s3.converters.boolean, defaultValue: false }, { key: "ignoreMethod", converter: s3.converters.boolean, defaultValue: false }, { key: "ignoreVary", converter: s3.converters.boolean, defaultValue: false }];
    return s3.converters.CacheQueryOptions = s3.dictionaryConverter(k3), s3.converters.MultiCacheQueryOptions = s3.dictionaryConverter([...k3, { key: "cacheName", converter: s3.converters.DOMString }]), s3.converters.Response = s3.interfaceConverter(i4), s3.converters["sequence<RequestInfo>"] = s3.sequenceConverter(s3.converters.RequestInfo), cache = { Cache: S }, cache;
  }
  function requireCachestorage() {
    var s3;
    if (hasRequiredCachestorage)
      return cachestorage;
    hasRequiredCachestorage = 1;
    const { kConstruct: e3 } = requireSymbols$1(), { Cache: A } = requireCache(), { webidl: t4 } = requireWebidl(), { kEnumerableProperty: n3 } = util$m, i4 = class i5 {
      constructor() {
        CA(this, s3, new Map);
        arguments[0] !== e3 && t4.illegalConstructor();
      }
      async match(Q, C = {}) {
        if (t4.brandCheck(this, i5), t4.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), Q = t4.converters.RequestInfo(Q), C = t4.converters.MultiCacheQueryOptions(C), C.cacheName != null) {
          if (p3(this, s3).has(C.cacheName)) {
            const I = p3(this, s3).get(C.cacheName);
            return await new A(e3, I).match(Q, C);
          }
        } else
          for (const I of p3(this, s3).values()) {
            const f3 = await new A(e3, I).match(Q, C);
            if (f3 !== undefined)
              return f3;
          }
      }
      async has(Q) {
        return t4.brandCheck(this, i5), t4.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), Q = t4.converters.DOMString(Q), p3(this, s3).has(Q);
      }
      async open(Q) {
        if (t4.brandCheck(this, i5), t4.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), Q = t4.converters.DOMString(Q), p3(this, s3).has(Q)) {
          const I = p3(this, s3).get(Q);
          return new A(e3, I);
        }
        const C = [];
        return p3(this, s3).set(Q, C), new A(e3, C);
      }
      async delete(Q) {
        return t4.brandCheck(this, i5), t4.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), Q = t4.converters.DOMString(Q), p3(this, s3).delete(Q);
      }
      async keys() {
        return t4.brandCheck(this, i5), [...p3(this, s3).keys()];
      }
    };
    s3 = new WeakMap, o4(i4, "CacheStorage");
    let r = i4;
    return Object.defineProperties(r.prototype, { [Symbol.toStringTag]: { value: "CacheStorage", configurable: true }, match: n3, has: n3, open: n3, delete: n3, keys: n3 }), cachestorage = { CacheStorage: r }, cachestorage;
  }
  function requireConstants$1() {
    return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 }), constants$1;
  }
  function requireUtil$2() {
    if (hasRequiredUtil$2)
      return util$3;
    hasRequiredUtil$2 = 1;
    const e3 = require$$0__default, { kHeadersList: A } = symbols$4;
    function t4(c3) {
      for (let l3 = 0;l3 < c3.length; ++l3) {
        const S = c3.charCodeAt(l3);
        if (S >= 0 && S <= 8 || S >= 10 && S <= 31 || S === 127)
          return true;
      }
      return false;
    }
    o4(t4, "isCTLExcludingHtab");
    function n3(c3) {
      for (let l3 = 0;l3 < c3.length; ++l3) {
        const S = c3.charCodeAt(l3);
        if (S < 33 || S > 126 || S === 34 || S === 40 || S === 41 || S === 60 || S === 62 || S === 64 || S === 44 || S === 59 || S === 58 || S === 92 || S === 47 || S === 91 || S === 93 || S === 63 || S === 61 || S === 123 || S === 125)
          throw new Error("Invalid cookie name");
      }
    }
    o4(n3, "validateCookieName");
    function r(c3) {
      let l3 = c3.length, S = 0;
      if (c3[0] === '"') {
        if (l3 === 1 || c3[l3 - 1] !== '"')
          throw new Error("Invalid cookie value");
        --l3, ++S;
      }
      for (;S < l3; ) {
        const k3 = c3.charCodeAt(S++);
        if (k3 < 33 || k3 > 126 || k3 === 34 || k3 === 44 || k3 === 59 || k3 === 92)
          throw new Error("Invalid cookie value");
      }
    }
    o4(r, "validateCookieValue");
    function s3(c3) {
      for (let l3 = 0;l3 < c3.length; ++l3) {
        const S = c3.charCodeAt(l3);
        if (S < 32 || S === 127 || S === 59)
          throw new Error("Invalid cookie path");
      }
    }
    o4(s3, "validateCookiePath");
    function i4(c3) {
      if (c3.startsWith("-") || c3.endsWith(".") || c3.endsWith("-"))
        throw new Error("Invalid cookie domain");
    }
    o4(i4, "validateCookieDomain");
    const E4 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], Q = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], C = Array(61).fill(0).map((c3, l3) => l3.toString().padStart(2, "0"));
    function I(c3) {
      return typeof c3 == "number" && (c3 = new Date(c3)), `${E4[c3.getUTCDay()]}, ${C[c3.getUTCDate()]} ${Q[c3.getUTCMonth()]} ${c3.getUTCFullYear()} ${C[c3.getUTCHours()]}:${C[c3.getUTCMinutes()]}:${C[c3.getUTCSeconds()]} GMT`;
    }
    o4(I, "toIMFDate");
    function a3(c3) {
      if (c3 < 0)
        throw new Error("Invalid cookie max-age");
    }
    o4(a3, "validateCookieMaxAge");
    function f3(c3) {
      if (c3.name.length === 0)
        return null;
      n3(c3.name), r(c3.value);
      const l3 = [`${c3.name}=${c3.value}`];
      c3.name.startsWith("__Secure-") && (c3.secure = true), c3.name.startsWith("__Host-") && (c3.secure = true, c3.domain = null, c3.path = "/"), c3.secure && l3.push("Secure"), c3.httpOnly && l3.push("HttpOnly"), typeof c3.maxAge == "number" && (a3(c3.maxAge), l3.push(`Max-Age=${c3.maxAge}`)), c3.domain && (i4(c3.domain), l3.push(`Domain=${c3.domain}`)), c3.path && (s3(c3.path), l3.push(`Path=${c3.path}`)), c3.expires && c3.expires.toString() !== "Invalid Date" && l3.push(`Expires=${I(c3.expires)}`), c3.sameSite && l3.push(`SameSite=${c3.sameSite}`);
      for (const S of c3.unparsed) {
        if (!S.includes("="))
          throw new Error("Invalid unparsed");
        const [k3, ...w] = S.split("=");
        l3.push(`${k3.trim()}=${w.join("=")}`);
      }
      return l3.join("; ");
    }
    o4(f3, "stringify");
    let h4;
    function L(c3) {
      if (c3[A])
        return c3[A];
      h4 || (h4 = Object.getOwnPropertySymbols(c3).find((S) => S.description === "headers list"), e3(h4, "Headers cannot be parsed"));
      const l3 = c3[h4];
      return e3(l3), l3;
    }
    return o4(L, "getHeadersList"), util$3 = { isCTLExcludingHtab: t4, validateCookieName: n3, validateCookiePath: s3, validateCookieValue: r, toIMFDate: I, stringify: f3, getHeadersList: L }, util$3;
  }
  function requireParse() {
    if (hasRequiredParse)
      return parse2;
    hasRequiredParse = 1;
    const { maxNameValuePairSize: e3, maxAttributeValueSize: A } = requireConstants$1(), { isCTLExcludingHtab: t4 } = requireUtil$2(), { collectASequenceOfCodePointsFast: n3 } = requireDataUrl(), r = require$$0__default;
    function s3(E4) {
      if (t4(E4))
        return null;
      let Q = "", C = "", I = "", a3 = "";
      if (E4.includes(";")) {
        const f3 = { position: 0 };
        Q = n3(";", E4, f3), C = E4.slice(f3.position);
      } else
        Q = E4;
      if (!Q.includes("="))
        a3 = Q;
      else {
        const f3 = { position: 0 };
        I = n3("=", Q, f3), a3 = Q.slice(f3.position + 1);
      }
      return I = I.trim(), a3 = a3.trim(), I.length + a3.length > e3 ? null : { name: I, value: a3, ...i4(C) };
    }
    o4(s3, "parseSetCookie");
    function i4(E4, Q = {}) {
      if (E4.length === 0)
        return Q;
      r(E4[0] === ";"), E4 = E4.slice(1);
      let C = "";
      E4.includes(";") ? (C = n3(";", E4, { position: 0 }), E4 = E4.slice(C.length)) : (C = E4, E4 = "");
      let I = "", a3 = "";
      if (C.includes("=")) {
        const h4 = { position: 0 };
        I = n3("=", C, h4), a3 = C.slice(h4.position + 1);
      } else
        I = C;
      if (I = I.trim(), a3 = a3.trim(), a3.length > A)
        return i4(E4, Q);
      const f3 = I.toLowerCase();
      if (f3 === "expires") {
        const h4 = new Date(a3);
        Q.expires = h4;
      } else if (f3 === "max-age") {
        const h4 = a3.charCodeAt(0);
        if ((h4 < 48 || h4 > 57) && a3[0] !== "-" || !/^\d+$/.test(a3))
          return i4(E4, Q);
        const L = Number(a3);
        Q.maxAge = L;
      } else if (f3 === "domain") {
        let h4 = a3;
        h4[0] === "." && (h4 = h4.slice(1)), h4 = h4.toLowerCase(), Q.domain = h4;
      } else if (f3 === "path") {
        let h4 = "";
        a3.length === 0 || a3[0] !== "/" ? h4 = "/" : h4 = a3, Q.path = h4;
      } else if (f3 === "secure")
        Q.secure = true;
      else if (f3 === "httponly")
        Q.httpOnly = true;
      else if (f3 === "samesite") {
        let h4 = "Default";
        const L = a3.toLowerCase();
        L.includes("none") && (h4 = "None"), L.includes("strict") && (h4 = "Strict"), L.includes("lax") && (h4 = "Lax"), Q.sameSite = h4;
      } else
        Q.unparsed ?? (Q.unparsed = []), Q.unparsed.push(`${I}=${a3}`);
      return i4(E4, Q);
    }
    return o4(i4, "parseUnparsedAttributes"), parse2 = { parseSetCookie: s3, parseUnparsedAttributes: i4 }, parse2;
  }
  function requireCookies() {
    if (hasRequiredCookies)
      return cookies;
    hasRequiredCookies = 1;
    const { parseSetCookie: e3 } = requireParse(), { stringify: A, getHeadersList: t4 } = requireUtil$2(), { webidl: n3 } = requireWebidl(), { Headers: r } = requireHeaders();
    function s3(C) {
      n3.argumentLengthCheck(arguments, 1, { header: "getCookies" }), n3.brandCheck(C, r, { strict: false });
      const I = C.get("cookie"), a3 = {};
      if (!I)
        return a3;
      for (const f3 of I.split(";")) {
        const [h4, ...L] = f3.split("=");
        a3[h4.trim()] = L.join("=");
      }
      return a3;
    }
    o4(s3, "getCookies");
    function i4(C, I, a3) {
      n3.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), n3.brandCheck(C, r, { strict: false }), I = n3.converters.DOMString(I), a3 = n3.converters.DeleteCookieAttributes(a3), Q(C, { name: I, value: "", expires: new Date(0), ...a3 });
    }
    o4(i4, "deleteCookie");
    function E4(C) {
      n3.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), n3.brandCheck(C, r, { strict: false });
      const I = t4(C).cookies;
      return I ? I.map((a3) => e3(Array.isArray(a3) ? a3[1] : a3)) : [];
    }
    o4(E4, "getSetCookies");
    function Q(C, I) {
      n3.argumentLengthCheck(arguments, 2, { header: "setCookie" }), n3.brandCheck(C, r, { strict: false }), I = n3.converters.Cookie(I);
      const a3 = A(I);
      a3 && C.append("Set-Cookie", a3);
    }
    return o4(Q, "setCookie"), n3.converters.DeleteCookieAttributes = n3.dictionaryConverter([{ converter: n3.nullableConverter(n3.converters.DOMString), key: "path", defaultValue: null }, { converter: n3.nullableConverter(n3.converters.DOMString), key: "domain", defaultValue: null }]), n3.converters.Cookie = n3.dictionaryConverter([{ converter: n3.converters.DOMString, key: "name" }, { converter: n3.converters.DOMString, key: "value" }, { converter: n3.nullableConverter((C) => typeof C == "number" ? n3.converters["unsigned long long"](C) : new Date(C)), key: "expires", defaultValue: null }, { converter: n3.nullableConverter(n3.converters["long long"]), key: "maxAge", defaultValue: null }, { converter: n3.nullableConverter(n3.converters.DOMString), key: "domain", defaultValue: null }, { converter: n3.nullableConverter(n3.converters.DOMString), key: "path", defaultValue: null }, { converter: n3.nullableConverter(n3.converters.boolean), key: "secure", defaultValue: null }, { converter: n3.nullableConverter(n3.converters.boolean), key: "httpOnly", defaultValue: null }, { converter: n3.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] }, { converter: n3.sequenceConverter(n3.converters.DOMString), key: "unparsed", defaultValue: [] }]), cookies = { getCookies: s3, deleteCookie: i4, getSetCookies: E4, setCookie: Q }, cookies;
  }
  function requireEvents() {
    var E4, C, a3;
    if (hasRequiredEvents)
      return events;
    hasRequiredEvents = 1;
    const { webidl: e3 } = requireWebidl(), { kEnumerableProperty: A } = util$m, { MessagePort: t4 } = require$$2__default, Q = class Q4 extends Event {
      constructor(c3, l3 = {}) {
        e3.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), c3 = e3.converters.DOMString(c3), l3 = e3.converters.MessageEventInit(l3);
        super(c3, l3);
        CA(this, E4, undefined);
        EA(this, E4, l3);
      }
      get data() {
        return e3.brandCheck(this, Q4), p3(this, E4).data;
      }
      get origin() {
        return e3.brandCheck(this, Q4), p3(this, E4).origin;
      }
      get lastEventId() {
        return e3.brandCheck(this, Q4), p3(this, E4).lastEventId;
      }
      get source() {
        return e3.brandCheck(this, Q4), p3(this, E4).source;
      }
      get ports() {
        return e3.brandCheck(this, Q4), Object.isFrozen(p3(this, E4).ports) || Object.freeze(p3(this, E4).ports), p3(this, E4).ports;
      }
      initMessageEvent(c3, l3 = false, S = false, k3 = null, w = "", U = "", M = null, B = []) {
        return e3.brandCheck(this, Q4), e3.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new Q4(c3, { bubbles: l3, cancelable: S, data: k3, origin: w, lastEventId: U, source: M, ports: B });
      }
    };
    E4 = new WeakMap, o4(Q, "MessageEvent");
    let n3 = Q;
    const I = class I4 extends Event {
      constructor(c3, l3 = {}) {
        e3.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), c3 = e3.converters.DOMString(c3), l3 = e3.converters.CloseEventInit(l3);
        super(c3, l3);
        CA(this, C, undefined);
        EA(this, C, l3);
      }
      get wasClean() {
        return e3.brandCheck(this, I4), p3(this, C).wasClean;
      }
      get code() {
        return e3.brandCheck(this, I4), p3(this, C).code;
      }
      get reason() {
        return e3.brandCheck(this, I4), p3(this, C).reason;
      }
    };
    C = new WeakMap, o4(I, "CloseEvent");
    let r = I;
    const f3 = class f4 extends Event {
      constructor(c3, l3) {
        e3.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(c3, l3);
        CA(this, a3, undefined);
        c3 = e3.converters.DOMString(c3), l3 = e3.converters.ErrorEventInit(l3 ?? {}), EA(this, a3, l3);
      }
      get message() {
        return e3.brandCheck(this, f4), p3(this, a3).message;
      }
      get filename() {
        return e3.brandCheck(this, f4), p3(this, a3).filename;
      }
      get lineno() {
        return e3.brandCheck(this, f4), p3(this, a3).lineno;
      }
      get colno() {
        return e3.brandCheck(this, f4), p3(this, a3).colno;
      }
      get error() {
        return e3.brandCheck(this, f4), p3(this, a3).error;
      }
    };
    a3 = new WeakMap, o4(f3, "ErrorEvent");
    let s3 = f3;
    Object.defineProperties(n3.prototype, { [Symbol.toStringTag]: { value: "MessageEvent", configurable: true }, data: A, origin: A, lastEventId: A, source: A, ports: A, initMessageEvent: A }), Object.defineProperties(r.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: A, code: A, wasClean: A }), Object.defineProperties(s3.prototype, { [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true }, message: A, filename: A, lineno: A, colno: A, error: A }), e3.converters.MessagePort = e3.interfaceConverter(t4), e3.converters["sequence<MessagePort>"] = e3.sequenceConverter(e3.converters.MessagePort);
    const i4 = [{ key: "bubbles", converter: e3.converters.boolean, defaultValue: false }, { key: "cancelable", converter: e3.converters.boolean, defaultValue: false }, { key: "composed", converter: e3.converters.boolean, defaultValue: false }];
    return e3.converters.MessageEventInit = e3.dictionaryConverter([...i4, { key: "data", converter: e3.converters.any, defaultValue: null }, { key: "origin", converter: e3.converters.USVString, defaultValue: "" }, { key: "lastEventId", converter: e3.converters.DOMString, defaultValue: "" }, { key: "source", converter: e3.nullableConverter(e3.converters.MessagePort), defaultValue: null }, { key: "ports", converter: e3.converters["sequence<MessagePort>"], get defaultValue() {
      return [];
    } }]), e3.converters.CloseEventInit = e3.dictionaryConverter([...i4, { key: "wasClean", converter: e3.converters.boolean, defaultValue: false }, { key: "code", converter: e3.converters["unsigned short"], defaultValue: 0 }, { key: "reason", converter: e3.converters.USVString, defaultValue: "" }]), e3.converters.ErrorEventInit = e3.dictionaryConverter([...i4, { key: "message", converter: e3.converters.DOMString, defaultValue: "" }, { key: "filename", converter: e3.converters.USVString, defaultValue: "" }, { key: "lineno", converter: e3.converters["unsigned long"], defaultValue: 0 }, { key: "colno", converter: e3.converters["unsigned long"], defaultValue: 0 }, { key: "error", converter: e3.converters.any }]), events = { MessageEvent: n3, CloseEvent: r, ErrorEvent: s3 }, events;
  }
  function requireConstants() {
    if (hasRequiredConstants)
      return constants;
    hasRequiredConstants = 1;
    const e3 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", A = { enumerable: true, writable: false, configurable: false }, t4 = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 }, n3 = { NOT_SENT: 0, PROCESSING: 1, SENT: 2 }, r = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 }, s3 = 2 ** 16 - 1, i4 = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 }, E4 = Buffer.allocUnsafe(0);
    return constants = { uid: e3, sentCloseFrameState: n3, staticPropertyDescriptors: A, states: t4, opcodes: r, maxUnsigned16Bit: s3, parserStates: i4, emptyBuffer: E4 }, constants;
  }
  function requireSymbols() {
    return hasRequiredSymbols || (hasRequiredSymbols = 1, symbols3 = { kWebSocketURL: Symbol("url"), kReadyState: Symbol("ready state"), kController: Symbol("controller"), kResponse: Symbol("response"), kBinaryType: Symbol("binary type"), kSentClose: Symbol("sent close"), kReceivedClose: Symbol("received close"), kByteParser: Symbol("byte parser") }), symbols3;
  }
  function requireUtil$1() {
    if (hasRequiredUtil$1)
      return util$2;
    hasRequiredUtil$1 = 1;
    const { kReadyState: e3, kController: A, kResponse: t4, kBinaryType: n3, kWebSocketURL: r } = requireSymbols(), { states: s3, opcodes: i4 } = requireConstants(), { MessageEvent: E4, ErrorEvent: Q } = requireEvents(), { isUtf8: C } = require$$6__default;
    function I(B) {
      return B[e3] === s3.CONNECTING;
    }
    o4(I, "isConnecting");
    function a3(B) {
      return B[e3] === s3.OPEN;
    }
    o4(a3, "isEstablished");
    function f3(B) {
      return B[e3] === s3.CLOSING;
    }
    o4(f3, "isClosing");
    function h4(B) {
      return B[e3] === s3.CLOSED;
    }
    o4(h4, "isClosed");
    function L(B, D, G = Event, g3 = {}) {
      const d3 = new G(B, g3);
      D.dispatchEvent(d3);
    }
    o4(L, "fireEvent");
    function c3(B, D, G) {
      if (B[e3] !== s3.OPEN)
        return;
      let g3;
      if (D === i4.TEXT)
        try {
          g3 = M(G);
        } catch {
          k3(B, "Received invalid UTF-8 in text frame.");
          return;
        }
      else
        D === i4.BINARY && (B[n3] === "blob" ? g3 = new Blob([G]) : g3 = new Uint8Array(G).buffer);
      L("message", B, E4, { origin: B[r].origin, data: g3 });
    }
    o4(c3, "websocketMessageReceived");
    function l3(B) {
      if (B.length === 0)
        return false;
      for (let D = 0;D < B.length; ++D) {
        const G = B.charCodeAt(D);
        if (G < 33 || G > 126 || G === 34 || G === 40 || G === 41 || G === 44 || G === 47 || G === 58 || G === 59 || G === 60 || G === 61 || G === 62 || G === 63 || G === 64 || G === 91 || G === 92 || G === 93 || G === 123 || G === 125)
          return false;
      }
      return true;
    }
    o4(l3, "isValidSubprotocol");
    function S(B) {
      return B >= 1000 && B < 1015 ? B !== 1004 && B !== 1005 && B !== 1006 : B >= 3000 && B <= 4999;
    }
    o4(S, "isValidStatusCode");
    function k3(B, D) {
      const { [A]: G, [t4]: g3 } = B;
      G.abort(), g3?.socket && !g3.socket.destroyed && g3.socket.destroy(), D && L("error", B, Q, { error: new Error(D) });
    }
    o4(k3, "failWebsocketConnection");
    const w = typeof process.versions.icu == "string", U = w ? new TextDecoder("utf-8", { fatal: true }) : undefined;
    function M(B) {
      if (w)
        return U.decode(B);
      if (!C?.(B))
        throw C || process.emitWarning("ICU is not supported and no fallback exists. Please upgrade to at least Node v18.14.0.", { code: "UNDICI-WS-NO-ICU" }), new TypeError("Invalid utf-8 received.");
      return B.toString("utf-8");
    }
    return o4(M, "utf8Decode"), util$2 = { isConnecting: I, isEstablished: a3, isClosing: f3, isClosed: h4, fireEvent: L, isValidSubprotocol: l3, isValidStatusCode: S, failWebsocketConnection: k3, websocketMessageReceived: c3, utf8Decode: M }, util$2;
  }
  function requireConnection() {
    if (hasRequiredConnection)
      return connection;
    hasRequiredConnection = 1;
    const { uid: e3, states: A, sentCloseFrameState: t4 } = requireConstants(), { kReadyState: n3, kSentClose: r, kByteParser: s3, kReceivedClose: i4 } = requireSymbols(), { fireEvent: E4, failWebsocketConnection: Q } = requireUtil$1(), { channels: C } = diagnostics, { CloseEvent: I } = requireEvents(), { makeRequest: a3 } = requireRequest(), { fetching: f3 } = requireFetch(), { Headers: h4 } = requireHeaders(), { getDecodeSplit: L } = requireUtil$5(), { kHeadersList: c3 } = symbols$4;
    let l3;
    try {
      l3 = import.meta.require("crypto");
    } catch {
    }
    function S(M, B, D, G, g3) {
      const d3 = M;
      d3.protocol = M.protocol === "ws:" ? "http:" : "https:";
      const F = a3({ urlList: [d3], serviceWorkers: "none", referrer: "no-referrer", mode: "websocket", credentials: "include", cache: "no-store", redirect: "error" });
      if (g3.headers) {
        const m3 = new h4(g3.headers)[c3];
        F.headersList = m3;
      }
      const N = l3.randomBytes(16).toString("base64");
      F.headersList.append("sec-websocket-key", N), F.headersList.append("sec-websocket-version", "13");
      for (const m3 of B)
        F.headersList.append("sec-websocket-protocol", m3);
      const u = "";
      return f3({ request: F, useParallelQueue: true, dispatcher: g3.dispatcher, processResponse(m3) {
        if (m3.type === "error" || m3.status !== 101) {
          Q(D, "Received network error or non-101 status code.");
          return;
        }
        if (B.length !== 0 && !m3.headersList.get("Sec-WebSocket-Protocol")) {
          Q(D, "Server did not respond with sent protocols.");
          return;
        }
        if (m3.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          Q(D, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (m3.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          Q(D, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const T = m3.headersList.get("Sec-WebSocket-Accept"), v3 = l3.createHash("sha1").update(N + e3).digest("base64");
        if (T !== v3) {
          Q(D, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const Z = m3.headersList.get("Sec-WebSocket-Extensions");
        if (Z !== null && Z !== u) {
          Q(D, "Received different permessage-deflate than the one set.");
          return;
        }
        const P = m3.headersList.get("Sec-WebSocket-Protocol");
        if (P !== null && !L("sec-websocket-protocol", F.headersList).includes(P)) {
          Q(D, "Protocol was not set in the opening handshake.");
          return;
        }
        m3.socket.on("data", k3), m3.socket.on("close", w), m3.socket.on("error", U), C.open.hasSubscribers && C.open.publish({ address: m3.socket.address(), protocol: P, extensions: Z }), G(m3);
      } });
    }
    o4(S, "establishWebSocketConnection");
    function k3(M) {
      this.ws[s3].write(M) || this.pause();
    }
    o4(k3, "onSocketData");
    function w() {
      const { ws: M } = this, B = M[r] === t4.SENT && M[i4];
      let D = 1005, G = "";
      const g3 = M[s3].closingInfo;
      g3 ? (D = g3.code ?? 1005, G = g3.reason) : M[r] !== t4.SENT && (D = 1006), M[n3] = A.CLOSED, E4("close", M, I, { wasClean: B, code: D, reason: G }), C.close.hasSubscribers && C.close.publish({ websocket: M, code: D, reason: G });
    }
    o4(w, "onSocketClose");
    function U(M) {
      const { ws: B } = this;
      B[n3] = A.CLOSING, C.socketError.hasSubscribers && C.socketError.publish(M), this.destroy();
    }
    return o4(U, "onSocketError"), connection = { establishWebSocketConnection: S }, connection;
  }
  function requireFrame() {
    if (hasRequiredFrame)
      return frame;
    hasRequiredFrame = 1;
    const { maxUnsigned16Bit: e3 } = requireConstants();
    let A;
    try {
      A = import.meta.require("crypto");
    } catch {
    }
    const n3 = class n4 {
      constructor(s3) {
        this.frameData = s3, this.maskKey = A.randomBytes(4);
      }
      createFrame(s3) {
        const i4 = this.frameData?.byteLength ?? 0;
        let E4 = i4, Q = 6;
        i4 > e3 ? (Q += 8, E4 = 127) : i4 > 125 && (Q += 2, E4 = 126);
        const C = Buffer.allocUnsafe(i4 + Q);
        C[0] = C[1] = 0, C[0] |= 128, C[0] = (C[0] & 240) + s3;
        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
        C[Q - 4] = this.maskKey[0], C[Q - 3] = this.maskKey[1], C[Q - 2] = this.maskKey[2], C[Q - 1] = this.maskKey[3], C[1] = E4, E4 === 126 ? C.writeUInt16BE(i4, 2) : E4 === 127 && (C[2] = C[3] = 0, C.writeUIntBE(i4, 4, 6)), C[1] |= 128;
        for (let I = 0;I < i4; I++)
          C[Q + I] = this.frameData[I] ^ this.maskKey[I % 4];
        return C;
      }
    };
    o4(n3, "WebsocketFrameSend");
    let t4 = n3;
    return frame = { WebsocketFrameSend: t4 }, frame;
  }
  function requireReceiver() {
    var S, k3, w, U, M;
    if (hasRequiredReceiver)
      return receiver;
    hasRequiredReceiver = 1;
    const { Writable: e3 } = Stream__default, { parserStates: A, opcodes: t4, states: n3, emptyBuffer: r, sentCloseFrameState: s3 } = requireConstants(), { kReadyState: i4, kSentClose: E4, kResponse: Q, kReceivedClose: C } = requireSymbols(), { channels: I } = diagnostics, { isValidStatusCode: a3, failWebsocketConnection: f3, websocketMessageReceived: h4, utf8Decode: L } = requireUtil$1(), { WebsocketFrameSend: c3 } = requireFrame(), B = class B2 extends e3 {
      constructor(g3) {
        super();
        CA(this, S, []);
        CA(this, k3, 0);
        CA(this, w, A.INFO);
        CA(this, U, {});
        CA(this, M, []);
        this.ws = g3;
      }
      _write(g3, d3, F) {
        p3(this, S).push(g3), EA(this, k3, p3(this, k3) + g3.length), this.run(F);
      }
      run(g3) {
        var d3;
        for (;; ) {
          if (p3(this, w) === A.INFO) {
            if (p3(this, k3) < 2)
              return g3();
            const F = this.consume(2);
            if (p3(this, U).fin = (F[0] & 128) !== 0, p3(this, U).opcode = F[0] & 15, (d3 = p3(this, U)).originalOpcode ?? (d3.originalOpcode = p3(this, U).opcode), p3(this, U).fragmented = !p3(this, U).fin && p3(this, U).opcode !== t4.CONTINUATION, p3(this, U).fragmented && p3(this, U).opcode !== t4.BINARY && p3(this, U).opcode !== t4.TEXT) {
              f3(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const N = F[1] & 127;
            if (N <= 125 ? (p3(this, U).payloadLength = N, EA(this, w, A.READ_DATA)) : N === 126 ? EA(this, w, A.PAYLOADLENGTH_16) : N === 127 && EA(this, w, A.PAYLOADLENGTH_64), p3(this, U).fragmented && N > 125) {
              f3(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((p3(this, U).opcode === t4.PING || p3(this, U).opcode === t4.PONG || p3(this, U).opcode === t4.CLOSE) && N > 125) {
              f3(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (p3(this, U).opcode === t4.CLOSE) {
              if (N === 1) {
                f3(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const u = this.consume(N);
              if (p3(this, U).closeInfo = this.parseCloseBody(u), this.ws[E4] !== s3.SENT) {
                let b = r;
                p3(this, U).closeInfo.code && (b = Buffer.allocUnsafe(2), b.writeUInt16BE(p3(this, U).closeInfo.code, 0));
                const m3 = new c3(b);
                this.ws[Q].socket.write(m3.createFrame(t4.CLOSE), (T) => {
                  T || (this.ws[E4] = s3.SENT);
                });
              }
              this.ws[i4] = n3.CLOSING, this.ws[C] = true, this.end();
              return;
            } else if (p3(this, U).opcode === t4.PING) {
              const u = this.consume(N);
              if (!this.ws[C]) {
                const b = new c3(u);
                this.ws[Q].socket.write(b.createFrame(t4.PONG)), I.ping.hasSubscribers && I.ping.publish({ payload: u });
              }
              if (EA(this, w, A.INFO), p3(this, k3) > 0)
                continue;
              g3();
              return;
            } else if (p3(this, U).opcode === t4.PONG) {
              const u = this.consume(N);
              if (I.pong.hasSubscribers && I.pong.publish({ payload: u }), p3(this, k3) > 0)
                continue;
              g3();
              return;
            }
          } else if (p3(this, w) === A.PAYLOADLENGTH_16) {
            if (p3(this, k3) < 2)
              return g3();
            const F = this.consume(2);
            p3(this, U).payloadLength = F.readUInt16BE(0), EA(this, w, A.READ_DATA);
          } else if (p3(this, w) === A.PAYLOADLENGTH_64) {
            if (p3(this, k3) < 8)
              return g3();
            const F = this.consume(8), N = F.readUInt32BE(0);
            if (N > 2 ** 31 - 1) {
              f3(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const u = F.readUInt32BE(4);
            p3(this, U).payloadLength = (N << 8) + u, EA(this, w, A.READ_DATA);
          } else if (p3(this, w) === A.READ_DATA) {
            if (p3(this, k3) < p3(this, U).payloadLength)
              return g3();
            if (p3(this, k3) >= p3(this, U).payloadLength) {
              const F = this.consume(p3(this, U).payloadLength);
              if (p3(this, M).push(F), !p3(this, U).fragmented || p3(this, U).fin && p3(this, U).opcode === t4.CONTINUATION) {
                const N = Buffer.concat(p3(this, M));
                h4(this.ws, p3(this, U).originalOpcode, N), EA(this, U, {}), p3(this, M).length = 0;
              }
              EA(this, w, A.INFO);
            }
          }
          if (p3(this, k3) === 0) {
            g3();
            break;
          }
        }
      }
      consume(g3) {
        if (g3 > p3(this, k3))
          return null;
        if (g3 === 0)
          return r;
        if (p3(this, S)[0].length === g3)
          return EA(this, k3, p3(this, k3) - p3(this, S)[0].length), p3(this, S).shift();
        const d3 = Buffer.allocUnsafe(g3);
        let F = 0;
        for (;F !== g3; ) {
          const N = p3(this, S)[0], { length: u } = N;
          if (u + F === g3) {
            d3.set(p3(this, S).shift(), F);
            break;
          } else if (u + F > g3) {
            d3.set(N.subarray(0, g3 - F), F), p3(this, S)[0] = N.subarray(g3 - F);
            break;
          } else
            d3.set(p3(this, S).shift(), F), F += N.length;
        }
        return EA(this, k3, p3(this, k3) - g3), d3;
      }
      parseCloseBody(g3) {
        let d3;
        g3.length >= 2 && (d3 = g3.readUInt16BE(0));
        let F = g3.subarray(2);
        if (F[0] === 239 && F[1] === 187 && F[2] === 191 && (F = F.subarray(3)), d3 !== undefined && !a3(d3))
          return null;
        try {
          F = L(F);
        } catch {
          return null;
        }
        return { code: d3, reason: F };
      }
      get closingInfo() {
        return p3(this, U).closeInfo;
      }
    };
    S = new WeakMap, k3 = new WeakMap, w = new WeakMap, U = new WeakMap, M = new WeakMap, o4(B, "ByteParser");
    let l3 = B;
    return receiver = { ByteParser: l3 }, receiver;
  }
  function requireWebsocket() {
    var m3, T, v3, Z, P, kt;
    if (hasRequiredWebsocket)
      return websocket;
    hasRequiredWebsocket = 1;
    const { webidl: e3 } = requireWebidl(), { URLSerializer: A } = requireDataUrl(), { getGlobalOrigin: t4 } = requireGlobal(), { staticPropertyDescriptors: n3, states: r, sentCloseFrameState: s3, opcodes: i4, emptyBuffer: E4 } = requireConstants(), { kWebSocketURL: Q, kReadyState: C, kController: I, kBinaryType: a3, kResponse: f3, kSentClose: h4, kByteParser: L } = requireSymbols(), { isConnecting: c3, isEstablished: l3, isClosed: S, isClosing: k3, isValidSubprotocol: w, failWebsocketConnection: U, fireEvent: M } = requireUtil$1(), { establishWebSocketConnection: B } = requireConnection(), { WebsocketFrameSend: D } = requireFrame(), { ByteParser: G } = requireReceiver(), { kEnumerableProperty: g3, isBlobLike: d3 } = util$m, { getGlobalDispatcher: F } = global2, { types: N } = require$$0__default$1;
    let u = false;
    const K = class K4 extends EventTarget {
      constructor(X, $ = []) {
        super();
        CA(this, P);
        CA(this, m3, { open: null, error: null, close: null, message: null });
        CA(this, T, 0);
        CA(this, v3, "");
        CA(this, Z, "");
        e3.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), u || (u = true, process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" }));
        const V2 = e3.converters["DOMString or sequence<DOMString> or WebSocketInit"]($);
        X = e3.converters.USVString(X), $ = V2.protocols;
        const q = t4();
        let z;
        try {
          z = new URL(X, q);
        } catch (rA) {
          throw new DOMException(rA, "SyntaxError");
        }
        if (z.protocol === "http:" ? z.protocol = "ws:" : z.protocol === "https:" && (z.protocol = "wss:"), z.protocol !== "ws:" && z.protocol !== "wss:")
          throw new DOMException(`Expected a ws: or wss: protocol, got ${z.protocol}`, "SyntaxError");
        if (z.hash || z.href.endsWith("#"))
          throw new DOMException("Got fragment", "SyntaxError");
        if (typeof $ == "string" && ($ = [$]), $.length !== new Set($.map((rA) => rA.toLowerCase())).size)
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        if ($.length > 0 && !$.every((rA) => w(rA)))
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        this[Q] = new URL(z.href), this[I] = B(z, $, this, (rA) => kA(this, P, kt).call(this, rA), V2), this[C] = K4.CONNECTING, this[h4] = s3.NOT_SENT, this[a3] = "blob";
      }
      close(X = undefined, $ = undefined) {
        if (e3.brandCheck(this, K4), X !== undefined && (X = e3.converters["unsigned short"](X, { clamp: true })), $ !== undefined && ($ = e3.converters.USVString($)), X !== undefined && X !== 1000 && (X < 3000 || X > 4999))
          throw new DOMException("invalid code", "InvalidAccessError");
        let V2 = 0;
        if ($ !== undefined && (V2 = Buffer.byteLength($), V2 > 123))
          throw new DOMException(`Reason must be less than 123 bytes; received ${V2}`, "SyntaxError");
        if (!(k3(this) || S(this)))
          if (!l3(this))
            U(this, "Connection was closed before it was established."), this[C] = K4.CLOSING;
          else if (this[h4] === s3.NOT_SENT) {
            this[h4] = s3.PROCESSING;
            const q = new D;
            X !== undefined && $ === undefined ? (q.frameData = Buffer.allocUnsafe(2), q.frameData.writeUInt16BE(X, 0)) : X !== undefined && $ !== undefined ? (q.frameData = Buffer.allocUnsafe(2 + V2), q.frameData.writeUInt16BE(X, 0), q.frameData.write($, 2, "utf-8")) : q.frameData = E4, this[f3].socket.write(q.createFrame(i4.CLOSE), (rA) => {
              rA || (this[h4] = s3.SENT);
            }), this[C] = r.CLOSING;
          } else
            this[C] = K4.CLOSING;
      }
      send(X) {
        if (e3.brandCheck(this, K4), e3.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), X = e3.converters.WebSocketSendData(X), c3(this))
          throw new DOMException("Sent before connected.", "InvalidStateError");
        if (!l3(this) || k3(this))
          return;
        const $ = this[f3].socket;
        if (typeof X == "string") {
          const V2 = Buffer.from(X), z = new D(V2).createFrame(i4.TEXT);
          EA(this, T, p3(this, T) + V2.byteLength), $.write(z, () => {
            EA(this, T, p3(this, T) - V2.byteLength);
          });
        } else if (N.isArrayBuffer(X)) {
          const V2 = Buffer.from(X), z = new D(V2).createFrame(i4.BINARY);
          EA(this, T, p3(this, T) + V2.byteLength), $.write(z, () => {
            EA(this, T, p3(this, T) - V2.byteLength);
          });
        } else if (ArrayBuffer.isView(X)) {
          const V2 = Buffer.from(X, X.byteOffset, X.byteLength), z = new D(V2).createFrame(i4.BINARY);
          EA(this, T, p3(this, T) + V2.byteLength), $.write(z, () => {
            EA(this, T, p3(this, T) - V2.byteLength);
          });
        } else if (d3(X)) {
          const V2 = new D;
          X.arrayBuffer().then((q) => {
            const z = Buffer.from(q);
            V2.frameData = z;
            const rA = V2.createFrame(i4.BINARY);
            EA(this, T, p3(this, T) + z.byteLength), $.write(rA, () => {
              EA(this, T, p3(this, T) - z.byteLength);
            });
          });
        }
      }
      get readyState() {
        return e3.brandCheck(this, K4), this[C];
      }
      get bufferedAmount() {
        return e3.brandCheck(this, K4), p3(this, T);
      }
      get url() {
        return e3.brandCheck(this, K4), A(this[Q]);
      }
      get extensions() {
        return e3.brandCheck(this, K4), p3(this, Z);
      }
      get protocol() {
        return e3.brandCheck(this, K4), p3(this, v3);
      }
      get onopen() {
        return e3.brandCheck(this, K4), p3(this, m3).open;
      }
      set onopen(X) {
        e3.brandCheck(this, K4), p3(this, m3).open && this.removeEventListener("open", p3(this, m3).open), typeof X == "function" ? (p3(this, m3).open = X, this.addEventListener("open", X)) : p3(this, m3).open = null;
      }
      get onerror() {
        return e3.brandCheck(this, K4), p3(this, m3).error;
      }
      set onerror(X) {
        e3.brandCheck(this, K4), p3(this, m3).error && this.removeEventListener("error", p3(this, m3).error), typeof X == "function" ? (p3(this, m3).error = X, this.addEventListener("error", X)) : p3(this, m3).error = null;
      }
      get onclose() {
        return e3.brandCheck(this, K4), p3(this, m3).close;
      }
      set onclose(X) {
        e3.brandCheck(this, K4), p3(this, m3).close && this.removeEventListener("close", p3(this, m3).close), typeof X == "function" ? (p3(this, m3).close = X, this.addEventListener("close", X)) : p3(this, m3).close = null;
      }
      get onmessage() {
        return e3.brandCheck(this, K4), p3(this, m3).message;
      }
      set onmessage(X) {
        e3.brandCheck(this, K4), p3(this, m3).message && this.removeEventListener("message", p3(this, m3).message), typeof X == "function" ? (p3(this, m3).message = X, this.addEventListener("message", X)) : p3(this, m3).message = null;
      }
      get binaryType() {
        return e3.brandCheck(this, K4), this[a3];
      }
      set binaryType(X) {
        e3.brandCheck(this, K4), X !== "blob" && X !== "arraybuffer" ? this[a3] = "blob" : this[a3] = X;
      }
    };
    m3 = new WeakMap, T = new WeakMap, v3 = new WeakMap, Z = new WeakMap, P = new WeakSet, kt = o4(function(X) {
      this[f3] = X;
      const $ = new G(this);
      $.on("drain", o4(function() {
        this.ws[f3].socket.resume();
      }, "onParserDrain")), X.socket.ws = this, this[L] = $, this[C] = r.OPEN;
      const V2 = X.headersList.get("sec-websocket-extensions");
      V2 !== null && EA(this, Z, V2);
      const q = X.headersList.get("sec-websocket-protocol");
      q !== null && EA(this, v3, q), M("open", this);
    }, "#onConnectionEstablished"), o4(K, "WebSocket");
    let b = K;
    return b.CONNECTING = b.prototype.CONNECTING = r.CONNECTING, b.OPEN = b.prototype.OPEN = r.OPEN, b.CLOSING = b.prototype.CLOSING = r.CLOSING, b.CLOSED = b.prototype.CLOSED = r.CLOSED, Object.defineProperties(b.prototype, { CONNECTING: n3, OPEN: n3, CLOSING: n3, CLOSED: n3, url: g3, readyState: g3, bufferedAmount: g3, onopen: g3, onerror: g3, onclose: g3, close: g3, onmessage: g3, binaryType: g3, send: g3, extensions: g3, protocol: g3, [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(b, { CONNECTING: n3, OPEN: n3, CLOSING: n3, CLOSED: n3 }), e3.converters["sequence<DOMString>"] = e3.sequenceConverter(e3.converters.DOMString), e3.converters["DOMString or sequence<DOMString>"] = function(tA) {
      return e3.util.Type(tA) === "Object" && Symbol.iterator in tA ? e3.converters["sequence<DOMString>"](tA) : e3.converters.DOMString(tA);
    }, e3.converters.WebSocketInit = e3.dictionaryConverter([{ key: "protocols", converter: e3.converters["DOMString or sequence<DOMString>"], get defaultValue() {
      return [];
    } }, { key: "dispatcher", converter: (tA) => tA, get defaultValue() {
      return F();
    } }, { key: "headers", converter: e3.nullableConverter(e3.converters.HeadersInit) }]), e3.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(tA) {
      return e3.util.Type(tA) === "Object" && !(Symbol.iterator in tA) ? e3.converters.WebSocketInit(tA) : { protocols: e3.converters["DOMString or sequence<DOMString>"](tA) };
    }, e3.converters.WebSocketSendData = function(tA) {
      if (e3.util.Type(tA) === "Object") {
        if (d3(tA))
          return e3.converters.Blob(tA, { strict: false });
        if (ArrayBuffer.isView(tA) || N.isArrayBuffer(tA))
          return e3.converters.BufferSource(tA);
      }
      return e3.converters.USVString(tA);
    }, websocket = { WebSocket: b }, websocket;
  }
  function requireUtil() {
    if (hasRequiredUtil)
      return util$1;
    hasRequiredUtil = 1;
    function e3(n3) {
      return n3.indexOf("\0") === -1;
    }
    o4(e3, "isValidLastEventId");
    function A(n3) {
      if (n3.length === 0)
        return false;
      for (let r = 0;r < n3.length; r++)
        if (n3.charCodeAt(r) < 48 || n3.charCodeAt(r) > 57)
          return false;
      return true;
    }
    o4(A, "isASCIINumber");
    function t4(n3) {
      return new Promise((r) => {
        setTimeout(r, n3).unref();
      });
    }
    return o4(t4, "delay"), util$1 = { isValidLastEventId: e3, isASCIINumber: A, delay: t4 }, util$1;
  }
  function requireEventsourceStream() {
    if (hasRequiredEventsourceStream)
      return eventsourceStream;
    hasRequiredEventsourceStream = 1;
    const { Transform: e3 } = Stream__default, { isASCIINumber: A, isValidLastEventId: t4 } = requireUtil(), n3 = [239, 187, 191], r = 10, s3 = 13, i4 = 58, E4 = 32, C = class C2 extends e3 {
      constructor(f3 = {}) {
        f3.readableObjectMode = true;
        super(f3);
        NA(this, "state", null);
        NA(this, "checkBOM", true);
        NA(this, "crlfCheck", false);
        NA(this, "eventEndCheck", false);
        NA(this, "buffer", null);
        NA(this, "pos", 0);
        NA(this, "event", { data: undefined, event: undefined, id: undefined, retry: undefined });
        this.state = f3.eventSourceSettings || {}, f3.push && (this.push = f3.push);
      }
      _transform(f3, h4, L) {
        if (f3.length === 0) {
          L();
          return;
        }
        if (this.buffer ? this.buffer = Buffer.concat([this.buffer, f3]) : this.buffer = f3, this.checkBOM)
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === n3[0]) {
                L();
                return;
              }
              this.checkBOM = false, L();
              return;
            case 2:
              if (this.buffer[0] === n3[0] && this.buffer[1] === n3[1]) {
                L();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === n3[0] && this.buffer[1] === n3[1] && this.buffer[2] === n3[2]) {
                this.buffer = Buffer.alloc(0), this.checkBOM = false, L();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              this.buffer[0] === n3[0] && this.buffer[1] === n3[1] && this.buffer[2] === n3[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = false;
              break;
          }
        for (;this.pos < this.buffer.length; ) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === r) {
                this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = false;
                continue;
              }
              this.crlfCheck = false;
            }
            if (this.buffer[this.pos] === r || this.buffer[this.pos] === s3) {
              this.buffer[this.pos] === s3 && (this.crlfCheck = true), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
              continue;
            }
            this.eventEndCheck = false;
            continue;
          }
          if (this.buffer[this.pos] === r || this.buffer[this.pos] === s3) {
            this.buffer[this.pos] === s3 && (this.crlfCheck = true), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = true;
            continue;
          }
          this.pos++;
        }
        L();
      }
      parseLine(f3, h4) {
        if (f3.length === 0)
          return;
        const L = f3.indexOf(i4);
        if (L === 0)
          return;
        let c3 = "", l3 = "";
        if (L !== -1) {
          c3 = f3.subarray(0, L).toString("utf8");
          let S = L + 1;
          f3[S] === E4 && ++S, l3 = f3.subarray(S).toString("utf8");
        } else
          c3 = f3.toString("utf8"), l3 = "";
        switch (c3) {
          case "data":
            h4[c3] === undefined ? h4[c3] = l3 : h4[c3] += `
${l3}`;
            break;
          case "retry":
            A(l3) && (h4[c3] = l3);
            break;
          case "id":
            t4(l3) && (h4[c3] = l3);
            break;
          case "event":
            l3.length > 0 && (h4[c3] = l3);
            break;
        }
      }
      processEvent(f3) {
        f3.retry && A(f3.retry) && (this.state.reconnectionTime = parseInt(f3.retry, 10)), f3.id && t4(f3.id) && (this.state.lastEventId = f3.id), f3.data !== undefined && this.push({ type: f3.event || "message", options: { data: f3.data, lastEventId: this.state.lastEventId, origin: this.state.origin } });
      }
      clearEvent() {
        this.event = { data: undefined, event: undefined, id: undefined, retry: undefined };
      }
    };
    o4(C, "EventSourceStream");
    let Q = C;
    return eventsourceStream = { EventSourceStream: Q }, eventsourceStream;
  }
  function requireEventsource() {
    var U, M, B, D, G, g3, d3, F, $e, u, _e;
    if (hasRequiredEventsource)
      return eventsource;
    hasRequiredEventsource = 1;
    const { pipeline: e3 } = Stream__default, { fetching: A } = requireFetch(), { makeRequest: t4 } = requireRequest(), { getGlobalOrigin: n3 } = requireGlobal(), { webidl: r } = requireWebidl(), { EventSourceStream: s3 } = requireEventsourceStream(), { parseMIMEType: i4 } = requireDataUrl(), { MessageEvent: E4 } = requireEvents(), { isNetworkError: Q } = requireResponse(), { delay: C } = requireUtil(), { kEnumerableProperty: I } = util$m;
    let a3 = false;
    const f3 = 3000, h4 = 0, L = 1, c3 = 2, l3 = "anonymous", S = "use-credentials", m3 = class m4 extends EventTarget {
      constructor(Z, P = {}) {
        super();
        CA(this, F);
        CA(this, u);
        CA(this, U, { open: null, error: null, message: null });
        CA(this, M, null);
        CA(this, B, false);
        CA(this, D, h4);
        CA(this, G, null);
        CA(this, g3, null);
        CA(this, d3, null);
        r.argumentLengthCheck(arguments, 1, { header: "EventSource constructor" }), a3 || (a3 = true, process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" })), Z = r.converters.USVString(Z), P = r.converters.EventSourceInitDict(P), EA(this, d3, { origin: n3(), policyContainer: { referrerPolicy: "no-referrer" }, lastEventId: "", reconnectionTime: f3 });
        let AA;
        try {
          AA = new URL(Z, p3(this, d3).origin), p3(this, d3).origin = AA.origin;
        } catch (aA) {
          throw new DOMException(aA, "SyntaxError");
        }
        EA(this, M, AA.href);
        let K = l3;
        P.withCredentials && (K = S, EA(this, B, true));
        const tA = { redirect: "follow", keepalive: true, mode: "cors", credentials: K === "anonymous" ? "same-origin" : "omit", referrer: "no-referrer" };
        tA.client = p3(this, d3), tA.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], tA.cache = "no-store", tA.initiator = "other", tA.urlList = [new URL(p3(this, M))], EA(this, G, t4(tA)), kA(this, F, $e).call(this);
      }
      get readyState() {
        return p3(this, D);
      }
      get url() {
        return p3(this, M);
      }
      get withCredentials() {
        return p3(this, B);
      }
      close() {
        r.brandCheck(this, m4), p3(this, D) !== c3 && (EA(this, D, c3), clearTimeout(p3(this, d3).reconnectionTimer), p3(this, g3).abort(), p3(this, G) && EA(this, G, null));
      }
      get onopen() {
        return p3(this, U).open;
      }
      set onopen(Z) {
        p3(this, U).open && this.removeEventListener("open", p3(this, U).open), typeof Z == "function" ? (p3(this, U).open = Z, this.addEventListener("open", Z)) : p3(this, U).open = null;
      }
      get onmessage() {
        return p3(this, U).message;
      }
      set onmessage(Z) {
        p3(this, U).message && this.removeEventListener("message", p3(this, U).message), typeof Z == "function" ? (p3(this, U).message = Z, this.addEventListener("message", Z)) : p3(this, U).message = null;
      }
      get onerror() {
        return p3(this, U).error;
      }
      set onerror(Z) {
        p3(this, U).error && this.removeEventListener("error", p3(this, U).error), typeof Z == "function" ? (p3(this, U).error = Z, this.addEventListener("error", Z)) : p3(this, U).error = null;
      }
    };
    U = new WeakMap, M = new WeakMap, B = new WeakMap, D = new WeakMap, G = new WeakMap, g3 = new WeakMap, d3 = new WeakMap, F = new WeakSet, $e = o4(function() {
      if (p3(this, D) === c3)
        return;
      EA(this, D, h4);
      const Z = { request: p3(this, G) }, P = o4((AA) => {
        Q(AA) && (this.dispatchEvent(new Event("error")), this.close()), kA(this, u, _e).call(this);
      }, "processEventSourceEndOfBody");
      Z.processResponseEndOfBody = P, Z.processResponse = (AA) => {
        if (Q(AA))
          if (AA.aborted) {
            this.close(), this.dispatchEvent(new Event("error"));
            return;
          } else {
            kA(this, u, _e).call(this);
            return;
          }
        const K = AA.headersList.get("content-type", true), tA = K !== null ? i4(K) : "failure", aA = tA !== "failure" && tA.essence === "text/event-stream";
        if (AA.status !== 200 || aA === false) {
          this.close(), this.dispatchEvent(new Event("error"));
          return;
        }
        EA(this, D, L), this.dispatchEvent(new Event("open")), p3(this, d3).origin = AA.urlList[AA.urlList.length - 1].origin;
        const X = new s3({ eventSourceSettings: p3(this, d3), push: ($) => {
          this.dispatchEvent(new E4($.type, $.options));
        } });
        e3(AA.body.stream, X, ($) => {
          $?.aborted === false && (this.close(), this.dispatchEvent(new Event("error")));
        });
      }, EA(this, g3, A(Z));
    }, "#connect"), u = new WeakSet, _e = o4(async function() {
      p3(this, D) !== c3 && (EA(this, D, h4), this.dispatchEvent(new Event("error")), await C(p3(this, d3).reconnectionTime), p3(this, D) === h4 && (p3(this, d3).lastEventId !== "" && p3(this, G).headersList.set("last-event-id", p3(this, d3).lastEventId, true), kA(this, F, $e).call(this)));
    }, "#reconnect"), o4(m3, "EventSource");
    let k3 = m3;
    const w = { CONNECTING: { __proto__: null, configurable: false, enumerable: true, value: h4, writable: false }, OPEN: { __proto__: null, configurable: false, enumerable: true, value: L, writable: false }, CLOSED: { __proto__: null, configurable: false, enumerable: true, value: c3, writable: false } };
    return Object.defineProperties(k3, w), Object.defineProperties(k3.prototype, w), Object.defineProperties(k3.prototype, { close: I, onerror: I, onmessage: I, onopen: I, readyState: I, url: I, withCredentials: I }), r.converters.EventSourceInitDict = r.dictionaryConverter([{ key: "withCredentials", converter: r.converters.boolean, defaultValue: false }]), eventsource = { EventSource: k3, defaultReconnectionTime: f3 }, eventsource;
  }
  function makeDispatcher(e3) {
    return (A, t4, n3) => {
      if (typeof t4 == "function" && (n3 = t4, t4 = null), !A || typeof A != "string" && typeof A != "object" && !(A instanceof URL))
        throw new InvalidArgumentError("invalid url");
      if (t4 != null && typeof t4 != "object")
        throw new InvalidArgumentError("invalid opts");
      if (t4 && t4.path != null) {
        if (typeof t4.path != "string")
          throw new InvalidArgumentError("invalid opts.path");
        let i4 = t4.path;
        t4.path.startsWith("/") || (i4 = `/${i4}`), A = new URL(util.parseOrigin(A).origin + i4);
      } else
        t4 || (t4 = typeof A == "object" ? A : {}), A = util.parseURL(A);
      const { agent: r, dispatcher: s3 = getGlobalDispatcher() } = t4;
      if (r)
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      return e3.call(s3, { ...t4, origin: A.origin, path: A.search ? `${A.pathname}${A.search}` : A.pathname, method: t4.method || (t4.body ? "PUT" : "GET") }, n3);
    };
  }
  var Dt = Object.defineProperty;
  var Ft = (e3, A, t4) => (A in e3) ? Dt(e3, A, { enumerable: true, configurable: true, writable: true, value: t4 }) : e3[A] = t4;
  var o4 = (e3, A) => Dt(e3, "name", { value: A, configurable: true });
  var NA = (e3, A, t4) => (Ft(e3, typeof A != "symbol" ? A + "" : A, t4), t4);
  var ze = (e3, A, t4) => {
    if (!A.has(e3))
      throw TypeError("Cannot " + t4);
  };
  var yt = (e3, A) => {
    if (Object(A) !== A)
      throw TypeError('Cannot use the "in" operator on this value');
    return e3.has(A);
  };
  var p3 = (e3, A, t4) => (ze(e3, A, "read from private field"), t4 ? t4.call(e3) : A.get(e3));
  var CA = (e3, A, t4) => {
    if (A.has(e3))
      throw TypeError("Cannot add the same private member more than once");
    A instanceof WeakSet ? A.add(e3) : A.set(e3, t4);
  };
  var EA = (e3, A, t4, n3) => (ze(e3, A, "write to private field"), n3 ? n3.call(e3, t4) : A.set(e3, t4), t4);
  var kA = (e3, A, t4) => (ze(e3, A, "access private method"), t4);
  var ne;
  var se;
  var oe;
  var ie;
  var Qe;
  var Ee;
  var ge;
  var Be;
  var Ce;
  var Ie;
  var ae;
  var ce;
  var he;
  var le;
  var ue;
  var de;
  var fe;
  var De;
  var ye;
  var Re;
  var we;
  var ke;
  var _A;
  var Ne;
  var Fe;
  var pe;
  var Se;
  var Ue;
  var be;
  var me;
  var Le;
  var Me;
  var Ye;
  var Je;
  var Oe;
  var Rt;
  var Ge;
  var Ae;
  var Te;
  var require$$0 = import.meta.require("assert");
  var require$$4 = import.meta.require("net");
  var http$1 = import.meta.require("http");
  var Stream = import.meta.require("stream");
  var require$$6 = import.meta.require("buffer");
  var require$$0$1 = import.meta.require("util");
  var require$$8 = import.meta.require("querystring");
  var require$$0$2 = import.meta.require("diagnostics_channel");
  var require$$0$3 = import.meta.require("events");
  var _commonjsHelpers = require_node_fetch_native_with_agent_61758d11();
  var require$$4$1 = import.meta.require("tls");
  var zlib = import.meta.require("zlib");
  var require$$5 = import.meta.require("perf_hooks");
  var require$$8$1 = import.meta.require("util/types");
  var require$$0$4 = import.meta.require("os");
  var require$$1 = import.meta.require("url");
  var require$$5$1 = import.meta.require("async_hooks");
  import.meta.require("console");
  var require$$5$2 = import.meta.require("string_decoder");
  var require$$2 = import.meta.require("worker_threads");
  o4(_interopDefaultCompat, "_interopDefaultCompat");
  var require$$0__default = _interopDefaultCompat(require$$0);
  var require$$4__default = _interopDefaultCompat(require$$4);
  var http__default = _interopDefaultCompat(http$1);
  var Stream__default = _interopDefaultCompat(Stream);
  var require$$6__default = _interopDefaultCompat(require$$6);
  var require$$0__default$1 = _interopDefaultCompat(require$$0$1);
  var require$$8__default = _interopDefaultCompat(require$$8);
  var require$$0__default$2 = _interopDefaultCompat(require$$0$2);
  var require$$0__default$3 = _interopDefaultCompat(require$$0$3);
  var require$$4__default$1 = _interopDefaultCompat(require$$4$1);
  var zlib__default = _interopDefaultCompat(zlib);
  var require$$5__default = _interopDefaultCompat(require$$5);
  var require$$8__default$1 = _interopDefaultCompat(require$$8$1);
  var require$$0__default$4 = _interopDefaultCompat(require$$0$4);
  var require$$1__default = _interopDefaultCompat(require$$1);
  var require$$5__default$1 = _interopDefaultCompat(require$$5$1);
  var require$$5__default$2 = _interopDefaultCompat(require$$5$2);
  var require$$2__default = _interopDefaultCompat(require$$2);
  var symbols$4 = { kClose: Symbol("close"), kDestroy: Symbol("destroy"), kDispatch: Symbol("dispatch"), kUrl: Symbol("url"), kWriting: Symbol("writing"), kResuming: Symbol("resuming"), kQueue: Symbol("queue"), kConnect: Symbol("connect"), kConnecting: Symbol("connecting"), kHeadersList: Symbol("headers list"), kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"), kKeepAliveMaxTimeout: Symbol("max keep alive timeout"), kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"), kKeepAliveTimeoutValue: Symbol("keep alive timeout"), kKeepAlive: Symbol("keep alive"), kHeadersTimeout: Symbol("headers timeout"), kBodyTimeout: Symbol("body timeout"), kServerName: Symbol("server name"), kLocalAddress: Symbol("local address"), kHost: Symbol("host"), kNoRef: Symbol("no ref"), kBodyUsed: Symbol("used"), kRunning: Symbol("running"), kBlocking: Symbol("blocking"), kPending: Symbol("pending"), kSize: Symbol("size"), kBusy: Symbol("busy"), kQueued: Symbol("queued"), kFree: Symbol("free"), kConnected: Symbol("connected"), kClosed: Symbol("closed"), kNeedDrain: Symbol("need drain"), kReset: Symbol("reset"), kDestroyed: Symbol.for("nodejs.stream.destroyed"), kResume: Symbol("resume"), kOnError: Symbol("on error"), kMaxHeadersSize: Symbol("max headers size"), kRunningIdx: Symbol("running index"), kPendingIdx: Symbol("pending index"), kError: Symbol("error"), kClients: Symbol("clients"), kClient: Symbol("client"), kParser: Symbol("parser"), kOnDestroyed: Symbol("destroy callbacks"), kPipelining: Symbol("pipelining"), kSocket: Symbol("socket"), kHostHeader: Symbol("host header"), kConnector: Symbol("connector"), kStrictContentLength: Symbol("strict content length"), kMaxRedirections: Symbol("maxRedirections"), kMaxRequests: Symbol("maxRequestsPerClient"), kProxy: Symbol("proxy agent options"), kCounter: Symbol("socket request counter"), kInterceptors: Symbol("dispatch interceptors"), kMaxResponseSize: Symbol("max response size"), kHTTP2Session: Symbol("http2Session"), kHTTP2SessionState: Symbol("http2Session state"), kRetryHandlerDefaultRetry: Symbol("retry agent default retry"), kConstruct: Symbol("constructable"), kListeners: Symbol("listeners"), kHTTPContext: Symbol("http context"), kMaxConcurrentStreams: Symbol("max concurrent streams") };
  var UndiciError$1 = (ne = class extends Error {
    constructor(A) {
      super(A), this.name = "UndiciError", this.code = "UND_ERR";
    }
  }, o4(ne, "UndiciError"), ne);
  var ConnectTimeoutError$1 = (se = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ConnectTimeoutError", this.message = A || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }, o4(se, "ConnectTimeoutError"), se);
  var HeadersTimeoutError$1 = (oe = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "HeadersTimeoutError", this.message = A || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }, o4(oe, "HeadersTimeoutError"), oe);
  var HeadersOverflowError$1 = (ie = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "HeadersOverflowError", this.message = A || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }, o4(ie, "HeadersOverflowError"), ie);
  var BodyTimeoutError$1 = (Qe = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "BodyTimeoutError", this.message = A || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }, o4(Qe, "BodyTimeoutError"), Qe);
  var ResponseStatusCodeError$1 = (Ee = class extends UndiciError$1 {
    constructor(A, t4, n3, r) {
      super(A), this.name = "ResponseStatusCodeError", this.message = A || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = r, this.status = t4, this.statusCode = t4, this.headers = n3;
    }
  }, o4(Ee, "ResponseStatusCodeError"), Ee);
  var InvalidArgumentError$k = (ge = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "InvalidArgumentError", this.message = A || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
    }
  }, o4(ge, "InvalidArgumentError"), ge);
  var InvalidReturnValueError$2 = (Be = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "InvalidReturnValueError", this.message = A || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }, o4(Be, "InvalidReturnValueError"), Be);
  var AbortError$1 = (Ce = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "AbortError", this.message = A || "The operation was aborted";
    }
  }, o4(Ce, "AbortError"), Ce);
  var RequestAbortedError$6 = (Ie = class extends AbortError$1 {
    constructor(A) {
      super(A), this.name = "AbortError", this.message = A || "Request aborted", this.code = "UND_ERR_ABORTED";
    }
  }, o4(Ie, "RequestAbortedError"), Ie);
  var InformationalError$3 = (ae = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "InformationalError", this.message = A || "Request information", this.code = "UND_ERR_INFO";
    }
  }, o4(ae, "InformationalError"), ae);
  var RequestContentLengthMismatchError$2 = (ce = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "RequestContentLengthMismatchError", this.message = A || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }, o4(ce, "RequestContentLengthMismatchError"), ce);
  var ResponseContentLengthMismatchError$1 = (he = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ResponseContentLengthMismatchError", this.message = A || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }, o4(he, "ResponseContentLengthMismatchError"), he);
  var ClientDestroyedError$2 = (le = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ClientDestroyedError", this.message = A || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
    }
  }, o4(le, "ClientDestroyedError"), le);
  var ClientClosedError$1 = (ue = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ClientClosedError", this.message = A || "The client is closed", this.code = "UND_ERR_CLOSED";
    }
  }, o4(ue, "ClientClosedError"), ue);
  var SocketError$4 = (de = class extends UndiciError$1 {
    constructor(A, t4) {
      super(A), this.name = "SocketError", this.message = A || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = t4;
    }
  }, o4(de, "SocketError"), de);
  var NotSupportedError$2 = (fe = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "NotSupportedError", this.message = A || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }, o4(fe, "NotSupportedError"), fe);
  var At = class At2 extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "MissingUpstreamError", this.message = A || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  };
  o4(At, "BalancedPoolMissingUpstreamError");
  var BalancedPoolMissingUpstreamError = At;
  var HTTPParserError$1 = (De = class extends Error {
    constructor(A, t4, n3) {
      super(A), this.name = "HTTPParserError", this.code = t4 ? `HPE_${t4}` : undefined, this.data = n3 ? n3.toString() : undefined;
    }
  }, o4(De, "HTTPParserError"), De);
  var ResponseExceededMaxSizeError$1 = (ye = class extends UndiciError$1 {
    constructor(A) {
      super(A), this.name = "ResponseExceededMaxSizeError", this.message = A || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }, o4(ye, "ResponseExceededMaxSizeError"), ye);
  var et = class et2 extends UndiciError$1 {
    constructor(A, t4, { headers: n3, data: r }) {
      super(A), this.name = "RequestRetryError", this.message = A || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = t4, this.data = r, this.headers = n3;
    }
  };
  o4(et, "RequestRetryError");
  var RequestRetryError = et;
  var SecureProxyConnectionError$1 = (Re = class extends UndiciError$1 {
    constructor(A, t4, n3) {
      super(t4, { cause: A, ...n3 ?? {} }), this.name = "SecureProxyConnectionError", this.message = t4 || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = A;
    }
  }, o4(Re, "SecureProxyConnectionError"), Re);
  var errors$1 = { AbortError: AbortError$1, HTTPParserError: HTTPParserError$1, UndiciError: UndiciError$1, HeadersTimeoutError: HeadersTimeoutError$1, HeadersOverflowError: HeadersOverflowError$1, BodyTimeoutError: BodyTimeoutError$1, RequestContentLengthMismatchError: RequestContentLengthMismatchError$2, ConnectTimeoutError: ConnectTimeoutError$1, ResponseStatusCodeError: ResponseStatusCodeError$1, InvalidArgumentError: InvalidArgumentError$k, InvalidReturnValueError: InvalidReturnValueError$2, RequestAbortedError: RequestAbortedError$6, ClientDestroyedError: ClientDestroyedError$2, ClientClosedError: ClientClosedError$1, InformationalError: InformationalError$3, SocketError: SocketError$4, NotSupportedError: NotSupportedError$2, ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1, BalancedPoolMissingUpstreamError, ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1, RequestRetryError, SecureProxyConnectionError: SecureProxyConnectionError$1 };
  var headerNameLowerCasedRecord$3 = {};
  var wellknownHeaderNames$1 = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"];
  for (let e3 = 0;e3 < wellknownHeaderNames$1.length; ++e3) {
    const A = wellknownHeaderNames$1[e3], t4 = A.toLowerCase();
    headerNameLowerCasedRecord$3[A] = headerNameLowerCasedRecord$3[t4] = t4;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord$3, null);
  var constants$5 = { wellknownHeaderNames: wellknownHeaderNames$1, headerNameLowerCasedRecord: headerNameLowerCasedRecord$3 };
  var { wellknownHeaderNames, headerNameLowerCasedRecord: headerNameLowerCasedRecord$2 } = constants$5;
  var xA = class xA2 {
    constructor(A, t4, n3) {
      NA(this, "value", null);
      NA(this, "left", null);
      NA(this, "middle", null);
      NA(this, "right", null);
      NA(this, "code");
      if (n3 === undefined || n3 >= A.length)
        throw new TypeError("Unreachable");
      if ((this.code = A.charCodeAt(n3)) > 127)
        throw new TypeError("key must be ascii string");
      A.length !== ++n3 ? this.middle = new xA2(A, t4, n3) : this.value = t4;
    }
    add(A, t4) {
      const n3 = A.length;
      if (n3 === 0)
        throw new TypeError("Unreachable");
      let r = 0, s3 = this;
      for (;; ) {
        const i4 = A.charCodeAt(r);
        if (i4 > 127)
          throw new TypeError("key must be ascii string");
        if (s3.code === i4)
          if (n3 === ++r) {
            s3.value = t4;
            break;
          } else if (s3.middle !== null)
            s3 = s3.middle;
          else {
            s3.middle = new xA2(A, t4, r);
            break;
          }
        else if (s3.code < i4)
          if (s3.left !== null)
            s3 = s3.left;
          else {
            s3.left = new xA2(A, t4, r);
            break;
          }
        else if (s3.right !== null)
          s3 = s3.right;
        else {
          s3.right = new xA2(A, t4, r);
          break;
        }
      }
    }
    search(A) {
      const t4 = A.length;
      let n3 = 0, r = this;
      for (;r !== null && n3 < t4; ) {
        let s3 = A[n3];
        for (s3 <= 90 && s3 >= 65 && (s3 |= 32);r !== null; ) {
          if (s3 === r.code) {
            if (t4 === ++n3)
              return r;
            r = r.middle;
            break;
          }
          r = r.code < s3 ? r.left : r.right;
        }
      }
      return null;
    }
  };
  o4(xA, "TstNode");
  var TstNode = xA;
  var tt = class tt2 {
    constructor() {
      NA(this, "node", null);
    }
    insert(A, t4) {
      this.node === null ? this.node = new TstNode(A, t4, 0) : this.node.add(A, t4);
    }
    lookup(A) {
      return this.node?.search(A)?.value ?? null;
    }
  };
  o4(tt, "TernarySearchTree");
  var TernarySearchTree = tt;
  var tree$1 = new TernarySearchTree;
  for (let e3 = 0;e3 < wellknownHeaderNames.length; ++e3) {
    const A = headerNameLowerCasedRecord$2[wellknownHeaderNames[e3]];
    tree$1.insert(A, A);
  }
  var tree_1 = { TernarySearchTree, tree: tree$1 };
  var assert$d = require$$0__default;
  var { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$1, kListeners } = symbols$4;
  var { IncomingMessage } = http__default;
  var stream$1 = Stream__default;
  var net$2 = require$$4__default;
  var { InvalidArgumentError: InvalidArgumentError$j } = errors$1;
  var { Blob: Blob$1 } = require$$6__default;
  var nodeUtil = require$$0__default$1;
  var { stringify } = require$$8__default;
  var { headerNameLowerCasedRecord: headerNameLowerCasedRecord$1 } = constants$5;
  var { tree } = tree_1;
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((e3) => Number(e3));
  o4(nop, "nop");
  o4(isStream$1, "isStream$1");
  o4(isBlobLike$1, "isBlobLike$1");
  o4(buildURL$3, "buildURL$3");
  o4(parseURL, "parseURL");
  o4(parseOrigin, "parseOrigin");
  o4(getHostname, "getHostname");
  o4(getServerName$1, "getServerName$1");
  o4(deepClone, "deepClone");
  o4(isAsyncIterable, "isAsyncIterable");
  o4(isIterable$1, "isIterable$1");
  o4(bodyLength, "bodyLength");
  o4(isDestroyed, "isDestroyed");
  o4(isReadableAborted, "isReadableAborted");
  o4(destroy$1, "destroy$1");
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  o4(parseKeepAliveTimeout, "parseKeepAliveTimeout");
  o4(headerNameToString, "headerNameToString");
  o4(bufferToLowerCasedHeaderName, "bufferToLowerCasedHeaderName");
  o4(parseHeaders, "parseHeaders");
  o4(parseRawHeaders, "parseRawHeaders");
  o4(isBuffer$1, "isBuffer$1");
  o4(validateHandler$1, "validateHandler$1");
  o4(isDisturbed, "isDisturbed");
  o4(isErrored, "isErrored");
  o4(isReadable, "isReadable");
  o4(getSocketInfo, "getSocketInfo");
  o4(ReadableStreamFrom$1, "ReadableStreamFrom$1");
  o4(isFormDataLike$1, "isFormDataLike$1");
  o4(addAbortListener$1, "addAbortListener$1");
  var hasToWellFormed = typeof String.prototype.toWellFormed == "function";
  var hasIsWellFormed = typeof String.prototype.isWellFormed == "function";
  o4(toUSVString, "toUSVString");
  o4(isUSVString, "isUSVString");
  o4(isTokenCharCode, "isTokenCharCode");
  o4(isValidHTTPToken$1, "isValidHTTPToken$1");
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  o4(isValidHeaderChar$1, "isValidHeaderChar$1");
  o4(parseRangeHeader, "parseRangeHeader");
  o4(addListener$1, "addListener$1");
  o4(removeAllListeners$1, "removeAllListeners$1");
  o4(errorRequest, "errorRequest");
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  var util$m = { kEnumerableProperty, nop, isDisturbed, isErrored, isReadable, toUSVString, isUSVString, isReadableAborted, isBlobLike: isBlobLike$1, parseOrigin, parseURL, getServerName: getServerName$1, isStream: isStream$1, isIterable: isIterable$1, isAsyncIterable, isDestroyed, headerNameToString, bufferToLowerCasedHeaderName, addListener: addListener$1, removeAllListeners: removeAllListeners$1, errorRequest, parseRawHeaders, parseHeaders, parseKeepAliveTimeout, destroy: destroy$1, bodyLength, deepClone, ReadableStreamFrom: ReadableStreamFrom$1, isBuffer: isBuffer$1, validateHandler: validateHandler$1, getSocketInfo, isFormDataLike: isFormDataLike$1, buildURL: buildURL$3, addAbortListener: addAbortListener$1, isValidHTTPToken: isValidHTTPToken$1, isValidHeaderChar: isValidHeaderChar$1, isTokenCharCode, parseRangeHeader, nodeMajor, nodeMinor, nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13, safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"] };
  var diagnosticsChannel = require$$0__default$2;
  var util$l = require$$0__default$1;
  var undiciDebugLog = util$l.debuglog("undici");
  var fetchDebuglog = util$l.debuglog("fetch");
  var websocketDebuglog = util$l.debuglog("websocket");
  var isClientSet = false;
  var channels$3 = { beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"), connected: diagnosticsChannel.channel("undici:client:connected"), connectError: diagnosticsChannel.channel("undici:client:connectError"), sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"), create: diagnosticsChannel.channel("undici:request:create"), bodySent: diagnosticsChannel.channel("undici:request:bodySent"), headers: diagnosticsChannel.channel("undici:request:headers"), trailers: diagnosticsChannel.channel("undici:request:trailers"), error: diagnosticsChannel.channel("undici:request:error"), open: diagnosticsChannel.channel("undici:websocket:open"), close: diagnosticsChannel.channel("undici:websocket:close"), socketError: diagnosticsChannel.channel("undici:websocket:socket_error"), ping: diagnosticsChannel.channel("undici:websocket:ping"), pong: diagnosticsChannel.channel("undici:websocket:pong") };
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    const e3 = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;
    diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((A) => {
      const { connectParams: { version: t4, protocol: n3, port: r, host: s3 } } = A;
      e3("connecting to %s using %s%s", `${s3}${r ? `:${r}` : ""}`, n3, t4);
    }), diagnosticsChannel.channel("undici:client:connected").subscribe((A) => {
      const { connectParams: { version: t4, protocol: n3, port: r, host: s3 } } = A;
      e3("connected to %s using %s%s", `${s3}${r ? `:${r}` : ""}`, n3, t4);
    }), diagnosticsChannel.channel("undici:client:connectError").subscribe((A) => {
      const { connectParams: { version: t4, protocol: n3, port: r, host: s3 }, error: i4 } = A;
      e3("connection to %s using %s%s errored - %s", `${s3}${r ? `:${r}` : ""}`, n3, t4, i4.message);
    }), diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((A) => {
      const { request: { method: t4, path: n3, origin: r } } = A;
      e3("sending request to %s %s/%s", t4, r, n3);
    }), diagnosticsChannel.channel("undici:request:headers").subscribe((A) => {
      const { request: { method: t4, path: n3, origin: r }, response: { statusCode: s3 } } = A;
      e3("received response to %s %s/%s - HTTP %d", t4, r, n3, s3);
    }), diagnosticsChannel.channel("undici:request:trailers").subscribe((A) => {
      const { request: { method: t4, path: n3, origin: r } } = A;
      e3("trailers received from %s %s/%s", t4, r, n3);
    }), diagnosticsChannel.channel("undici:request:error").subscribe((A) => {
      const { request: { method: t4, path: n3, origin: r }, error: s3 } = A;
      e3("request to %s %s/%s errored - %s", t4, r, n3, s3.message);
    }), isClientSet = true;
  }
  if (websocketDebuglog.enabled) {
    if (!isClientSet) {
      const e3 = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;
      diagnosticsChannel.channel("undici:client:beforeConnect").subscribe((A) => {
        const { connectParams: { version: t4, protocol: n3, port: r, host: s3 } } = A;
        e3("connecting to %s%s using %s%s", s3, r ? `:${r}` : "", n3, t4);
      }), diagnosticsChannel.channel("undici:client:connected").subscribe((A) => {
        const { connectParams: { version: t4, protocol: n3, port: r, host: s3 } } = A;
        e3("connected to %s%s using %s%s", s3, r ? `:${r}` : "", n3, t4);
      }), diagnosticsChannel.channel("undici:client:connectError").subscribe((A) => {
        const { connectParams: { version: t4, protocol: n3, port: r, host: s3 }, error: i4 } = A;
        e3("connection to %s%s using %s%s errored - %s", s3, r ? `:${r}` : "", n3, t4, i4.message);
      }), diagnosticsChannel.channel("undici:client:sendHeaders").subscribe((A) => {
        const { request: { method: t4, path: n3, origin: r } } = A;
        e3("sending request to %s %s/%s", t4, r, n3);
      });
    }
    diagnosticsChannel.channel("undici:websocket:open").subscribe((e3) => {
      const { address: { address: A, port: t4 } } = e3;
      websocketDebuglog("connection opened %s%s", A, t4 ? `:${t4}` : "");
    }), diagnosticsChannel.channel("undici:websocket:close").subscribe((e3) => {
      const { websocket: A, code: t4, reason: n3 } = e3;
      websocketDebuglog("closed connection to %s - %s %s", A.url, t4, n3);
    }), diagnosticsChannel.channel("undici:websocket:socket_error").subscribe((e3) => {
      websocketDebuglog("connection errored - %s", e3.message);
    }), diagnosticsChannel.channel("undici:websocket:ping").subscribe((e3) => {
      websocketDebuglog("ping received");
    }), diagnosticsChannel.channel("undici:websocket:pong").subscribe((e3) => {
      websocketDebuglog("pong received");
    });
  }
  var diagnostics = { channels: channels$3 };
  var { InvalidArgumentError: InvalidArgumentError$i, NotSupportedError: NotSupportedError$1 } = errors$1;
  var assert$c = require$$0__default;
  var { isValidHTTPToken, isValidHeaderChar, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL: buildURL$2, validateHandler, getServerName } = util$m;
  var { channels: channels$2 } = diagnostics;
  var { headerNameLowerCasedRecord } = constants$5;
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");
  var Request$1 = (we = class {
    constructor(A, { path: t4, method: n3, body: r, headers: s3, query: i4, idempotent: E4, blocking: Q, upgrade: C, headersTimeout: I, bodyTimeout: a3, reset: f3, throwOnError: h4, expectContinue: L, servername: c3 }, l3) {
      if (typeof t4 != "string")
        throw new InvalidArgumentError$i("path must be a string");
      if (t4[0] !== "/" && !(t4.startsWith("http://") || t4.startsWith("https://")) && n3 !== "CONNECT")
        throw new InvalidArgumentError$i("path must be an absolute URL or start with a slash");
      if (invalidPathRegex.exec(t4) !== null)
        throw new InvalidArgumentError$i("invalid request path");
      if (typeof n3 != "string")
        throw new InvalidArgumentError$i("method must be a string");
      if (!isValidHTTPToken(n3))
        throw new InvalidArgumentError$i("invalid request method");
      if (C && typeof C != "string")
        throw new InvalidArgumentError$i("upgrade must be a string");
      if (I != null && (!Number.isFinite(I) || I < 0))
        throw new InvalidArgumentError$i("invalid headersTimeout");
      if (a3 != null && (!Number.isFinite(a3) || a3 < 0))
        throw new InvalidArgumentError$i("invalid bodyTimeout");
      if (f3 != null && typeof f3 != "boolean")
        throw new InvalidArgumentError$i("invalid reset");
      if (L != null && typeof L != "boolean")
        throw new InvalidArgumentError$i("invalid expectContinue");
      if (this.headersTimeout = I, this.bodyTimeout = a3, this.throwOnError = h4 === true, this.method = n3, this.abort = null, r == null)
        this.body = null;
      else if (isStream(r)) {
        this.body = r;
        const S = this.body._readableState;
        (!S || !S.autoDestroy) && (this.endHandler = o4(function() {
          destroy(this);
        }, "autoDestroy"), this.body.on("end", this.endHandler)), this.errorHandler = (k3) => {
          this.abort ? this.abort(k3) : this.error = k3;
        }, this.body.on("error", this.errorHandler);
      } else if (isBuffer(r))
        this.body = r.byteLength ? r : null;
      else if (ArrayBuffer.isView(r))
        this.body = r.buffer.byteLength ? Buffer.from(r.buffer, r.byteOffset, r.byteLength) : null;
      else if (r instanceof ArrayBuffer)
        this.body = r.byteLength ? Buffer.from(r) : null;
      else if (typeof r == "string")
        this.body = r.length ? Buffer.from(r) : null;
      else if (isFormDataLike(r) || isIterable(r) || isBlobLike(r))
        this.body = r;
      else
        throw new InvalidArgumentError$i("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      if (this.completed = false, this.aborted = false, this.upgrade = C || null, this.path = i4 ? buildURL$2(t4, i4) : t4, this.origin = A, this.idempotent = E4 ?? (n3 === "HEAD" || n3 === "GET"), this.blocking = Q ?? false, this.reset = f3 ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = L ?? false, Array.isArray(s3)) {
        if (s3.length % 2 !== 0)
          throw new InvalidArgumentError$i("headers array must be even");
        for (let S = 0;S < s3.length; S += 2)
          processHeader(this, s3[S], s3[S + 1]);
      } else if (s3 && typeof s3 == "object")
        if (s3[Symbol.iterator])
          for (const S of s3) {
            if (!Array.isArray(S) || S.length !== 2)
              throw new InvalidArgumentError$i("headers must be in key-value pair format");
            processHeader(this, S[0], S[1]);
          }
        else {
          const S = Object.keys(s3);
          for (let k3 = 0;k3 < S.length; ++k3)
            processHeader(this, S[k3], s3[S[k3]]);
        }
      else if (s3 != null)
        throw new InvalidArgumentError$i("headers must be an object or an array");
      validateHandler(l3, n3, C), this.servername = c3 || getServerName(this.host), this[kHandler] = l3, channels$2.create.hasSubscribers && channels$2.create.publish({ request: this });
    }
    onBodySent(A) {
      if (this[kHandler].onBodySent)
        try {
          return this[kHandler].onBodySent(A);
        } catch (t4) {
          this.abort(t4);
        }
    }
    onRequestSent() {
      if (channels$2.bodySent.hasSubscribers && channels$2.bodySent.publish({ request: this }), this[kHandler].onRequestSent)
        try {
          return this[kHandler].onRequestSent();
        } catch (A) {
          this.abort(A);
        }
    }
    onConnect(A) {
      if (assert$c(!this.aborted), assert$c(!this.completed), this.error)
        A(this.error);
      else
        return this.abort = A, this[kHandler].onConnect(A);
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(A, t4, n3, r) {
      assert$c(!this.aborted), assert$c(!this.completed), channels$2.headers.hasSubscribers && channels$2.headers.publish({ request: this, response: { statusCode: A, headers: t4, statusText: r } });
      try {
        return this[kHandler].onHeaders(A, t4, n3, r);
      } catch (s3) {
        this.abort(s3);
      }
    }
    onData(A) {
      assert$c(!this.aborted), assert$c(!this.completed);
      try {
        return this[kHandler].onData(A);
      } catch (t4) {
        return this.abort(t4), false;
      }
    }
    onUpgrade(A, t4, n3) {
      return assert$c(!this.aborted), assert$c(!this.completed), this[kHandler].onUpgrade(A, t4, n3);
    }
    onComplete(A) {
      this.onFinally(), assert$c(!this.aborted), this.completed = true, channels$2.trailers.hasSubscribers && channels$2.trailers.publish({ request: this, trailers: A });
      try {
        return this[kHandler].onComplete(A);
      } catch (t4) {
        this.onError(t4);
      }
    }
    onError(A) {
      if (this.onFinally(), channels$2.error.hasSubscribers && channels$2.error.publish({ request: this, error: A }), !this.aborted)
        return this.aborted = true, this[kHandler].onError(A);
    }
    onFinally() {
      this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
    }
    addHeader(A, t4) {
      return processHeader(this, A, t4), this;
    }
  }, o4(we, "Request"), we);
  o4(processHeader, "processHeader");
  var request$2 = Request$1;
  var EventEmitter = require$$0__default$3;
  var Dispatcher$2 = (ke = class extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...A) {
      const t4 = Array.isArray(A[0]) ? A[0] : A;
      let n3 = this.dispatch.bind(this);
      for (const r of t4)
        if (r != null) {
          if (typeof r != "function")
            throw new TypeError(`invalid interceptor, expected function received ${typeof r}`);
          if (n3 = r(n3), n3 == null || typeof n3 != "function" || n3.length !== 2)
            throw new TypeError("invalid interceptor");
        }
      return new ComposedDispatcher(this, n3);
    }
  }, o4(ke, "Dispatcher"), ke);
  var rt = class rt2 extends Dispatcher$2 {
    constructor(t4, n3) {
      super();
      CA(this, _A, null);
      CA(this, Ne, null);
      EA(this, _A, t4), EA(this, Ne, n3);
    }
    dispatch(...t4) {
      p3(this, Ne).call(this, ...t4);
    }
    close(...t4) {
      return p3(this, _A).close(...t4);
    }
    destroy(...t4) {
      return p3(this, _A).destroy(...t4);
    }
  };
  _A = new WeakMap, Ne = new WeakMap, o4(rt, "ComposedDispatcher");
  var ComposedDispatcher = rt;
  var dispatcher = Dispatcher$2;
  var Dispatcher$1 = dispatcher;
  var { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$h } = errors$1;
  var { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$4 } = symbols$4;
  var kDestroyed = Symbol("destroyed");
  var kClosed = Symbol("closed");
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");
  var DispatcherBase$4 = (Fe = class extends Dispatcher$1 {
    constructor() {
      super(), this[kDestroyed] = false, this[kOnDestroyed] = null, this[kClosed] = false, this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors$4];
    }
    set interceptors(A) {
      if (A) {
        for (let t4 = A.length - 1;t4 >= 0; t4--)
          if (typeof this[kInterceptors$4][t4] != "function")
            throw new InvalidArgumentError$h("interceptor must be an function");
      }
      this[kInterceptors$4] = A;
    }
    close(A) {
      if (A === undefined)
        return new Promise((n3, r) => {
          this.close((s3, i4) => s3 ? r(s3) : n3(i4));
        });
      if (typeof A != "function")
        throw new InvalidArgumentError$h("invalid callback");
      if (this[kDestroyed]) {
        queueMicrotask(() => A(new ClientDestroyedError$1, null));
        return;
      }
      if (this[kClosed]) {
        this[kOnClosed] ? this[kOnClosed].push(A) : queueMicrotask(() => A(null, null));
        return;
      }
      this[kClosed] = true, this[kOnClosed].push(A);
      const t4 = o4(() => {
        const n3 = this[kOnClosed];
        this[kOnClosed] = null;
        for (let r = 0;r < n3.length; r++)
          n3[r](null, null);
      }, "onClosed");
      this[kClose$6]().then(() => this.destroy()).then(() => {
        queueMicrotask(t4);
      });
    }
    destroy(A, t4) {
      if (typeof A == "function" && (t4 = A, A = null), t4 === undefined)
        return new Promise((r, s3) => {
          this.destroy(A, (i4, E4) => i4 ? s3(i4) : r(E4));
        });
      if (typeof t4 != "function")
        throw new InvalidArgumentError$h("invalid callback");
      if (this[kDestroyed]) {
        this[kOnDestroyed] ? this[kOnDestroyed].push(t4) : queueMicrotask(() => t4(null, null));
        return;
      }
      A || (A = new ClientDestroyedError$1), this[kDestroyed] = true, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(t4);
      const n3 = o4(() => {
        const r = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let s3 = 0;s3 < r.length; s3++)
          r[s3](null, null);
      }, "onDestroyed");
      this[kDestroy$4](A).then(() => {
        queueMicrotask(n3);
      });
    }
    [kInterceptedDispatch](A, t4) {
      if (!this[kInterceptors$4] || this[kInterceptors$4].length === 0)
        return this[kInterceptedDispatch] = this[kDispatch$3], this[kDispatch$3](A, t4);
      let n3 = this[kDispatch$3].bind(this);
      for (let r = this[kInterceptors$4].length - 1;r >= 0; r--)
        n3 = this[kInterceptors$4][r](n3);
      return this[kInterceptedDispatch] = n3, n3(A, t4);
    }
    dispatch(A, t4) {
      if (!t4 || typeof t4 != "object")
        throw new InvalidArgumentError$h("handler must be an object");
      try {
        if (!A || typeof A != "object")
          throw new InvalidArgumentError$h("opts must be an object.");
        if (this[kDestroyed] || this[kOnDestroyed])
          throw new ClientDestroyedError$1;
        if (this[kClosed])
          throw new ClientClosedError;
        return this[kInterceptedDispatch](A, t4);
      } catch (n3) {
        if (typeof t4.onError != "function")
          throw new InvalidArgumentError$h("invalid onError method");
        return t4.onError(n3), false;
      }
    }
  }, o4(Fe, "DispatcherBase"), Fe);
  var dispatcherBase = DispatcherBase$4;
  var net$1 = require$$4__default;
  var assert$b = require$$0__default;
  var util$k = util$m;
  var { InvalidArgumentError: InvalidArgumentError$g, ConnectTimeoutError } = errors$1;
  var tls;
  var SessionCache;
  _commonjsHelpers.commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? SessionCache = (pe = class {
    constructor(A) {
      this._maxCachedSessions = A, this._sessionCache = new Map, this._sessionRegistry = new _commonjsHelpers.commonjsGlobal.FinalizationRegistry((t4) => {
        if (this._sessionCache.size < this._maxCachedSessions)
          return;
        const n3 = this._sessionCache.get(t4);
        n3 !== undefined && n3.deref() === undefined && this._sessionCache.delete(t4);
      });
    }
    get(A) {
      const t4 = this._sessionCache.get(A);
      return t4 ? t4.deref() : null;
    }
    set(A, t4) {
      this._maxCachedSessions !== 0 && (this._sessionCache.set(A, new WeakRef(t4)), this._sessionRegistry.register(t4, A));
    }
  }, o4(pe, "WeakSessionCache"), pe) : SessionCache = (Se = class {
    constructor(A) {
      this._maxCachedSessions = A, this._sessionCache = new Map;
    }
    get(A) {
      return this._sessionCache.get(A);
    }
    set(A, t4) {
      if (this._maxCachedSessions !== 0) {
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: n3 } = this._sessionCache.keys().next();
          this._sessionCache.delete(n3);
        }
        this._sessionCache.set(A, t4);
      }
    }
  }, o4(Se, "SimpleSessionCache"), Se);
  o4(buildConnector$3, "buildConnector$3");
  o4(setupTimeout, "setupTimeout");
  o4(onConnectTimeout, "onConnectTimeout");
  var connect$2 = buildConnector$3;
  var fastNow = Date.now();
  var fastNowTimeout;
  var fastTimers = [];
  o4(onTimeout, "onTimeout");
  o4(refreshTimeout, "refreshTimeout");
  var nt = class nt2 {
    constructor(A, t4, n3) {
      this.callback = A, this.delay = t4, this.opaque = n3, this.state = -2, this.refresh();
    }
    refresh() {
      this.state === -2 && (fastTimers.push(this), (!fastNowTimeout || fastTimers.length === 1) && refreshTimeout()), this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  };
  o4(nt, "Timeout");
  var Timeout = nt;
  var timers$1 = { setTimeout(e3, A, t4) {
    return A < 1000 ? setTimeout(e3, A, t4) : new Timeout(e3, A, t4);
  }, clearTimeout(e3) {
    e3 instanceof Timeout ? e3.clear() : clearTimeout(e3);
  } };
  var constants$4 = {};
  var utils = {};
  Object.defineProperty(utils, "__esModule", { value: true }), utils.enumToMap = undefined;
  o4(enumToMap, "enumToMap"), utils.enumToMap = enumToMap, function(e3) {
    Object.defineProperty(e3, "__esModule", { value: true }), e3.SPECIAL_HEADERS = e3.HEADER_STATE = e3.MINOR = e3.MAJOR = e3.CONNECTION_TOKEN_CHARS = e3.HEADER_CHARS = e3.TOKEN = e3.STRICT_TOKEN = e3.HEX = e3.URL_CHAR = e3.STRICT_URL_CHAR = e3.USERINFO_CHARS = e3.MARK = e3.ALPHANUM = e3.NUM = e3.HEX_MAP = e3.NUM_MAP = e3.ALPHA = e3.FINISH = e3.H_METHOD_MAP = e3.METHOD_MAP = e3.METHODS_RTSP = e3.METHODS_ICE = e3.METHODS_HTTP = e3.METHODS = e3.LENIENT_FLAGS = e3.FLAGS = e3.TYPE = e3.ERROR = undefined;
    const A = utils;
    (function(r) {
      r[r.OK = 0] = "OK", r[r.INTERNAL = 1] = "INTERNAL", r[r.STRICT = 2] = "STRICT", r[r.LF_EXPECTED = 3] = "LF_EXPECTED", r[r.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", r[r.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", r[r.INVALID_METHOD = 6] = "INVALID_METHOD", r[r.INVALID_URL = 7] = "INVALID_URL", r[r.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", r[r.INVALID_VERSION = 9] = "INVALID_VERSION", r[r.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", r[r.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", r[r.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", r[r.INVALID_STATUS = 13] = "INVALID_STATUS", r[r.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", r[r.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", r[r.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", r[r.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", r[r.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", r[r.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", r[r.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", r[r.PAUSED = 21] = "PAUSED", r[r.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", r[r.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", r[r.USER = 24] = "USER";
    })(e3.ERROR || (e3.ERROR = {})), function(r) {
      r[r.BOTH = 0] = "BOTH", r[r.REQUEST = 1] = "REQUEST", r[r.RESPONSE = 2] = "RESPONSE";
    }(e3.TYPE || (e3.TYPE = {})), function(r) {
      r[r.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", r[r.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", r[r.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", r[r.CHUNKED = 8] = "CHUNKED", r[r.UPGRADE = 16] = "UPGRADE", r[r.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", r[r.SKIPBODY = 64] = "SKIPBODY", r[r.TRAILING = 128] = "TRAILING", r[r.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
    }(e3.FLAGS || (e3.FLAGS = {})), function(r) {
      r[r.HEADERS = 1] = "HEADERS", r[r.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", r[r.KEEP_ALIVE = 4] = "KEEP_ALIVE";
    }(e3.LENIENT_FLAGS || (e3.LENIENT_FLAGS = {}));
    var t4;
    (function(r) {
      r[r.DELETE = 0] = "DELETE", r[r.GET = 1] = "GET", r[r.HEAD = 2] = "HEAD", r[r.POST = 3] = "POST", r[r.PUT = 4] = "PUT", r[r.CONNECT = 5] = "CONNECT", r[r.OPTIONS = 6] = "OPTIONS", r[r.TRACE = 7] = "TRACE", r[r.COPY = 8] = "COPY", r[r.LOCK = 9] = "LOCK", r[r.MKCOL = 10] = "MKCOL", r[r.MOVE = 11] = "MOVE", r[r.PROPFIND = 12] = "PROPFIND", r[r.PROPPATCH = 13] = "PROPPATCH", r[r.SEARCH = 14] = "SEARCH", r[r.UNLOCK = 15] = "UNLOCK", r[r.BIND = 16] = "BIND", r[r.REBIND = 17] = "REBIND", r[r.UNBIND = 18] = "UNBIND", r[r.ACL = 19] = "ACL", r[r.REPORT = 20] = "REPORT", r[r.MKACTIVITY = 21] = "MKACTIVITY", r[r.CHECKOUT = 22] = "CHECKOUT", r[r.MERGE = 23] = "MERGE", r[r["M-SEARCH"] = 24] = "M-SEARCH", r[r.NOTIFY = 25] = "NOTIFY", r[r.SUBSCRIBE = 26] = "SUBSCRIBE", r[r.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", r[r.PATCH = 28] = "PATCH", r[r.PURGE = 29] = "PURGE", r[r.MKCALENDAR = 30] = "MKCALENDAR", r[r.LINK = 31] = "LINK", r[r.UNLINK = 32] = "UNLINK", r[r.SOURCE = 33] = "SOURCE", r[r.PRI = 34] = "PRI", r[r.DESCRIBE = 35] = "DESCRIBE", r[r.ANNOUNCE = 36] = "ANNOUNCE", r[r.SETUP = 37] = "SETUP", r[r.PLAY = 38] = "PLAY", r[r.PAUSE = 39] = "PAUSE", r[r.TEARDOWN = 40] = "TEARDOWN", r[r.GET_PARAMETER = 41] = "GET_PARAMETER", r[r.SET_PARAMETER = 42] = "SET_PARAMETER", r[r.REDIRECT = 43] = "REDIRECT", r[r.RECORD = 44] = "RECORD", r[r.FLUSH = 45] = "FLUSH";
    })(t4 = e3.METHODS || (e3.METHODS = {})), e3.METHODS_HTTP = [t4.DELETE, t4.GET, t4.HEAD, t4.POST, t4.PUT, t4.CONNECT, t4.OPTIONS, t4.TRACE, t4.COPY, t4.LOCK, t4.MKCOL, t4.MOVE, t4.PROPFIND, t4.PROPPATCH, t4.SEARCH, t4.UNLOCK, t4.BIND, t4.REBIND, t4.UNBIND, t4.ACL, t4.REPORT, t4.MKACTIVITY, t4.CHECKOUT, t4.MERGE, t4["M-SEARCH"], t4.NOTIFY, t4.SUBSCRIBE, t4.UNSUBSCRIBE, t4.PATCH, t4.PURGE, t4.MKCALENDAR, t4.LINK, t4.UNLINK, t4.PRI, t4.SOURCE], e3.METHODS_ICE = [t4.SOURCE], e3.METHODS_RTSP = [t4.OPTIONS, t4.DESCRIBE, t4.ANNOUNCE, t4.SETUP, t4.PLAY, t4.PAUSE, t4.TEARDOWN, t4.GET_PARAMETER, t4.SET_PARAMETER, t4.REDIRECT, t4.RECORD, t4.FLUSH, t4.GET, t4.POST], e3.METHOD_MAP = A.enumToMap(t4), e3.H_METHOD_MAP = {}, Object.keys(e3.METHOD_MAP).forEach((r) => {
      /^H/.test(r) && (e3.H_METHOD_MAP[r] = e3.METHOD_MAP[r]);
    }), function(r) {
      r[r.SAFE = 0] = "SAFE", r[r.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", r[r.UNSAFE = 2] = "UNSAFE";
    }(e3.FINISH || (e3.FINISH = {})), e3.ALPHA = [];
    for (let r = 65;r <= 90; r++)
      e3.ALPHA.push(String.fromCharCode(r)), e3.ALPHA.push(String.fromCharCode(r + 32));
    e3.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 }, e3.HEX_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, e3.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], e3.ALPHANUM = e3.ALPHA.concat(e3.NUM), e3.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], e3.USERINFO_CHARS = e3.ALPHANUM.concat(e3.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), e3.STRICT_URL_CHAR = ["!", '"', "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"].concat(e3.ALPHANUM), e3.URL_CHAR = e3.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let r = 128;r <= 255; r++)
      e3.URL_CHAR.push(r);
    e3.HEX = e3.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), e3.STRICT_TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(e3.ALPHANUM), e3.TOKEN = e3.STRICT_TOKEN.concat([" "]), e3.HEADER_CHARS = ["	"];
    for (let r = 32;r <= 255; r++)
      r !== 127 && e3.HEADER_CHARS.push(r);
    e3.CONNECTION_TOKEN_CHARS = e3.HEADER_CHARS.filter((r) => r !== 44), e3.MAJOR = e3.NUM_MAP, e3.MINOR = e3.MAJOR;
    var n3;
    (function(r) {
      r[r.GENERAL = 0] = "GENERAL", r[r.CONNECTION = 1] = "CONNECTION", r[r.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", r[r.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", r[r.UPGRADE = 4] = "UPGRADE", r[r.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", r[r.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", r[r.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", r[r.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(n3 = e3.HEADER_STATE || (e3.HEADER_STATE = {})), e3.SPECIAL_HEADERS = { connection: n3.CONNECTION, "content-length": n3.CONTENT_LENGTH, "proxy-connection": n3.CONNECTION, "transfer-encoding": n3.TRANSFER_ENCODING, upgrade: n3.UPGRADE };
  }(constants$4);
  var llhttpWasm;
  var hasRequiredLlhttpWasm;
  o4(requireLlhttpWasm, "requireLlhttpWasm");
  var llhttp_simdWasm;
  var hasRequiredLlhttp_simdWasm;
  o4(requireLlhttp_simdWasm, "requireLlhttp_simdWasm");
  var constants$3;
  var hasRequiredConstants$2;
  o4(requireConstants$2, "requireConstants$2");
  var global$1;
  var hasRequiredGlobal;
  o4(requireGlobal, "requireGlobal");
  var dataUrl;
  var hasRequiredDataUrl;
  o4(requireDataUrl, "requireDataUrl");
  var webidl_1;
  var hasRequiredWebidl;
  o4(requireWebidl, "requireWebidl");
  var util$j;
  var hasRequiredUtil$5;
  o4(requireUtil$5, "requireUtil$5");
  var symbols$3;
  var hasRequiredSymbols$3;
  o4(requireSymbols$3, "requireSymbols$3");
  var file;
  var hasRequiredFile;
  o4(requireFile, "requireFile");
  var formdata;
  var hasRequiredFormdata;
  o4(requireFormdata, "requireFormdata");
  var formdataParser;
  var hasRequiredFormdataParser;
  o4(requireFormdataParser, "requireFormdataParser");
  var body;
  var hasRequiredBody;
  o4(requireBody, "requireBody");
  var assert$a = require$$0__default;
  var util$i = util$m;
  var { channels: channels$1 } = diagnostics;
  var timers = timers$1;
  var { RequestContentLengthMismatchError: RequestContentLengthMismatchError$1, ResponseContentLengthMismatchError, RequestAbortedError: RequestAbortedError$5, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$3, InformationalError: InformationalError$2, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = errors$1;
  var { kUrl: kUrl$4, kReset: kReset$1, kClient: kClient$3, kParser, kBlocking, kRunning: kRunning$5, kPending: kPending$4, kSize: kSize$4, kWriting, kQueue: kQueue$3, kNoRef, kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout$1, kHostHeader: kHostHeader$1, kPendingIdx: kPendingIdx$2, kRunningIdx: kRunningIdx$2, kError: kError$2, kPipelining: kPipelining$1, kSocket: kSocket$1, kKeepAliveTimeoutValue: kKeepAliveTimeoutValue$1, kMaxHeadersSize: kMaxHeadersSize$1, kKeepAliveMaxTimeout: kKeepAliveMaxTimeout$1, kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold$1, kHeadersTimeout: kHeadersTimeout$1, kBodyTimeout: kBodyTimeout$1, kStrictContentLength: kStrictContentLength$2, kMaxRequests: kMaxRequests$1, kCounter: kCounter$1, kMaxResponseSize: kMaxResponseSize$1, kOnError: kOnError$2, kResume: kResume$3, kHTTPContext: kHTTPContext$1 } = symbols$4;
  var constants$2 = constants$4;
  var EMPTY_BUF = Buffer.alloc(0);
  var FastBuffer = Buffer[Symbol.species];
  var addListener = util$i.addListener;
  var removeAllListeners = util$i.removeAllListeners;
  var extractBody;
  o4(lazyllhttp, "lazyllhttp");
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var TIMEOUT_HEADERS = 1;
  var TIMEOUT_BODY = 2;
  var TIMEOUT_IDLE = 3;
  var st = class st2 {
    constructor(A, t4, { exports: n3 }) {
      assert$a(Number.isFinite(A[kMaxHeadersSize$1]) && A[kMaxHeadersSize$1] > 0), this.llhttp = n3, this.ptr = this.llhttp.llhttp_alloc(constants$2.TYPE.RESPONSE), this.client = A, this.socket = t4, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = false, this.headers = [], this.headersSize = 0, this.headersMaxSize = A[kMaxHeadersSize$1], this.shouldKeepAlive = false, this.paused = false, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = A[kMaxResponseSize$1];
    }
    setTimeout(A, t4) {
      this.timeoutType = t4, A !== this.timeoutValue ? (timers.clearTimeout(this.timeout), A ? (this.timeout = timers.setTimeout(onParserTimeout, A, this), this.timeout.unref && this.timeout.unref()) : this.timeout = null, this.timeoutValue = A) : this.timeout && this.timeout.refresh && this.timeout.refresh();
    }
    resume() {
      this.socket.destroyed || !this.paused || (assert$a(this.ptr != null), assert$a(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert$a(this.timeoutType === TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = false, this.execute(this.socket.read() || EMPTY_BUF), this.readMore());
    }
    readMore() {
      for (;!this.paused && this.ptr; ) {
        const A = this.socket.read();
        if (A === null)
          break;
        this.execute(A);
      }
    }
    execute(A) {
      assert$a(this.ptr != null), assert$a(currentParser == null), assert$a(!this.paused);
      const { socket: t4, llhttp: n3 } = this;
      A.length > currentBufferSize && (currentBufferPtr && n3.free(currentBufferPtr), currentBufferSize = Math.ceil(A.length / 4096) * 4096, currentBufferPtr = n3.malloc(currentBufferSize)), new Uint8Array(n3.memory.buffer, currentBufferPtr, currentBufferSize).set(A);
      try {
        let r;
        try {
          currentBufferRef = A, currentParser = this, r = n3.llhttp_execute(this.ptr, currentBufferPtr, A.length);
        } catch (i4) {
          throw i4;
        } finally {
          currentParser = null, currentBufferRef = null;
        }
        const s3 = n3.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (r === constants$2.ERROR.PAUSED_UPGRADE)
          this.onUpgrade(A.slice(s3));
        else if (r === constants$2.ERROR.PAUSED)
          this.paused = true, t4.unshift(A.slice(s3));
        else if (r !== constants$2.ERROR.OK) {
          const i4 = n3.llhttp_get_error_reason(this.ptr);
          let E4 = "";
          if (i4) {
            const Q = new Uint8Array(n3.memory.buffer, i4).indexOf(0);
            E4 = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(n3.memory.buffer, i4, Q).toString() + ")";
          }
          throw new HTTPParserError(E4, constants$2.ERROR[r], A.slice(s3));
        }
      } catch (r) {
        util$i.destroy(t4, r);
      }
    }
    destroy() {
      assert$a(this.ptr != null), assert$a(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = false;
    }
    onStatus(A) {
      this.statusText = A.toString();
    }
    onMessageBegin() {
      const { socket: A, client: t4 } = this;
      if (A.destroyed)
        return -1;
      const n3 = t4[kQueue$3][t4[kRunningIdx$2]];
      if (!n3)
        return -1;
      n3.onResponseStarted();
    }
    onHeaderField(A) {
      const t4 = this.headers.length;
      t4 & 1 ? this.headers[t4 - 1] = Buffer.concat([this.headers[t4 - 1], A]) : this.headers.push(A), this.trackHeader(A.length);
    }
    onHeaderValue(A) {
      let t4 = this.headers.length;
      (t4 & 1) === 1 ? (this.headers.push(A), t4 += 1) : this.headers[t4 - 1] = Buffer.concat([this.headers[t4 - 1], A]);
      const n3 = this.headers[t4 - 2];
      if (n3.length === 10) {
        const r = util$i.bufferToLowerCasedHeaderName(n3);
        r === "keep-alive" ? this.keepAlive += A.toString() : r === "connection" && (this.connection += A.toString());
      } else
        n3.length === 14 && util$i.bufferToLowerCasedHeaderName(n3) === "content-length" && (this.contentLength += A.toString());
      this.trackHeader(A.length);
    }
    trackHeader(A) {
      this.headersSize += A, this.headersSize >= this.headersMaxSize && util$i.destroy(this.socket, new HeadersOverflowError);
    }
    onUpgrade(A) {
      const { upgrade: t4, client: n3, socket: r, headers: s3, statusCode: i4 } = this;
      assert$a(t4);
      const E4 = n3[kQueue$3][n3[kRunningIdx$2]];
      assert$a(E4), assert$a(!r.destroyed), assert$a(r === n3[kSocket$1]), assert$a(!this.paused), assert$a(E4.upgrade || E4.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, r.unshift(A), r[kParser].destroy(), r[kParser] = null, r[kClient$3] = null, r[kError$2] = null, removeAllListeners(r), n3[kSocket$1] = null, n3[kHTTPContext$1] = null, n3[kQueue$3][n3[kRunningIdx$2]++] = null, n3.emit("disconnect", n3[kUrl$4], [n3], new InformationalError$2("upgrade"));
      try {
        E4.onUpgrade(i4, s3, r);
      } catch (Q) {
        util$i.destroy(r, Q);
      }
      n3[kResume$3]();
    }
    onHeadersComplete(A, t4, n3) {
      const { client: r, socket: s3, headers: i4, statusText: E4 } = this;
      if (s3.destroyed)
        return -1;
      const Q = r[kQueue$3][r[kRunningIdx$2]];
      if (!Q)
        return -1;
      if (assert$a(!this.upgrade), assert$a(this.statusCode < 200), A === 100)
        return util$i.destroy(s3, new SocketError$3("bad response", util$i.getSocketInfo(s3))), -1;
      if (t4 && !Q.upgrade)
        return util$i.destroy(s3, new SocketError$3("bad upgrade", util$i.getSocketInfo(s3))), -1;
      if (assert$a.strictEqual(this.timeoutType, TIMEOUT_HEADERS), this.statusCode = A, this.shouldKeepAlive = n3 || Q.method === "HEAD" && !s3[kReset$1] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
        const I = Q.bodyTimeout != null ? Q.bodyTimeout : r[kBodyTimeout$1];
        this.setTimeout(I, TIMEOUT_BODY);
      } else
        this.timeout && this.timeout.refresh && this.timeout.refresh();
      if (Q.method === "CONNECT")
        return assert$a(r[kRunning$5] === 1), this.upgrade = true, 2;
      if (t4)
        return assert$a(r[kRunning$5] === 1), this.upgrade = true, 2;
      if (assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && r[kPipelining$1]) {
        const I = this.keepAlive ? util$i.parseKeepAliveTimeout(this.keepAlive) : null;
        if (I != null) {
          const a3 = Math.min(I - r[kKeepAliveTimeoutThreshold$1], r[kKeepAliveMaxTimeout$1]);
          a3 <= 0 ? s3[kReset$1] = true : r[kKeepAliveTimeoutValue$1] = a3;
        } else
          r[kKeepAliveTimeoutValue$1] = r[kKeepAliveDefaultTimeout$1];
      } else
        s3[kReset$1] = true;
      const C = Q.onHeaders(A, i4, this.resume, E4) === false;
      return Q.aborted ? -1 : Q.method === "HEAD" || A < 200 ? 1 : (s3[kBlocking] && (s3[kBlocking] = false, r[kResume$3]()), C ? constants$2.ERROR.PAUSED : 0);
    }
    onBody(A) {
      const { client: t4, socket: n3, statusCode: r, maxResponseSize: s3 } = this;
      if (n3.destroyed)
        return -1;
      const i4 = t4[kQueue$3][t4[kRunningIdx$2]];
      if (assert$a(i4), assert$a.strictEqual(this.timeoutType, TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), assert$a(r >= 200), s3 > -1 && this.bytesRead + A.length > s3)
        return util$i.destroy(n3, new ResponseExceededMaxSizeError), -1;
      if (this.bytesRead += A.length, i4.onData(A) === false)
        return constants$2.ERROR.PAUSED;
    }
    onMessageComplete() {
      const { client: A, socket: t4, statusCode: n3, upgrade: r, headers: s3, contentLength: i4, bytesRead: E4, shouldKeepAlive: Q } = this;
      if (t4.destroyed && (!n3 || Q))
        return -1;
      if (r)
        return;
      const C = A[kQueue$3][A[kRunningIdx$2]];
      if (assert$a(C), assert$a(n3 >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", assert$a(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, !(n3 < 200)) {
        if (C.method !== "HEAD" && i4 && E4 !== parseInt(i4, 10))
          return util$i.destroy(t4, new ResponseContentLengthMismatchError), -1;
        if (C.onComplete(s3), A[kQueue$3][A[kRunningIdx$2]++] = null, t4[kWriting])
          return assert$a.strictEqual(A[kRunning$5], 0), util$i.destroy(t4, new InformationalError$2("reset")), constants$2.ERROR.PAUSED;
        if (Q) {
          if (t4[kReset$1] && A[kRunning$5] === 0)
            return util$i.destroy(t4, new InformationalError$2("reset")), constants$2.ERROR.PAUSED;
          A[kPipelining$1] == null || A[kPipelining$1] === 1 ? setImmediate(() => A[kResume$3]()) : A[kResume$3]();
        } else
          return util$i.destroy(t4, new InformationalError$2("reset")), constants$2.ERROR.PAUSED;
      }
    }
  };
  o4(st, "Parser");
  var Parser = st;
  o4(onParserTimeout, "onParserTimeout");
  o4(connectH1$1, "connectH1$1");
  o4(resumeH1, "resumeH1");
  o4(shouldSendContentLength$1, "shouldSendContentLength$1");
  o4(writeH1, "writeH1");
  o4(writeStream$1, "writeStream$1");
  o4(writeBuffer, "writeBuffer");
  o4(writeBlob$1, "writeBlob$1");
  o4(writeIterable$1, "writeIterable$1");
  var ot = class ot2 {
    constructor({ abort: A, socket: t4, request: n3, contentLength: r, client: s3, expectsPayload: i4, header: E4 }) {
      this.socket = t4, this.request = n3, this.contentLength = r, this.client = s3, this.bytesWritten = 0, this.expectsPayload = i4, this.header = E4, this.abort = A, t4[kWriting] = true;
    }
    write(A) {
      const { socket: t4, request: n3, contentLength: r, client: s3, bytesWritten: i4, expectsPayload: E4, header: Q } = this;
      if (t4[kError$2])
        throw t4[kError$2];
      if (t4.destroyed)
        return false;
      const C = Buffer.byteLength(A);
      if (!C)
        return true;
      if (r !== null && i4 + C > r) {
        if (s3[kStrictContentLength$2])
          throw new RequestContentLengthMismatchError$1;
        process.emitWarning(new RequestContentLengthMismatchError$1);
      }
      t4.cork(), i4 === 0 && (E4 || (t4[kReset$1] = true), r === null ? t4.write(`${Q}transfer-encoding: chunked\r
`, "latin1") : t4.write(`${Q}content-length: ${r}\r
\r
`, "latin1")), r === null && t4.write(`\r
${C.toString(16)}\r
`, "latin1"), this.bytesWritten += C;
      const I = t4.write(A);
      return t4.uncork(), n3.onBodySent(A), I || t4[kParser].timeout && t4[kParser].timeoutType === TIMEOUT_HEADERS && t4[kParser].timeout.refresh && t4[kParser].timeout.refresh(), I;
    }
    end() {
      const { socket: A, contentLength: t4, client: n3, bytesWritten: r, expectsPayload: s3, header: i4, request: E4 } = this;
      if (E4.onRequestSent(), A[kWriting] = false, A[kError$2])
        throw A[kError$2];
      if (!A.destroyed) {
        if (r === 0 ? s3 ? A.write(`${i4}content-length: 0\r
\r
`, "latin1") : A.write(`${i4}\r
`, "latin1") : t4 === null && A.write(`\r
0\r
\r
`, "latin1"), t4 !== null && r !== t4) {
          if (n3[kStrictContentLength$2])
            throw new RequestContentLengthMismatchError$1;
          process.emitWarning(new RequestContentLengthMismatchError$1);
        }
        A[kParser].timeout && A[kParser].timeoutType === TIMEOUT_HEADERS && A[kParser].timeout.refresh && A[kParser].timeout.refresh(), n3[kResume$3]();
      }
    }
    destroy(A) {
      const { socket: t4, client: n3, abort: r } = this;
      t4[kWriting] = false, A && (assert$a(n3[kRunning$5] <= 1, "pipeline should only contain this request"), r(A));
    }
  };
  o4(ot, "AsyncWriter");
  var AsyncWriter = ot;
  var clientH1 = connectH1$1;
  var assert$9 = require$$0__default;
  var { pipeline: pipeline$1 } = Stream__default;
  var util$h = util$m;
  var { RequestContentLengthMismatchError, RequestAbortedError: RequestAbortedError$4, SocketError: SocketError$2, InformationalError: InformationalError$1 } = errors$1;
  var { kUrl: kUrl$3, kReset, kClient: kClient$2, kRunning: kRunning$4, kPending: kPending$3, kQueue: kQueue$2, kPendingIdx: kPendingIdx$1, kRunningIdx: kRunningIdx$1, kError: kError$1, kSocket, kStrictContentLength: kStrictContentLength$1, kOnError: kOnError$1, kMaxConcurrentStreams: kMaxConcurrentStreams$1, kHTTP2Session, kResume: kResume$2 } = symbols$4;
  var kOpenStreams = Symbol("open streams");
  var h2ExperimentalWarned = false;
  var http2;
  try {
    http2 = import.meta.require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
  o4(parseH2Headers, "parseH2Headers");
  o4(connectH2$1, "connectH2$1");
  o4(onHttp2SessionError, "onHttp2SessionError");
  o4(onHttp2FrameError, "onHttp2FrameError");
  o4(onHttp2SessionEnd, "onHttp2SessionEnd");
  o4(onHTTP2GoAway, "onHTTP2GoAway");
  o4(shouldSendContentLength, "shouldSendContentLength");
  o4(writeH2, "writeH2");
  o4(writeStream, "writeStream");
  o4(writeBlob, "writeBlob");
  o4(writeIterable, "writeIterable");
  var clientH2 = connectH2$1;
  var util$g = util$m;
  var { kBodyUsed } = symbols$4;
  var assert$8 = require$$0__default;
  var { InvalidArgumentError: InvalidArgumentError$f } = errors$1;
  var EE = require$$0__default$3;
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody$1 = Symbol("body");
  var it = class it2 {
    constructor(A) {
      this[kBody$1] = A, this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert$8(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = true, yield* this[kBody$1];
    }
  };
  o4(it, "BodyAsyncIterable");
  var BodyAsyncIterable = it;
  var RedirectHandler$1 = (Ue = class {
    constructor(A, t4, n3, r) {
      if (t4 != null && (!Number.isInteger(t4) || t4 < 0))
        throw new InvalidArgumentError$f("maxRedirections must be a positive number");
      util$g.validateHandler(r, n3.method, n3.upgrade), this.dispatch = A, this.location = null, this.abort = null, this.opts = { ...n3, maxRedirections: 0 }, this.maxRedirections = t4, this.handler = r, this.history = [], this.redirectionLimitReached = false, util$g.isStream(this.opts.body) ? (util$g.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
        assert$8(false);
      }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[kBodyUsed] = false, EE.prototype.on.call(this.opts.body, "data", function() {
        this[kBodyUsed] = true;
      }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new BodyAsyncIterable(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && util$g.isIterable(this.opts.body) && (this.opts.body = new BodyAsyncIterable(this.opts.body));
    }
    onConnect(A) {
      this.abort = A, this.handler.onConnect(A, { history: this.history });
    }
    onUpgrade(A, t4, n3) {
      this.handler.onUpgrade(A, t4, n3);
    }
    onError(A) {
      this.handler.onError(A);
    }
    onHeaders(A, t4, n3, r) {
      if (this.location = this.history.length >= this.maxRedirections || util$g.isDisturbed(this.opts.body) ? null : parseLocation(A, t4), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        this.request && this.request.abort(new Error("max redirects")), this.redirectionLimitReached = true, this.abort(new Error("max redirects"));
        return;
      }
      if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
        return this.handler.onHeaders(A, t4, n3, r);
      const { origin: s3, pathname: i4, search: E4 } = util$g.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), Q = E4 ? `${i4}${E4}` : i4;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, A === 303, this.opts.origin !== s3), this.opts.path = Q, this.opts.origin = s3, this.opts.maxRedirections = 0, this.opts.query = null, A === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
    }
    onData(A) {
      if (!this.location)
        return this.handler.onData(A);
    }
    onComplete(A) {
      this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(A);
    }
    onBodySent(A) {
      this.handler.onBodySent && this.handler.onBodySent(A);
    }
  }, o4(Ue, "RedirectHandler"), Ue);
  o4(parseLocation, "parseLocation");
  o4(shouldRemoveHeader, "shouldRemoveHeader");
  o4(cleanRequestHeaders, "cleanRequestHeaders");
  var redirectHandler = RedirectHandler$1;
  var RedirectHandler = redirectHandler;
  o4(createRedirectInterceptor$2, "createRedirectInterceptor$2");
  var redirectInterceptor = createRedirectInterceptor$2;
  var assert$7 = require$$0__default;
  var net = require$$4__default;
  var http = http__default;
  var util$f = util$m;
  var { channels } = diagnostics;
  var Request2 = request$2;
  var DispatcherBase$3 = dispatcherBase;
  var { InvalidArgumentError: InvalidArgumentError$e, InformationalError, ClientDestroyedError } = errors$1;
  var buildConnector$2 = connect$2;
  var { kUrl: kUrl$2, kServerName, kClient: kClient$1, kBusy: kBusy$1, kConnect, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$3, kQueue: kQueue$1, kConnected: kConnected$4, kConnecting, kNeedDrain: kNeedDrain$2, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$3, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume: kResume$1 } = symbols$4;
  var connectH1 = clientH1;
  var connectH2 = clientH2;
  var deprecatedInterceptorWarned = false;
  var kClosedResolve$1 = Symbol("kClosedResolve");
  o4(getPipelining, "getPipelining");
  var Client$3 = (be = class extends DispatcherBase$3 {
    constructor(A, { interceptors: t4, maxHeaderSize: n3, headersTimeout: r, socketTimeout: s3, requestTimeout: i4, connectTimeout: E4, bodyTimeout: Q, idleTimeout: C, keepAlive: I, keepAliveTimeout: a3, maxKeepAliveTimeout: f3, keepAliveMaxTimeout: h4, keepAliveTimeoutThreshold: L, socketPath: c3, pipelining: l3, tls: S, strictContentLength: k3, maxCachedSessions: w, maxRedirections: U, connect: M, maxRequestsPerClient: B, localAddress: D, maxResponseSize: G, autoSelectFamily: g3, autoSelectFamilyAttemptTimeout: d3, maxConcurrentStreams: F, allowH2: N } = {}) {
      if (super(), I !== undefined)
        throw new InvalidArgumentError$e("unsupported keepAlive, use pipelining=0 instead");
      if (s3 !== undefined)
        throw new InvalidArgumentError$e("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (i4 !== undefined)
        throw new InvalidArgumentError$e("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (C !== undefined)
        throw new InvalidArgumentError$e("unsupported idleTimeout, use keepAliveTimeout instead");
      if (f3 !== undefined)
        throw new InvalidArgumentError$e("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (n3 != null && !Number.isFinite(n3))
        throw new InvalidArgumentError$e("invalid maxHeaderSize");
      if (c3 != null && typeof c3 != "string")
        throw new InvalidArgumentError$e("invalid socketPath");
      if (E4 != null && (!Number.isFinite(E4) || E4 < 0))
        throw new InvalidArgumentError$e("invalid connectTimeout");
      if (a3 != null && (!Number.isFinite(a3) || a3 <= 0))
        throw new InvalidArgumentError$e("invalid keepAliveTimeout");
      if (h4 != null && (!Number.isFinite(h4) || h4 <= 0))
        throw new InvalidArgumentError$e("invalid keepAliveMaxTimeout");
      if (L != null && !Number.isFinite(L))
        throw new InvalidArgumentError$e("invalid keepAliveTimeoutThreshold");
      if (r != null && (!Number.isInteger(r) || r < 0))
        throw new InvalidArgumentError$e("headersTimeout must be a positive integer or zero");
      if (Q != null && (!Number.isInteger(Q) || Q < 0))
        throw new InvalidArgumentError$e("bodyTimeout must be a positive integer or zero");
      if (M != null && typeof M != "function" && typeof M != "object")
        throw new InvalidArgumentError$e("connect must be a function or an object");
      if (U != null && (!Number.isInteger(U) || U < 0))
        throw new InvalidArgumentError$e("maxRedirections must be a positive number");
      if (B != null && (!Number.isInteger(B) || B < 0))
        throw new InvalidArgumentError$e("maxRequestsPerClient must be a positive number");
      if (D != null && (typeof D != "string" || net.isIP(D) === 0))
        throw new InvalidArgumentError$e("localAddress must be valid string IP address");
      if (G != null && (!Number.isInteger(G) || G < -1))
        throw new InvalidArgumentError$e("maxResponseSize must be a positive number");
      if (d3 != null && (!Number.isInteger(d3) || d3 < -1))
        throw new InvalidArgumentError$e("autoSelectFamilyAttemptTimeout must be a positive number");
      if (N != null && typeof N != "boolean")
        throw new InvalidArgumentError$e("allowH2 must be a valid boolean value");
      if (F != null && (typeof F != "number" || F < 1))
        throw new InvalidArgumentError$e("maxConcurrentStreams must be a positive integer, greater than 0");
      typeof M != "function" && (M = buildConnector$2({ ...S, maxCachedSessions: w, allowH2: N, socketPath: c3, timeout: E4, ...util$f.nodeHasAutoSelectFamily && g3 ? { autoSelectFamily: g3, autoSelectFamilyAttemptTimeout: d3 } : undefined, ...M })), t4?.Client && Array.isArray(t4.Client) ? (this[kInterceptors$3] = t4.Client, deprecatedInterceptorWarned || (deprecatedInterceptorWarned = true, process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", { code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" }))) : this[kInterceptors$3] = [createRedirectInterceptor$1({ maxRedirections: U })], this[kUrl$2] = util$f.parseOrigin(A), this[kConnector] = M, this[kPipelining] = l3 ?? 1, this[kMaxHeadersSize] = n3 || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = a3 ?? 4000, this[kKeepAliveMaxTimeout] = h4 ?? 600000, this[kKeepAliveTimeoutThreshold] = L ?? 1000, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = D ?? null, this[kResuming] = 0, this[kNeedDrain$2] = 0, this[kHostHeader] = `host: ${this[kUrl$2].hostname}${this[kUrl$2].port ? `:${this[kUrl$2].port}` : ""}\r
`, this[kBodyTimeout] = Q ?? 300000, this[kHeadersTimeout] = r ?? 300000, this[kStrictContentLength] = k3 ?? true, this[kMaxRedirections$1] = U, this[kMaxRequests] = B, this[kClosedResolve$1] = null, this[kMaxResponseSize] = G > -1 ? G : -1, this[kMaxConcurrentStreams] = F ?? 100, this[kHTTPContext] = null, this[kQueue$1] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0, this[kResume$1] = (u) => resume(this, u), this[kOnError] = (u) => onError(this, u);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(A) {
      this[kPipelining] = A, this[kResume$1](true);
    }
    get [kPending$2]() {
      return this[kQueue$1].length - this[kPendingIdx];
    }
    get [kRunning$3]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize$3]() {
      return this[kQueue$1].length - this[kRunningIdx];
    }
    get [kConnected$4]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy$1]() {
      return !!(this[kHTTPContext]?.busy(null) || this[kSize$3] >= (getPipelining(this) || 1) || this[kPending$2] > 0);
    }
    [kConnect](A) {
      connect$1(this), this.once("connect", A);
    }
    [kDispatch$2](A, t4) {
      const n3 = A.origin || this[kUrl$2].origin, r = new Request2(n3, A, t4);
      return this[kQueue$1].push(r), this[kResuming] || (util$f.bodyLength(r.body) == null && util$f.isIterable(r.body) ? (this[kResuming] = 1, queueMicrotask(() => resume(this))) : this[kResume$1](true)), this[kResuming] && this[kNeedDrain$2] !== 2 && this[kBusy$1] && (this[kNeedDrain$2] = 2), this[kNeedDrain$2] < 2;
    }
    async[kClose$5]() {
      return new Promise((A) => {
        this[kSize$3] ? this[kClosedResolve$1] = A : A(null);
      });
    }
    async[kDestroy$3](A) {
      return new Promise((t4) => {
        const n3 = this[kQueue$1].splice(this[kPendingIdx]);
        for (let s3 = 0;s3 < n3.length; s3++) {
          const i4 = n3[s3];
          util$f.errorRequest(this, i4, A);
        }
        const r = o4(() => {
          this[kClosedResolve$1] && (this[kClosedResolve$1](), this[kClosedResolve$1] = null), t4(null);
        }, "callback");
        this[kHTTPContext] ? (this[kHTTPContext].destroy(A, r), this[kHTTPContext] = null) : queueMicrotask(r), this[kResume$1]();
      });
    }
  }, o4(be, "Client"), be);
  var createRedirectInterceptor$1 = redirectInterceptor;
  o4(onError, "onError");
  o4(connect$1, "connect$1");
  o4(emitDrain, "emitDrain");
  o4(resume, "resume");
  o4(_resume, "_resume");
  var client = Client$3;
  var kSize$2 = 2048;
  var kMask = kSize$2 - 1;
  var Qt = class Qt2 {
    constructor() {
      this.bottom = 0, this.top = 0, this.list = new Array(kSize$2), this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(A) {
      this.list[this.top] = A, this.top = this.top + 1 & kMask;
    }
    shift() {
      const A = this.list[this.bottom];
      return A === undefined ? null : (this.list[this.bottom] = undefined, this.bottom = this.bottom + 1 & kMask, A);
    }
  };
  o4(Qt, "FixedCircularBuffer");
  var FixedCircularBuffer = Qt;
  var fixedQueue = (me = class {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(A) {
      this.head.isFull() && (this.head = this.head.next = new FixedCircularBuffer), this.head.push(A);
    }
    shift() {
      const A = this.tail, t4 = A.shift();
      return A.isEmpty() && A.next !== null && (this.tail = A.next), t4;
    }
  }, o4(me, "FixedQueue"), me);
  var { kFree: kFree$1, kConnected: kConnected$3, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$1 } = symbols$4;
  var kPool = Symbol("pool");
  var PoolStats$1 = (Le = class {
    constructor(A) {
      this[kPool] = A;
    }
    get connected() {
      return this[kPool][kConnected$3];
    }
    get free() {
      return this[kPool][kFree$1];
    }
    get pending() {
      return this[kPool][kPending$1];
    }
    get queued() {
      return this[kPool][kQueued$1];
    }
    get running() {
      return this[kPool][kRunning$2];
    }
    get size() {
      return this[kPool][kSize$1];
    }
  }, o4(Le, "PoolStats"), Le);
  var poolStats = PoolStats$1;
  var DispatcherBase$2 = dispatcherBase;
  var FixedQueue = fixedQueue;
  var { kConnected: kConnected$2, kSize, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$1, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = symbols$4;
  var PoolStats = poolStats;
  var kClients$2 = Symbol("clients");
  var kNeedDrain$1 = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain$1 = Symbol("onDrain");
  var kOnConnect$1 = Symbol("onConnect");
  var kOnDisconnect$1 = Symbol("onDisconnect");
  var kOnConnectionError$1 = Symbol("onConnectionError");
  var kGetDispatcher$1 = Symbol("get dispatcher");
  var kAddClient$1 = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");
  var PoolBase$1 = (Me = class extends DispatcherBase$2 {
    constructor() {
      super(), this[kQueue] = new FixedQueue, this[kClients$2] = [], this[kQueued] = 0;
      const A = this;
      this[kOnDrain$1] = o4(function(n3, r) {
        const s3 = A[kQueue];
        let i4 = false;
        for (;!i4; ) {
          const E4 = s3.shift();
          if (!E4)
            break;
          A[kQueued]--, i4 = !this.dispatch(E4.opts, E4.handler);
        }
        this[kNeedDrain$1] = i4, !this[kNeedDrain$1] && A[kNeedDrain$1] && (A[kNeedDrain$1] = false, A.emit("drain", n3, [A, ...r])), A[kClosedResolve] && s3.isEmpty() && Promise.all(A[kClients$2].map((E4) => E4.close())).then(A[kClosedResolve]);
      }, "onDrain"), this[kOnConnect$1] = (t4, n3) => {
        A.emit("connect", t4, [A, ...n3]);
      }, this[kOnDisconnect$1] = (t4, n3, r) => {
        A.emit("disconnect", t4, [A, ...n3], r);
      }, this[kOnConnectionError$1] = (t4, n3, r) => {
        A.emit("connectionError", t4, [A, ...n3], r);
      }, this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain$1];
    }
    get [kConnected$2]() {
      return this[kClients$2].filter((A) => A[kConnected$2]).length;
    }
    get [kFree]() {
      return this[kClients$2].filter((A) => A[kConnected$2] && !A[kNeedDrain$1]).length;
    }
    get [kPending]() {
      let A = this[kQueued];
      for (const { [kPending]: t4 } of this[kClients$2])
        A += t4;
      return A;
    }
    get [kRunning$1]() {
      let A = 0;
      for (const { [kRunning$1]: t4 } of this[kClients$2])
        A += t4;
      return A;
    }
    get [kSize]() {
      let A = this[kQueued];
      for (const { [kSize]: t4 } of this[kClients$2])
        A += t4;
      return A;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose$4]() {
      return this[kQueue].isEmpty() ? Promise.all(this[kClients$2].map((A) => A.close())) : new Promise((A) => {
        this[kClosedResolve] = A;
      });
    }
    async[kDestroy$2](A) {
      for (;; ) {
        const t4 = this[kQueue].shift();
        if (!t4)
          break;
        t4.handler.onError(A);
      }
      return Promise.all(this[kClients$2].map((t4) => t4.destroy(A)));
    }
    [kDispatch$1](A, t4) {
      const n3 = this[kGetDispatcher$1]();
      return n3 ? n3.dispatch(A, t4) || (n3[kNeedDrain$1] = true, this[kNeedDrain$1] = !this[kGetDispatcher$1]()) : (this[kNeedDrain$1] = true, this[kQueue].push({ opts: A, handler: t4 }), this[kQueued]++), !this[kNeedDrain$1];
    }
    [kAddClient$1](A) {
      return A.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]), this[kClients$2].push(A), this[kNeedDrain$1] && queueMicrotask(() => {
        this[kNeedDrain$1] && this[kOnDrain$1](A[kUrl$1], [this, A]);
      }), this;
    }
    [kRemoveClient](A) {
      A.close(() => {
        const t4 = this[kClients$2].indexOf(A);
        t4 !== -1 && this[kClients$2].splice(t4, 1);
      }), this[kNeedDrain$1] = this[kClients$2].some((t4) => !t4[kNeedDrain$1] && t4.closed !== true && t4.destroyed !== true);
    }
  }, o4(Me, "PoolBase"), Me);
  var poolBase = { PoolBase: PoolBase$1, kClients: kClients$2, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kRemoveClient, kGetDispatcher: kGetDispatcher$1 };
  var { PoolBase, kClients: kClients$1, kNeedDrain, kAddClient, kGetDispatcher } = poolBase;
  var Client$2 = client;
  var { InvalidArgumentError: InvalidArgumentError$d } = errors$1;
  var util$e = util$m;
  var { kUrl, kInterceptors: kInterceptors$2 } = symbols$4;
  var buildConnector$1 = connect$2;
  var kOptions$1 = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory$1 = Symbol("factory");
  o4(defaultFactory$2, "defaultFactory$2");
  var Pool$3 = (Ye = class extends PoolBase {
    constructor(A, { connections: t4, factory: n3 = defaultFactory$2, connect: r, connectTimeout: s3, tls: i4, maxCachedSessions: E4, socketPath: Q, autoSelectFamily: C, autoSelectFamilyAttemptTimeout: I, allowH2: a3, ...f3 } = {}) {
      if (super(), t4 != null && (!Number.isFinite(t4) || t4 < 0))
        throw new InvalidArgumentError$d("invalid connections");
      if (typeof n3 != "function")
        throw new InvalidArgumentError$d("factory must be a function.");
      if (r != null && typeof r != "function" && typeof r != "object")
        throw new InvalidArgumentError$d("connect must be a function or an object");
      typeof r != "function" && (r = buildConnector$1({ ...i4, maxCachedSessions: E4, allowH2: a3, socketPath: Q, timeout: s3, ...util$e.nodeHasAutoSelectFamily && C ? { autoSelectFamily: C, autoSelectFamilyAttemptTimeout: I } : undefined, ...r })), this[kInterceptors$2] = f3.interceptors?.Pool && Array.isArray(f3.interceptors.Pool) ? f3.interceptors.Pool : [], this[kConnections] = t4 || null, this[kUrl] = util$e.parseOrigin(A), this[kOptions$1] = { ...util$e.deepClone(f3), connect: r, allowH2: a3 }, this[kOptions$1].interceptors = f3.interceptors ? { ...f3.interceptors } : undefined, this[kFactory$1] = n3;
    }
    [kGetDispatcher]() {
      for (const A of this[kClients$1])
        if (!A[kNeedDrain])
          return A;
      if (!this[kConnections] || this[kClients$1].length < this[kConnections]) {
        const A = this[kFactory$1](this[kUrl], this[kOptions$1]);
        return this[kAddClient](A), A;
      }
    }
  }, o4(Ye, "Pool"), Ye);
  var pool = Pool$3;
  var { InvalidArgumentError: InvalidArgumentError$c } = errors$1;
  var { kClients, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = symbols$4;
  var DispatcherBase$1 = dispatcherBase;
  var Pool$2 = pool;
  var Client$1 = client;
  var util$d = util$m;
  var createRedirectInterceptor = redirectInterceptor;
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  o4(defaultFactory$1, "defaultFactory$1");
  var Agent$3 = (Je = class extends DispatcherBase$1 {
    constructor({ factory: A = defaultFactory$1, maxRedirections: t4 = 0, connect: n3, ...r } = {}) {
      if (super(), typeof A != "function")
        throw new InvalidArgumentError$c("factory must be a function.");
      if (n3 != null && typeof n3 != "function" && typeof n3 != "object")
        throw new InvalidArgumentError$c("connect must be a function or an object");
      if (!Number.isInteger(t4) || t4 < 0)
        throw new InvalidArgumentError$c("maxRedirections must be a positive number");
      n3 && typeof n3 != "function" && (n3 = { ...n3 }), this[kInterceptors$1] = r.interceptors?.Agent && Array.isArray(r.interceptors.Agent) ? r.interceptors.Agent : [createRedirectInterceptor({ maxRedirections: t4 })], this[kOptions] = { ...util$d.deepClone(r), connect: n3 }, this[kOptions].interceptors = r.interceptors ? { ...r.interceptors } : undefined, this[kMaxRedirections] = t4, this[kFactory] = A, this[kClients] = new Map, this[kOnDrain] = (s3, i4) => {
        this.emit("drain", s3, [this, ...i4]);
      }, this[kOnConnect] = (s3, i4) => {
        this.emit("connect", s3, [this, ...i4]);
      }, this[kOnDisconnect] = (s3, i4, E4) => {
        this.emit("disconnect", s3, [this, ...i4], E4);
      }, this[kOnConnectionError] = (s3, i4, E4) => {
        this.emit("connectionError", s3, [this, ...i4], E4);
      };
    }
    get [kRunning]() {
      let A = 0;
      for (const t4 of this[kClients].values())
        A += t4[kRunning];
      return A;
    }
    [kDispatch](A, t4) {
      let n3;
      if (A.origin && (typeof A.origin == "string" || A.origin instanceof URL))
        n3 = String(A.origin);
      else
        throw new InvalidArgumentError$c("opts.origin must be a non-empty string or URL.");
      let r = this[kClients].get(n3);
      return r || (r = this[kFactory](A.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].set(n3, r)), r.dispatch(A, t4);
    }
    async[kClose$3]() {
      const A = [];
      for (const t4 of this[kClients].values())
        A.push(t4.close());
      this[kClients].clear(), await Promise.all(A);
    }
    async[kDestroy$1](A) {
      const t4 = [];
      for (const n3 of this[kClients].values())
        t4.push(n3.destroy(A));
      this[kClients].clear(), await Promise.all(t4);
    }
  }, o4(Je, "Agent"), Je);
  var agent = Agent$3;
  var { kProxy, kClose: kClose$2, kDestroy, kInterceptors } = symbols$4;
  var { URL: URL$1 } = require$$1__default;
  var Agent$2 = agent;
  var Pool$1 = pool;
  var DispatcherBase = dispatcherBase;
  var { InvalidArgumentError: InvalidArgumentError$b, RequestAbortedError: RequestAbortedError$3, SecureProxyConnectionError } = errors$1;
  var buildConnector = connect$2;
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");
  o4(defaultProtocolPort, "defaultProtocolPort");
  o4(defaultFactory, "defaultFactory");
  var ProxyAgent$1 = (Ge = class extends DispatcherBase {
    constructor(t4) {
      super();
      CA(this, Oe);
      if (!t4 || typeof t4 == "object" && !(t4 instanceof URL$1) && !t4.uri)
        throw new InvalidArgumentError$b("Proxy uri is mandatory");
      const { clientFactory: n3 = defaultFactory } = t4;
      if (typeof n3 != "function")
        throw new InvalidArgumentError$b("Proxy opts.clientFactory must be a function.");
      const r = kA(this, Oe, Rt).call(this, t4), { href: s3, origin: i4, port: E4, protocol: Q, username: C, password: I, hostname: a3 } = r;
      if (this[kProxy] = { uri: s3, protocol: Q }, this[kInterceptors] = t4.interceptors?.ProxyAgent && Array.isArray(t4.interceptors.ProxyAgent) ? t4.interceptors.ProxyAgent : [], this[kRequestTls] = t4.requestTls, this[kProxyTls] = t4.proxyTls, this[kProxyHeaders] = t4.headers || {}, t4.auth && t4.token)
        throw new InvalidArgumentError$b("opts.auth cannot be used in combination with opts.token");
      t4.auth ? this[kProxyHeaders]["proxy-authorization"] = `Basic ${t4.auth}` : t4.token ? this[kProxyHeaders]["proxy-authorization"] = t4.token : C && I && (this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(C)}:${decodeURIComponent(I)}`).toString("base64")}`);
      const f3 = buildConnector({ ...t4.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...t4.requestTls }), this[kClient] = n3(r, { connect: f3 }), this[kAgent] = new Agent$2({ ...t4, connect: async (h4, L) => {
        let c3 = h4.host;
        h4.port || (c3 += `:${defaultProtocolPort(h4.protocol)}`);
        try {
          const { socket: l3, statusCode: S } = await this[kClient].connect({ origin: i4, port: E4, path: c3, signal: h4.signal, headers: { ...this[kProxyHeaders], host: h4.host }, servername: this[kProxyTls]?.servername || a3 });
          if (S !== 200 && (l3.on("error", () => {
          }).destroy(), L(new RequestAbortedError$3(`Proxy response (${S}) !== 200 when HTTP Tunneling`))), h4.protocol !== "https:") {
            L(null, l3);
            return;
          }
          let k3;
          this[kRequestTls] ? k3 = this[kRequestTls].servername : k3 = h4.servername, this[kConnectEndpoint]({ ...h4, servername: k3, httpSocket: l3 }, L);
        } catch (l3) {
          l3.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? L(new SecureProxyConnectionError(l3)) : L(l3);
        }
      } });
    }
    dispatch(t4, n3) {
      const r = buildHeaders(t4.headers);
      if (throwIfProxyAuthIsSent(r), r && !("host" in r) && !("Host" in r)) {
        const { host: s3 } = new URL$1(t4.origin);
        r.host = s3;
      }
      return this[kAgent].dispatch({ ...t4, headers: r }, n3);
    }
    async[kClose$2]() {
      await this[kAgent].close(), await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy(), await this[kClient].destroy();
    }
  }, Oe = new WeakSet, Rt = o4(function(t4) {
    return typeof t4 == "string" ? new URL$1(t4) : t4 instanceof URL$1 ? t4 : new URL$1(t4.uri);
  }, "#getUrl"), o4(Ge, "ProxyAgent"), Ge);
  o4(buildHeaders, "buildHeaders");
  o4(throwIfProxyAuthIsSent, "throwIfProxyAuthIsSent");
  var proxyAgent = ProxyAgent$1;
  var api$1 = {};
  var apiRequest = { exports: {} };
  var assert$6 = require$$0__default;
  var { Readable: Readable$2 } = Stream__default;
  var { RequestAbortedError: RequestAbortedError$2, NotSupportedError, InvalidArgumentError: InvalidArgumentError$a, AbortError } = errors$1;
  var util$c = util$m;
  var { ReadableStreamFrom } = util$m;
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("kAbort");
  var kContentType = Symbol("kContentType");
  var kContentLength$1 = Symbol("kContentLength");
  var noop = o4(() => {
  }, "noop");
  var Et = class Et2 extends Readable$2 {
    constructor({ resume: A, abort: t4, contentType: n3 = "", contentLength: r, highWaterMark: s3 = 64 * 1024 }) {
      super({ autoDestroy: true, read: A, highWaterMark: s3 }), this._readableState.dataEmitted = false, this[kAbort] = t4, this[kConsume] = null, this[kBody] = null, this[kContentType] = n3, this[kContentLength$1] = r, this[kReading] = false;
    }
    destroy(A) {
      return !A && !this._readableState.endEmitted && (A = new RequestAbortedError$2), A && this[kAbort](), super.destroy(A);
    }
    _destroy(A, t4) {
      queueMicrotask(() => {
        t4(A);
      });
    }
    on(A, ...t4) {
      return (A === "data" || A === "readable") && (this[kReading] = true), super.on(A, ...t4);
    }
    addListener(A, ...t4) {
      return this.on(A, ...t4);
    }
    off(A, ...t4) {
      const n3 = super.off(A, ...t4);
      return (A === "data" || A === "readable") && (this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), n3;
    }
    removeListener(A, ...t4) {
      return this.off(A, ...t4);
    }
    push(A) {
      return this[kConsume] && A !== null ? (consumePush(this[kConsume], A), this[kReading] ? super.push(A) : true) : super.push(A);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util$c.isDisturbed(this);
    }
    get body() {
      return this[kBody] || (this[kBody] = ReadableStreamFrom(this), this[kConsume] && (this[kBody].getReader(), assert$6(this[kBody].locked))), this[kBody];
    }
    async dump(A) {
      let t4 = Number.isFinite(A?.limit) ? A.limit : 131072;
      const n3 = A?.signal;
      if (n3 != null && (typeof n3 != "object" || !("aborted" in n3)))
        throw new InvalidArgumentError$a("signal must be an AbortSignal");
      return n3?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((r, s3) => {
        this[kContentLength$1] > t4 && this.destroy(new AbortError);
        const i4 = o4(() => {
          this.destroy(n3.reason ?? new AbortError);
        }, "onAbort");
        n3?.addEventListener("abort", i4), this.on("close", function() {
          n3?.removeEventListener("abort", i4), n3?.aborted ? s3(n3.reason ?? new AbortError) : r(null);
        }).on("error", noop).on("data", function(E4) {
          t4 -= E4.length, t4 <= 0 && this.destroy();
        }).resume();
      });
    }
  };
  o4(Et, "BodyReadable");
  var BodyReadable = Et;
  o4(isLocked, "isLocked");
  o4(isUnusable, "isUnusable");
  o4(consume, "consume");
  o4(consumeStart, "consumeStart");
  o4(chunksDecode$1, "chunksDecode$1");
  o4(consumeEnd, "consumeEnd");
  o4(consumePush, "consumePush");
  o4(consumeFinish, "consumeFinish");
  var readable = { Readable: BodyReadable, chunksDecode: chunksDecode$1 };
  var assert$5 = require$$0__default;
  var { ResponseStatusCodeError } = errors$1;
  var { chunksDecode } = readable;
  var CHUNK_LIMIT = 128 * 1024;
  o4(getResolveErrorBodyCallback$2, "getResolveErrorBodyCallback$2");
  var isContentTypeApplicationJson = o4((e3) => e3.length > 15 && e3[11] === "/" && e3[0] === "a" && e3[1] === "p" && e3[2] === "p" && e3[3] === "l" && e3[4] === "i" && e3[5] === "c" && e3[6] === "a" && e3[7] === "t" && e3[8] === "i" && e3[9] === "o" && e3[10] === "n" && e3[12] === "j" && e3[13] === "s" && e3[14] === "o" && e3[15] === "n", "isContentTypeApplicationJson");
  var isContentTypeText = o4((e3) => e3.length > 4 && e3[4] === "/" && e3[0] === "t" && e3[1] === "e" && e3[2] === "x" && e3[3] === "t", "isContentTypeText");
  var util$b = { getResolveErrorBodyCallback: getResolveErrorBodyCallback$2, isContentTypeApplicationJson, isContentTypeText };
  var { addAbortListener } = util$m;
  var { RequestAbortedError: RequestAbortedError$1 } = errors$1;
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  o4(abort, "abort");
  o4(addSignal$5, "addSignal$5");
  o4(removeSignal$5, "removeSignal$5");
  var abortSignal = { addSignal: addSignal$5, removeSignal: removeSignal$5 };
  var assert$4 = require$$0__default;
  var { Readable: Readable$1 } = readable;
  var { InvalidArgumentError: InvalidArgumentError$9 } = errors$1;
  var util$a = util$m;
  var { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = util$b;
  var { AsyncResource: AsyncResource$4 } = require$$5__default$1;
  var { addSignal: addSignal$4, removeSignal: removeSignal$4 } = abortSignal;
  var gt = class gt2 extends AsyncResource$4 {
    constructor(A, t4) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$9("invalid opts");
      const { signal: n3, method: r, opaque: s3, body: i4, onInfo: E4, responseHeaders: Q, throwOnError: C, highWaterMark: I } = A;
      try {
        if (typeof t4 != "function")
          throw new InvalidArgumentError$9("invalid callback");
        if (I && (typeof I != "number" || I < 0))
          throw new InvalidArgumentError$9("invalid highWaterMark");
        if (n3 && typeof n3.on != "function" && typeof n3.addEventListener != "function")
          throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
        if (r === "CONNECT")
          throw new InvalidArgumentError$9("invalid method");
        if (E4 && typeof E4 != "function")
          throw new InvalidArgumentError$9("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (a3) {
        throw util$a.isStream(i4) && util$a.destroy(i4.on("error", util$a.nop), a3), a3;
      }
      this.responseHeaders = Q || null, this.opaque = s3 || null, this.callback = t4, this.res = null, this.abort = null, this.body = i4, this.trailers = {}, this.context = null, this.onInfo = E4 || null, this.throwOnError = C, this.highWaterMark = I, util$a.isStream(i4) && i4.on("error", (a3) => {
        this.onError(a3);
      }), addSignal$4(this, n3);
    }
    onConnect(A, t4) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$4(this.callback), this.abort = A, this.context = t4;
    }
    onHeaders(A, t4, n3, r) {
      const { callback: s3, opaque: i4, abort: E4, context: Q, responseHeaders: C, highWaterMark: I } = this, a3 = C === "raw" ? util$a.parseRawHeaders(t4) : util$a.parseHeaders(t4);
      if (A < 200) {
        this.onInfo && this.onInfo({ statusCode: A, headers: a3 });
        return;
      }
      const f3 = C === "raw" ? util$a.parseHeaders(t4) : a3, h4 = f3["content-type"], L = f3["content-length"], c3 = new Readable$1({ resume: n3, abort: E4, contentType: h4, contentLength: L, highWaterMark: I });
      this.callback = null, this.res = c3, s3 !== null && (this.throwOnError && A >= 400 ? this.runInAsyncScope(getResolveErrorBodyCallback$1, null, { callback: s3, body: c3, contentType: h4, statusCode: A, statusMessage: r, headers: a3 }) : this.runInAsyncScope(s3, null, null, { statusCode: A, headers: a3, trailers: this.trailers, opaque: i4, body: c3, context: Q }));
    }
    onData(A) {
      const { res: t4 } = this;
      return t4.push(A);
    }
    onComplete(A) {
      const { res: t4 } = this;
      removeSignal$4(this), util$a.parseHeaders(A, this.trailers), t4.push(null);
    }
    onError(A) {
      const { res: t4, callback: n3, body: r, opaque: s3 } = this;
      removeSignal$4(this), n3 && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(n3, null, A, { opaque: s3 });
      })), t4 && (this.res = null, queueMicrotask(() => {
        util$a.destroy(t4, A);
      })), r && (this.body = null, util$a.destroy(r, A));
    }
  };
  o4(gt, "RequestHandler");
  var RequestHandler = gt;
  o4(request$1, "request$1"), apiRequest.exports = request$1, apiRequest.exports.RequestHandler = RequestHandler;
  var apiRequestExports = apiRequest.exports;
  var assert$3 = require$$0__default;
  var { finished, PassThrough: PassThrough$1 } = Stream__default;
  var { InvalidArgumentError: InvalidArgumentError$8, InvalidReturnValueError: InvalidReturnValueError$1 } = errors$1;
  var util$9 = util$m;
  var { getResolveErrorBodyCallback } = util$b;
  var { AsyncResource: AsyncResource$3 } = require$$5__default$1;
  var { addSignal: addSignal$3, removeSignal: removeSignal$3 } = abortSignal;
  var Bt = class Bt2 extends AsyncResource$3 {
    constructor(A, t4, n3) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$8("invalid opts");
      const { signal: r, method: s3, opaque: i4, body: E4, onInfo: Q, responseHeaders: C, throwOnError: I } = A;
      try {
        if (typeof n3 != "function")
          throw new InvalidArgumentError$8("invalid callback");
        if (typeof t4 != "function")
          throw new InvalidArgumentError$8("invalid factory");
        if (r && typeof r.on != "function" && typeof r.addEventListener != "function")
          throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
        if (s3 === "CONNECT")
          throw new InvalidArgumentError$8("invalid method");
        if (Q && typeof Q != "function")
          throw new InvalidArgumentError$8("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (a3) {
        throw util$9.isStream(E4) && util$9.destroy(E4.on("error", util$9.nop), a3), a3;
      }
      this.responseHeaders = C || null, this.opaque = i4 || null, this.factory = t4, this.callback = n3, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = E4, this.onInfo = Q || null, this.throwOnError = I || false, util$9.isStream(E4) && E4.on("error", (a3) => {
        this.onError(a3);
      }), addSignal$3(this, r);
    }
    onConnect(A, t4) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$3(this.callback), this.abort = A, this.context = t4;
    }
    onHeaders(A, t4, n3, r) {
      const { factory: s3, opaque: i4, context: E4, callback: Q, responseHeaders: C } = this, I = C === "raw" ? util$9.parseRawHeaders(t4) : util$9.parseHeaders(t4);
      if (A < 200) {
        this.onInfo && this.onInfo({ statusCode: A, headers: I });
        return;
      }
      this.factory = null;
      let a3;
      if (this.throwOnError && A >= 400) {
        const L = (C === "raw" ? util$9.parseHeaders(t4) : I)["content-type"];
        a3 = new PassThrough$1, this.callback = null, this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback: Q, body: a3, contentType: L, statusCode: A, statusMessage: r, headers: I });
      } else {
        if (s3 === null)
          return;
        if (a3 = this.runInAsyncScope(s3, null, { statusCode: A, headers: I, opaque: i4, context: E4 }), !a3 || typeof a3.write != "function" || typeof a3.end != "function" || typeof a3.on != "function")
          throw new InvalidReturnValueError$1("expected Writable");
        finished(a3, { readable: false }, (h4) => {
          const { callback: L, res: c3, opaque: l3, trailers: S, abort: k3 } = this;
          this.res = null, (h4 || !c3.readable) && util$9.destroy(c3, h4), this.callback = null, this.runInAsyncScope(L, null, h4 || null, { opaque: l3, trailers: S }), h4 && k3();
        });
      }
      return a3.on("drain", n3), this.res = a3, (a3.writableNeedDrain !== undefined ? a3.writableNeedDrain : a3._writableState?.needDrain) !== true;
    }
    onData(A) {
      const { res: t4 } = this;
      return t4 ? t4.write(A) : true;
    }
    onComplete(A) {
      const { res: t4 } = this;
      removeSignal$3(this), t4 && (this.trailers = util$9.parseHeaders(A), t4.end());
    }
    onError(A) {
      const { res: t4, callback: n3, opaque: r, body: s3 } = this;
      removeSignal$3(this), this.factory = null, t4 ? (this.res = null, util$9.destroy(t4, A)) : n3 && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(n3, null, A, { opaque: r });
      })), s3 && (this.body = null, util$9.destroy(s3, A));
    }
  };
  o4(Bt, "StreamHandler");
  var StreamHandler = Bt;
  o4(stream, "stream");
  var apiStream = stream;
  var { Readable, Duplex, PassThrough } = Stream__default;
  var { InvalidArgumentError: InvalidArgumentError$7, InvalidReturnValueError, RequestAbortedError } = errors$1;
  var util$8 = util$m;
  var { AsyncResource: AsyncResource$2 } = require$$5__default$1;
  var { addSignal: addSignal$2, removeSignal: removeSignal$2 } = abortSignal;
  var assert$2 = require$$0__default;
  var kResume = Symbol("resume");
  var Ct = class Ct2 extends Readable {
    constructor() {
      super({ autoDestroy: true }), this[kResume] = null;
    }
    _read() {
      const { [kResume]: A } = this;
      A && (this[kResume] = null, A());
    }
    _destroy(A, t4) {
      this._read(), t4(A);
    }
  };
  o4(Ct, "PipelineRequest");
  var PipelineRequest = Ct;
  var It = class It2 extends Readable {
    constructor(A) {
      super({ autoDestroy: true }), this[kResume] = A;
    }
    _read() {
      this[kResume]();
    }
    _destroy(A, t4) {
      !A && !this._readableState.endEmitted && (A = new RequestAbortedError), t4(A);
    }
  };
  o4(It, "PipelineResponse");
  var PipelineResponse = It;
  var at = class at2 extends AsyncResource$2 {
    constructor(A, t4) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$7("invalid opts");
      if (typeof t4 != "function")
        throw new InvalidArgumentError$7("invalid handler");
      const { signal: n3, method: r, opaque: s3, onInfo: i4, responseHeaders: E4 } = A;
      if (n3 && typeof n3.on != "function" && typeof n3.addEventListener != "function")
        throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
      if (r === "CONNECT")
        throw new InvalidArgumentError$7("invalid method");
      if (i4 && typeof i4 != "function")
        throw new InvalidArgumentError$7("invalid onInfo callback");
      super("UNDICI_PIPELINE"), this.opaque = s3 || null, this.responseHeaders = E4 || null, this.handler = t4, this.abort = null, this.context = null, this.onInfo = i4 || null, this.req = new PipelineRequest().on("error", util$8.nop), this.ret = new Duplex({ readableObjectMode: A.objectMode, autoDestroy: true, read: () => {
        const { body: Q } = this;
        Q?.resume && Q.resume();
      }, write: (Q, C, I) => {
        const { req: a3 } = this;
        a3.push(Q, C) || a3._readableState.destroyed ? I() : a3[kResume] = I;
      }, destroy: (Q, C) => {
        const { body: I, req: a3, res: f3, ret: h4, abort: L } = this;
        !Q && !h4._readableState.endEmitted && (Q = new RequestAbortedError), L && Q && L(), util$8.destroy(I, Q), util$8.destroy(a3, Q), util$8.destroy(f3, Q), removeSignal$2(this), C(Q);
      } }).on("prefinish", () => {
        const { req: Q } = this;
        Q.push(null);
      }), this.res = null, addSignal$2(this, n3);
    }
    onConnect(A, t4) {
      const { ret: n3, res: r } = this;
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$2(!r, "pipeline cannot be retried"), assert$2(!n3.destroyed), this.abort = A, this.context = t4;
    }
    onHeaders(A, t4, n3) {
      const { opaque: r, handler: s3, context: i4 } = this;
      if (A < 200) {
        if (this.onInfo) {
          const Q = this.responseHeaders === "raw" ? util$8.parseRawHeaders(t4) : util$8.parseHeaders(t4);
          this.onInfo({ statusCode: A, headers: Q });
        }
        return;
      }
      this.res = new PipelineResponse(n3);
      let E4;
      try {
        this.handler = null;
        const Q = this.responseHeaders === "raw" ? util$8.parseRawHeaders(t4) : util$8.parseHeaders(t4);
        E4 = this.runInAsyncScope(s3, null, { statusCode: A, headers: Q, opaque: r, body: this.res, context: i4 });
      } catch (Q) {
        throw this.res.on("error", util$8.nop), Q;
      }
      if (!E4 || typeof E4.on != "function")
        throw new InvalidReturnValueError("expected Readable");
      E4.on("data", (Q) => {
        const { ret: C, body: I } = this;
        !C.push(Q) && I.pause && I.pause();
      }).on("error", (Q) => {
        const { ret: C } = this;
        util$8.destroy(C, Q);
      }).on("end", () => {
        const { ret: Q } = this;
        Q.push(null);
      }).on("close", () => {
        const { ret: Q } = this;
        Q._readableState.ended || util$8.destroy(Q, new RequestAbortedError);
      }), this.body = E4;
    }
    onData(A) {
      const { res: t4 } = this;
      return t4.push(A);
    }
    onComplete(A) {
      const { res: t4 } = this;
      t4.push(null);
    }
    onError(A) {
      const { ret: t4 } = this;
      this.handler = null, util$8.destroy(t4, A);
    }
  };
  o4(at, "PipelineHandler");
  var PipelineHandler = at;
  o4(pipeline, "pipeline");
  var apiPipeline = pipeline;
  var { InvalidArgumentError: InvalidArgumentError$6, SocketError: SocketError$1 } = errors$1;
  var { AsyncResource: AsyncResource$1 } = require$$5__default$1;
  var util$7 = util$m;
  var { addSignal: addSignal$1, removeSignal: removeSignal$1 } = abortSignal;
  var assert$1 = require$$0__default;
  var ct = class ct2 extends AsyncResource$1 {
    constructor(A, t4) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$6("invalid opts");
      if (typeof t4 != "function")
        throw new InvalidArgumentError$6("invalid callback");
      const { signal: n3, opaque: r, responseHeaders: s3 } = A;
      if (n3 && typeof n3.on != "function" && typeof n3.addEventListener != "function")
        throw new InvalidArgumentError$6("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE"), this.responseHeaders = s3 || null, this.opaque = r || null, this.callback = t4, this.abort = null, this.context = null, addSignal$1(this, n3);
    }
    onConnect(A, t4) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert$1(this.callback), this.abort = A, this.context = null;
    }
    onHeaders() {
      throw new SocketError$1("bad upgrade", null);
    }
    onUpgrade(A, t4, n3) {
      const { callback: r, opaque: s3, context: i4 } = this;
      assert$1.strictEqual(A, 101), removeSignal$1(this), this.callback = null;
      const E4 = this.responseHeaders === "raw" ? util$7.parseRawHeaders(t4) : util$7.parseHeaders(t4);
      this.runInAsyncScope(r, null, null, { headers: E4, socket: n3, opaque: s3, context: i4 });
    }
    onError(A) {
      const { callback: t4, opaque: n3 } = this;
      removeSignal$1(this), t4 && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(t4, null, A, { opaque: n3 });
      }));
    }
  };
  o4(ct, "UpgradeHandler");
  var UpgradeHandler = ct;
  o4(upgrade, "upgrade");
  var apiUpgrade = upgrade;
  var assert = require$$0__default;
  var { AsyncResource } = require$$5__default$1;
  var { InvalidArgumentError: InvalidArgumentError$5, SocketError } = errors$1;
  var util$6 = util$m;
  var { addSignal, removeSignal } = abortSignal;
  var ht = class ht2 extends AsyncResource {
    constructor(A, t4) {
      if (!A || typeof A != "object")
        throw new InvalidArgumentError$5("invalid opts");
      if (typeof t4 != "function")
        throw new InvalidArgumentError$5("invalid callback");
      const { signal: n3, opaque: r, responseHeaders: s3 } = A;
      if (n3 && typeof n3.on != "function" && typeof n3.addEventListener != "function")
        throw new InvalidArgumentError$5("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT"), this.opaque = r || null, this.responseHeaders = s3 || null, this.callback = t4, this.abort = null, addSignal(this, n3);
    }
    onConnect(A, t4) {
      if (this.reason) {
        A(this.reason);
        return;
      }
      assert(this.callback), this.abort = A, this.context = t4;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(A, t4, n3) {
      const { callback: r, opaque: s3, context: i4 } = this;
      removeSignal(this), this.callback = null;
      let E4 = t4;
      E4 != null && (E4 = this.responseHeaders === "raw" ? util$6.parseRawHeaders(t4) : util$6.parseHeaders(t4)), this.runInAsyncScope(r, null, null, { statusCode: A, headers: E4, socket: n3, opaque: s3, context: i4 });
    }
    onError(A) {
      const { callback: t4, opaque: n3 } = this;
      removeSignal(this), t4 && (this.callback = null, queueMicrotask(() => {
        this.runInAsyncScope(t4, null, A, { opaque: n3 });
      }));
    }
  };
  o4(ht, "ConnectHandler");
  var ConnectHandler = ht;
  o4(connect, "connect");
  var apiConnect = connect;
  api$1.request = apiRequestExports, api$1.stream = apiStream, api$1.pipeline = apiPipeline, api$1.upgrade = apiUpgrade, api$1.connect = apiConnect;
  var { UndiciError } = errors$1;
  var MockNotMatchedError$1 = (Ae = class extends UndiciError {
    constructor(A) {
      super(A), Error.captureStackTrace(this, Ae), this.name = "MockNotMatchedError", this.message = A || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }, o4(Ae, "MockNotMatchedError"), Ae);
  var mockErrors = { MockNotMatchedError: MockNotMatchedError$1 };
  var mockSymbols = { kAgent: Symbol("agent"), kOptions: Symbol("options"), kFactory: Symbol("factory"), kDispatches: Symbol("dispatches"), kDispatchKey: Symbol("dispatch key"), kDefaultHeaders: Symbol("default headers"), kDefaultTrailers: Symbol("default trailers"), kContentLength: Symbol("content length"), kMockAgent: Symbol("mock agent"), kMockAgentSet: Symbol("mock agent set"), kMockAgentGet: Symbol("mock agent get"), kMockDispatch: Symbol("mock dispatch"), kClose: Symbol("close"), kOriginalClose: Symbol("original agent close"), kOrigin: Symbol("origin"), kIsMockActive: Symbol("is mock active"), kNetConnect: Symbol("net connect"), kGetNetConnect: Symbol("get net connect"), kConnected: Symbol("connected") };
  var { MockNotMatchedError } = mockErrors;
  var { kDispatches: kDispatches$3, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect } = mockSymbols;
  var { buildURL: buildURL$1 } = util$m;
  var { STATUS_CODES } = http__default;
  var { types: { isPromise } } = require$$0__default$1;
  o4(matchValue, "matchValue");
  o4(lowerCaseEntries, "lowerCaseEntries");
  o4(getHeaderByName, "getHeaderByName");
  o4(buildHeadersFromArray, "buildHeadersFromArray");
  o4(matchHeaders, "matchHeaders");
  o4(safeUrl, "safeUrl");
  o4(matchKey, "matchKey");
  o4(getResponseData$1, "getResponseData$1");
  o4(getMockDispatch, "getMockDispatch");
  o4(addMockDispatch$1, "addMockDispatch$1");
  o4(deleteMockDispatch, "deleteMockDispatch");
  o4(buildKey$1, "buildKey$1");
  o4(generateKeyValues, "generateKeyValues");
  o4(getStatusText, "getStatusText");
  o4(getResponse, "getResponse");
  o4(mockDispatch, "mockDispatch");
  o4(buildMockDispatch$2, "buildMockDispatch$2");
  o4(checkNetConnect, "checkNetConnect");
  o4(buildMockOptions, "buildMockOptions");
  var mockUtils = { getResponseData: getResponseData$1, getMockDispatch, addMockDispatch: addMockDispatch$1, deleteMockDispatch, buildKey: buildKey$1, generateKeyValues, matchValue, getResponse, getStatusText, mockDispatch, buildMockDispatch: buildMockDispatch$2, checkNetConnect, buildMockOptions, getHeaderByName, buildHeadersFromArray };
  var mockInterceptor = {};
  var { getResponseData, buildKey, addMockDispatch } = mockUtils;
  var { kDispatches: kDispatches$2, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = mockSymbols;
  var { InvalidArgumentError: InvalidArgumentError$4 } = errors$1;
  var { buildURL } = util$m;
  var lt = class lt2 {
    constructor(A) {
      this[kMockDispatch] = A;
    }
    delay(A) {
      if (typeof A != "number" || !Number.isInteger(A) || A <= 0)
        throw new InvalidArgumentError$4("waitInMs must be a valid integer > 0");
      return this[kMockDispatch].delay = A, this;
    }
    persist() {
      return this[kMockDispatch].persist = true, this;
    }
    times(A) {
      if (typeof A != "number" || !Number.isInteger(A) || A <= 0)
        throw new InvalidArgumentError$4("repeatTimes must be a valid integer > 0");
      return this[kMockDispatch].times = A, this;
    }
  };
  o4(lt, "MockScope");
  var MockScope = lt;
  var MockInterceptor$2 = (Te = class {
    constructor(A, t4) {
      if (typeof A != "object")
        throw new InvalidArgumentError$4("opts must be an object");
      if (typeof A.path > "u")
        throw new InvalidArgumentError$4("opts.path must be defined");
      if (typeof A.method > "u" && (A.method = "GET"), typeof A.path == "string")
        if (A.query)
          A.path = buildURL(A.path, A.query);
        else {
          const n3 = new URL(A.path, "data://");
          A.path = n3.pathname + n3.search;
        }
      typeof A.method == "string" && (A.method = A.method.toUpperCase()), this[kDispatchKey] = buildKey(A), this[kDispatches$2] = t4, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode: A, data: t4, responseOptions: n3 }) {
      const r = getResponseData(t4), s3 = this[kContentLength] ? { "content-length": r.length } : {}, i4 = { ...this[kDefaultHeaders], ...s3, ...n3.headers }, E4 = { ...this[kDefaultTrailers], ...n3.trailers };
      return { statusCode: A, data: t4, headers: i4, trailers: E4 };
    }
    validateReplyParameters(A) {
      if (typeof A.statusCode > "u")
        throw new InvalidArgumentError$4("statusCode must be defined");
      if (typeof A.responseOptions != "object" || A.responseOptions === null)
        throw new InvalidArgumentError$4("responseOptions must be an object");
    }
    reply(A) {
      if (typeof A == "function") {
        const s3 = o4((E4) => {
          const Q = A(E4);
          if (typeof Q != "object" || Q === null)
            throw new InvalidArgumentError$4("reply options callback must return an object");
          const C = { data: "", responseOptions: {}, ...Q };
          return this.validateReplyParameters(C), { ...this.createMockScopeDispatchData(C) };
        }, "wrappedDefaultsCallback"), i4 = addMockDispatch(this[kDispatches$2], this[kDispatchKey], s3);
        return new MockScope(i4);
      }
      const t4 = { statusCode: A, data: arguments[1] === undefined ? "" : arguments[1], responseOptions: arguments[2] === undefined ? {} : arguments[2] };
      this.validateReplyParameters(t4);
      const n3 = this.createMockScopeDispatchData(t4), r = addMockDispatch(this[kDispatches$2], this[kDispatchKey], n3);
      return new MockScope(r);
    }
    replyWithError(A) {
      if (typeof A > "u")
        throw new InvalidArgumentError$4("error must be defined");
      const t4 = addMockDispatch(this[kDispatches$2], this[kDispatchKey], { error: A });
      return new MockScope(t4);
    }
    defaultReplyHeaders(A) {
      if (typeof A > "u")
        throw new InvalidArgumentError$4("headers must be defined");
      return this[kDefaultHeaders] = A, this;
    }
    defaultReplyTrailers(A) {
      if (typeof A > "u")
        throw new InvalidArgumentError$4("trailers must be defined");
      return this[kDefaultTrailers] = A, this;
    }
    replyContentLength() {
      return this[kContentLength] = true, this;
    }
  }, o4(Te, "MockInterceptor"), Te);
  mockInterceptor.MockInterceptor = MockInterceptor$2, mockInterceptor.MockScope = MockScope;
  var { promisify: promisify$1 } = require$$0__default$1;
  var Client = client;
  var { buildMockDispatch: buildMockDispatch$1 } = mockUtils;
  var { kDispatches: kDispatches$1, kMockAgent: kMockAgent$1, kClose: kClose$1, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = mockSymbols;
  var { MockInterceptor: MockInterceptor$1 } = mockInterceptor;
  var Symbols$1 = symbols$4;
  var { InvalidArgumentError: InvalidArgumentError$3 } = errors$1;
  var ut = class ut2 extends Client {
    constructor(A, t4) {
      if (super(A, t4), !t4 || !t4.agent || typeof t4.agent.dispatch != "function")
        throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
      this[kMockAgent$1] = t4.agent, this[kOrigin$1] = A, this[kDispatches$1] = [], this[kConnected$1] = 1, this[kOriginalDispatch$1] = this.dispatch, this[kOriginalClose$1] = this.close.bind(this), this.dispatch = buildMockDispatch$1.call(this), this.close = this[kClose$1];
    }
    get [Symbols$1.kConnected]() {
      return this[kConnected$1];
    }
    intercept(A) {
      return new MockInterceptor$1(A, this[kDispatches$1]);
    }
    async[kClose$1]() {
      await promisify$1(this[kOriginalClose$1])(), this[kConnected$1] = 0, this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
    }
  };
  o4(ut, "MockClient");
  var { promisify } = require$$0__default$1;
  var Pool = pool;
  var { buildMockDispatch } = mockUtils;
  var { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = mockSymbols;
  var { MockInterceptor } = mockInterceptor;
  var Symbols = symbols$4;
  var { InvalidArgumentError: InvalidArgumentError$2 } = errors$1;
  var dt = class dt2 extends Pool {
    constructor(A, t4) {
      if (super(A, t4), !t4 || !t4.agent || typeof t4.agent.dispatch != "function")
        throw new InvalidArgumentError$2("Argument opts.agent must implement Agent");
      this[kMockAgent] = t4.agent, this[kOrigin] = A, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(A) {
      return new MockInterceptor(A, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  };
  o4(dt, "MockPool");
  process.versions.icu, process.versions.icu;
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError: InvalidArgumentError$1 } = errors$1;
  var Agent$1 = agent;
  getGlobalDispatcher$1() === undefined && setGlobalDispatcher$1(new Agent$1);
  o4(setGlobalDispatcher$1, "setGlobalDispatcher$1");
  o4(getGlobalDispatcher$1, "getGlobalDispatcher$1");
  var global2 = { setGlobalDispatcher: setGlobalDispatcher$1, getGlobalDispatcher: getGlobalDispatcher$1 };
  var headers;
  var hasRequiredHeaders;
  o4(requireHeaders, "requireHeaders");
  var response;
  var hasRequiredResponse;
  o4(requireResponse, "requireResponse");
  var dispatcherWeakref;
  var hasRequiredDispatcherWeakref;
  o4(requireDispatcherWeakref, "requireDispatcherWeakref");
  var request;
  var hasRequiredRequest;
  o4(requireRequest, "requireRequest");
  var fetch_1;
  var hasRequiredFetch;
  o4(requireFetch, "requireFetch");
  var symbols$2;
  var hasRequiredSymbols$2;
  o4(requireSymbols$2, "requireSymbols$2");
  var progressevent;
  var hasRequiredProgressevent;
  o4(requireProgressevent, "requireProgressevent");
  var encoding;
  var hasRequiredEncoding;
  o4(requireEncoding, "requireEncoding");
  var util$5;
  var hasRequiredUtil$4;
  o4(requireUtil$4, "requireUtil$4");
  var filereader;
  var hasRequiredFilereader;
  o4(requireFilereader, "requireFilereader");
  var symbols$1;
  var hasRequiredSymbols$1;
  o4(requireSymbols$1, "requireSymbols$1");
  var util$4;
  var hasRequiredUtil$3;
  o4(requireUtil$3, "requireUtil$3");
  var cache;
  var hasRequiredCache;
  o4(requireCache, "requireCache");
  var cachestorage;
  var hasRequiredCachestorage;
  o4(requireCachestorage, "requireCachestorage");
  var constants$1;
  var hasRequiredConstants$1;
  o4(requireConstants$1, "requireConstants$1");
  var util$3;
  var hasRequiredUtil$2;
  o4(requireUtil$2, "requireUtil$2");
  var parse2;
  var hasRequiredParse;
  o4(requireParse, "requireParse");
  var cookies;
  var hasRequiredCookies;
  o4(requireCookies, "requireCookies");
  var events;
  var hasRequiredEvents;
  o4(requireEvents, "requireEvents");
  var constants;
  var hasRequiredConstants;
  o4(requireConstants, "requireConstants");
  var symbols3;
  var hasRequiredSymbols;
  o4(requireSymbols, "requireSymbols");
  var util$2;
  var hasRequiredUtil$1;
  o4(requireUtil$1, "requireUtil$1");
  var connection;
  var hasRequiredConnection;
  o4(requireConnection, "requireConnection");
  var frame;
  var hasRequiredFrame;
  o4(requireFrame, "requireFrame");
  var receiver;
  var hasRequiredReceiver;
  o4(requireReceiver, "requireReceiver");
  var websocket;
  var hasRequiredWebsocket;
  o4(requireWebsocket, "requireWebsocket");
  var util$1;
  var hasRequiredUtil;
  o4(requireUtil, "requireUtil");
  var eventsourceStream;
  var hasRequiredEventsourceStream;
  o4(requireEventsourceStream, "requireEventsourceStream");
  var eventsource;
  var hasRequiredEventsource;
  o4(requireEventsource, "requireEventsource");
  var Dispatcher = dispatcher;
  var Agent = agent;
  var ProxyAgent = proxyAgent;
  var errors2 = errors$1;
  var util = util$m;
  var { InvalidArgumentError } = errors2;
  var api = api$1;
  var { getGlobalDispatcher, setGlobalDispatcher } = global2;
  Object.assign(Dispatcher.prototype, api);
  var Agent_1 = Agent;
  var ProxyAgent_1 = ProxyAgent;
  util.parseHeaders, util.headerNameToString;
  o4(makeDispatcher, "makeDispatcher"), requireFetch().fetch, requireHeaders().Headers, requireResponse().Response, requireRequest().Request, requireFormdata().FormData, requireFile().File, requireFilereader().FileReader, requireGlobal();
  var { CacheStorage } = requireCachestorage();
  var { kConstruct } = requireSymbols$1();
  new CacheStorage(kConstruct), requireCookies(), requireDataUrl(), requireEvents(), requireWebsocket().WebSocket, makeDispatcher(api.request), makeDispatcher(api.stream), makeDispatcher(api.pipeline), makeDispatcher(api.connect), makeDispatcher(api.upgrade), requireEventsource(), exports.Agent_1 = Agent_1, exports.ProxyAgent_1 = ProxyAgent_1;
});

// node_modules/node-fetch-native-with-agent/dist/agent.cjs
var require_agent = __commonJS((exports) => {
  function createAgent(e3, t4 = {}) {
    const n3 = { rejectUnauthorized: t4.rejectUnauthorized }, c3 = e3?.startsWith("https:") ? new https.Agent(n3) : new http.Agent, s3 = new index.Agent_1({ connect: n3 });
    return { agent: c3, dispatcher: s3 };
  }
  function createFetch(e3 = {}) {
    const t4 = createAgent(undefined, e3);
    return (n3, c3) => nodeFetchNativeWithAgent.fetch(n3, { ...t4, ...c3 });
  }
  var u = Object.defineProperty;
  var o4 = (e3, t4) => u(e3, "name", { value: t4, configurable: true });
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var index = require_node_fetch_native_with_agent_df7e6bd6();
  var nodeFetchNativeWithAgent = (init_native(), __toCommonJS(exports_native));
  import.meta.require("assert"), import.meta.require("net"), import.meta.require("stream"), import.meta.require("buffer"), import.meta.require("util"), import.meta.require("querystring"), import.meta.require("diagnostics_channel"), import.meta.require("events"), require_node_fetch_native_with_agent_61758d11(), import.meta.require("tls"), import.meta.require("zlib"), import.meta.require("perf_hooks"), import.meta.require("util/types"), import.meta.require("os"), import.meta.require("url"), import.meta.require("async_hooks"), import.meta.require("console"), import.meta.require("string_decoder"), import.meta.require("worker_threads");
  var i4 = Object.defineProperty;
  var r = o4((e3, t4) => i4(e3, "name", { value: t4, configurable: true }), "r");
  o4(createAgent, "createAgent"), r(createAgent, "createAgent");
  o4(createFetch, "createFetch"), r(createFetch, "createFetch");
  var fetch2 = createFetch({});
  exports.createAgent = createAgent, exports.createFetch = createFetch, exports.fetch = fetch2;
});

// node_modules/node-appwrite/dist/query.js
var require_query = __commonJS((exports) => {
  var _Query = class _Query2 {
    constructor(method, attribute, values) {
      this.method = method;
      this.attribute = attribute;
      if (values !== undefined) {
        if (Array.isArray(values)) {
          this.values = values;
        } else {
          this.values = [values];
        }
      }
    }
    toString() {
      return JSON.stringify({
        method: this.method,
        attribute: this.attribute,
        values: this.values
      });
    }
  };
  _Query.equal = (attribute, value2) => new _Query("equal", attribute, value2).toString();
  _Query.notEqual = (attribute, value2) => new _Query("notEqual", attribute, value2).toString();
  _Query.lessThan = (attribute, value2) => new _Query("lessThan", attribute, value2).toString();
  _Query.lessThanEqual = (attribute, value2) => new _Query("lessThanEqual", attribute, value2).toString();
  _Query.greaterThan = (attribute, value2) => new _Query("greaterThan", attribute, value2).toString();
  _Query.greaterThanEqual = (attribute, value2) => new _Query("greaterThanEqual", attribute, value2).toString();
  _Query.isNull = (attribute) => new _Query("isNull", attribute).toString();
  _Query.isNotNull = (attribute) => new _Query("isNotNull", attribute).toString();
  _Query.between = (attribute, start, end) => new _Query("between", attribute, [start, end]).toString();
  _Query.startsWith = (attribute, value2) => new _Query("startsWith", attribute, value2).toString();
  _Query.endsWith = (attribute, value2) => new _Query("endsWith", attribute, value2).toString();
  _Query.select = (attributes) => new _Query("select", undefined, attributes).toString();
  _Query.search = (attribute, value2) => new _Query("search", attribute, value2).toString();
  _Query.orderDesc = (attribute) => new _Query("orderDesc", attribute).toString();
  _Query.orderAsc = (attribute) => new _Query("orderAsc", attribute).toString();
  _Query.cursorAfter = (documentId) => new _Query("cursorAfter", undefined, documentId).toString();
  _Query.cursorBefore = (documentId) => new _Query("cursorBefore", undefined, documentId).toString();
  _Query.limit = (limit) => new _Query("limit", undefined, limit).toString();
  _Query.offset = (offset) => new _Query("offset", undefined, offset).toString();
  _Query.contains = (attribute, value2) => new _Query("contains", attribute, value2).toString();
  _Query.or = (queries) => new _Query("or", undefined, queries.map((query) => JSON.parse(query))).toString();
  _Query.and = (queries) => new _Query("and", undefined, queries.map((query) => JSON.parse(query))).toString();
  var Query = _Query;
  exports.Query = Query;
});

// node_modules/node-appwrite/dist/client.js
var require_client = __commonJS((exports) => {
  function getUserAgent() {
    let ua = "AppwriteNodeJSSDK/14.1.0";
    const platform = [];
    if (typeof process !== "undefined") {
      if (typeof process.platform === "string")
        platform.push(process.platform);
      if (typeof process.arch === "string")
        platform.push(process.arch);
    }
    if (platform.length > 0) {
      ua += ` (${platform.join("; ")})`;
    }
    if (typeof navigator !== "undefined" && typeof navigator.userAgent === "string") {
      ua += ` ${navigator.userAgent}`;
    } else if (typeof globalThis.EdgeRuntime === "string") {
      ua += ` EdgeRuntime`;
    } else if (typeof process !== "undefined" && typeof process.version === "string") {
      ua += ` Node.js/${process.version}`;
    }
    return ua;
  }
  var nodeFetchNativeWithAgent = (init_native(), __toCommonJS(exports_native));
  var agent = require_agent();
  var query = require_query();

  class AppwriteException extends Error {
    constructor(message, code = 0, type3 = "", response = "") {
      super(message);
      this.name = "AppwriteException";
      this.message = message;
      this.code = code;
      this.type = type3;
      this.response = response;
    }
  }
  var _Client = class _Client2 {
    constructor() {
      this.config = {
        endpoint: "https://cloud.appwrite.io/v1",
        selfSigned: false,
        project: "",
        key: "",
        jwt: "",
        locale: "",
        session: "",
        forwardeduseragent: ""
      };
      this.headers = {
        "x-sdk-name": "Node.js",
        "x-sdk-platform": "server",
        "x-sdk-language": "nodejs",
        "x-sdk-version": "14.1.0",
        "user-agent": getUserAgent(),
        "X-Appwrite-Response-Format": "1.6.0"
      };
    }
    setEndpoint(endpoint) {
      this.config.endpoint = endpoint;
      return this;
    }
    setSelfSigned(selfSigned) {
      if (typeof globalThis.EdgeRuntime !== "undefined") {
        console.warn("setSelfSigned is not supported in edge runtimes.");
      }
      this.config.selfSigned = selfSigned;
      return this;
    }
    addHeader(header, value2) {
      this.headers[header.toLowerCase()] = value2;
      return this;
    }
    setProject(value2) {
      this.headers["X-Appwrite-Project"] = value2;
      this.config.project = value2;
      return this;
    }
    setKey(value2) {
      this.headers["X-Appwrite-Key"] = value2;
      this.config.key = value2;
      return this;
    }
    setJWT(value2) {
      this.headers["X-Appwrite-JWT"] = value2;
      this.config.jwt = value2;
      return this;
    }
    setLocale(value2) {
      this.headers["X-Appwrite-Locale"] = value2;
      this.config.locale = value2;
      return this;
    }
    setSession(value2) {
      this.headers["X-Appwrite-Session"] = value2;
      this.config.session = value2;
      return this;
    }
    setForwardedUserAgent(value2) {
      this.headers["X-Forwarded-User-Agent"] = value2;
      this.config.forwardeduseragent = value2;
      return this;
    }
    prepareRequest(method, url, headers = {}, params = {}) {
      method = method.toUpperCase();
      headers = Object.assign({}, this.headers, headers);
      let options = {
        method,
        headers,
        ...agent.createAgent(this.config.endpoint, { rejectUnauthorized: !this.config.selfSigned })
      };
      if (method === "GET") {
        for (const [key, value2] of Object.entries(_Client2.flatten(params))) {
          url.searchParams.append(key, value2);
        }
      } else {
        switch (headers["content-type"]) {
          case "application/json":
            options.body = JSON.stringify(params);
            break;
          case "multipart/form-data":
            const formData = new nodeFetchNativeWithAgent.FormData;
            for (const [key, value2] of Object.entries(params)) {
              if (value2 instanceof nodeFetchNativeWithAgent.File) {
                formData.append(key, value2, value2.name);
              } else if (Array.isArray(value2)) {
                for (const nestedValue of value2) {
                  formData.append(`${key}[]`, nestedValue);
                }
              } else {
                formData.append(key, value2);
              }
            }
            options.body = formData;
            delete headers["content-type"];
            break;
        }
      }
      return { uri: url.toString(), options };
    }
    async chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {
      const file = Object.values(originalPayload).find((value2) => value2 instanceof nodeFetchNativeWithAgent.File);
      if (file.size <= _Client2.CHUNK_SIZE) {
        return await this.call(method, url, headers, originalPayload);
      }
      let start = 0;
      let response = null;
      while (start < file.size) {
        let end = start + _Client2.CHUNK_SIZE;
        if (end >= file.size) {
          end = file.size;
        }
        headers["content-range"] = `bytes ${start}-${end - 1}/${file.size}`;
        const chunk = file.slice(start, end);
        let payload = { ...originalPayload, file: new nodeFetchNativeWithAgent.File([chunk], file.name) };
        response = await this.call(method, url, headers, payload);
        if (onProgress && typeof onProgress === "function") {
          onProgress({
            $id: response.$id,
            progress: Math.round(end / file.size * 100),
            sizeUploaded: end,
            chunksTotal: Math.ceil(file.size / _Client2.CHUNK_SIZE),
            chunksUploaded: Math.ceil(end / _Client2.CHUNK_SIZE)
          });
        }
        if (response && response.$id) {
          headers["x-appwrite-id"] = response.$id;
        }
        start = end;
      }
      return response;
    }
    async redirect(method, url, headers = {}, params = {}) {
      const { uri, options } = this.prepareRequest(method, url, headers, params);
      const response = await nodeFetchNativeWithAgent.fetch(uri, {
        ...options,
        redirect: "manual"
      });
      if (response.status !== 301 && response.status !== 302) {
        throw new AppwriteException("Invalid redirect", response.status);
      }
      return response.headers.get("location") || "";
    }
    async call(method, url, headers = {}, params = {}, responseType = "json") {
      var _a;
      const { uri, options } = this.prepareRequest(method, url, headers, params);
      let data = null;
      const response = await nodeFetchNativeWithAgent.fetch(uri, options);
      const warnings = response.headers.get("x-appwrite-warning");
      if (warnings) {
        warnings.split(";").forEach((warning) => console.warn("Warning: " + warning));
      }
      if ((_a = response.headers.get("content-type")) == null ? undefined : _a.includes("application/json")) {
        data = await response.json();
      } else if (responseType === "arrayBuffer") {
        data = await response.arrayBuffer();
      } else {
        data = {
          message: await response.text()
        };
      }
      if (400 <= response.status) {
        throw new AppwriteException(data == null ? undefined : data.message, response.status, data == null ? undefined : data.type, data);
      }
      return data;
    }
    static flatten(data, prefix = "") {
      let output = {};
      for (const [key, value2] of Object.entries(data)) {
        let finalKey = prefix ? prefix + "[" + key + "]" : key;
        if (Array.isArray(value2)) {
          output = { ...output, ..._Client2.flatten(value2, finalKey) };
        } else {
          output[finalKey] = value2;
        }
      }
      return output;
    }
  };
  _Client.CHUNK_SIZE = 1024 * 1024 * 5;
  var Client = _Client;
  Object.defineProperty(exports, "Query", {
    enumerable: true,
    get: function() {
      return query.Query;
    }
  });
  exports.AppwriteException = AppwriteException;
  exports.Client = Client;
});

// node_modules/node-appwrite/dist/services/account.js
var require_account = __commonJS((exports) => {
  var client = require_client();

  class Account {
    constructor(client2) {
      this.client = client2;
    }
    async get() {
      const apiPath = "/account";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async create(userId, email, password, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateEmail(email, password) {
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/email";
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async listIdentities(queries) {
      const apiPath = "/account/identities";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteIdentity(identityId) {
      if (typeof identityId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "identityId"');
      }
      const apiPath = "/account/identities/{identityId}".replace("{identityId}", identityId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async createJWT() {
      const apiPath = "/account/jwts";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async listLogs(queries) {
      const apiPath = "/account/logs";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateMFA(mfa) {
      if (typeof mfa === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "mfa"');
      }
      const apiPath = "/account/mfa";
      const payload = {};
      if (typeof mfa !== "undefined") {
        payload["mfa"] = mfa;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createMfaAuthenticator(type3) {
      if (typeof type3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type3);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateMfaAuthenticator(type3, otp) {
      if (typeof type3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof otp === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "otp"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type3);
      const payload = {};
      if (typeof otp !== "undefined") {
        payload["otp"] = otp;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async deleteMfaAuthenticator(type3) {
      if (typeof type3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type3);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async createMfaChallenge(factor) {
      if (typeof factor === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "factor"');
      }
      const apiPath = "/account/mfa/challenge";
      const payload = {};
      if (typeof factor !== "undefined") {
        payload["factor"] = factor;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateMfaChallenge(challengeId, otp) {
      if (typeof challengeId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "challengeId"');
      }
      if (typeof otp === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "otp"');
      }
      const apiPath = "/account/mfa/challenge";
      const payload = {};
      if (typeof challengeId !== "undefined") {
        payload["challengeId"] = challengeId;
      }
      if (typeof otp !== "undefined") {
        payload["otp"] = otp;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async listMfaFactors() {
      const apiPath = "/account/mfa/factors";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getMfaRecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createMfaRecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateMfaRecoveryCodes() {
      const apiPath = "/account/mfa/recovery-codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updateName(name) {
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/account/name";
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updatePassword(password, oldPassword) {
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/password";
      const payload = {};
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof oldPassword !== "undefined") {
        payload["oldPassword"] = oldPassword;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updatePhone(phone, password) {
      if (typeof phone === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "phone"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/phone";
      const payload = {};
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getPrefs() {
      const apiPath = "/account/prefs";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updatePrefs(prefs) {
      if (typeof prefs === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "prefs"');
      }
      const apiPath = "/account/prefs";
      const payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createRecovery(email, url) {
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/account/recovery";
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateRecovery(userId, secret, password) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/recovery";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async listSessions() {
      const apiPath = "/account/sessions";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteSessions() {
      const apiPath = "/account/sessions";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async createAnonymousSession() {
      const apiPath = "/account/sessions/anonymous";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createEmailPasswordSession(email, password) {
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/account/sessions/email";
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateMagicURLSession(userId, secret) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/sessions/magic-url";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async updatePhoneSession(userId, secret) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/sessions/phone";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async createSession(userId, secret) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/sessions/token";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getSession(sessionId) {
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateSession(sessionId) {
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteSession(sessionId) {
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async updateStatus() {
      const apiPath = "/account/status";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createEmailToken(userId, email, phrase) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      const apiPath = "/account/tokens/email";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof phrase !== "undefined") {
        payload["phrase"] = phrase;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createMagicURLToken(userId, email, url, phrase) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      const apiPath = "/account/tokens/magic-url";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof phrase !== "undefined") {
        payload["phrase"] = phrase;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createOAuth2Token(provider, success, failure, scopes) {
      if (typeof provider === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "provider"');
      }
      const apiPath = "/account/tokens/oauth2/{provider}".replace("{provider}", provider);
      const payload = {};
      if (typeof success !== "undefined") {
        payload["success"] = success;
      }
      if (typeof failure !== "undefined") {
        payload["failure"] = failure;
      }
      if (typeof scopes !== "undefined") {
        payload["scopes"] = scopes;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.redirect("get", uri, apiHeaders, payload);
    }
    async createPhoneToken(userId, phone) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof phone === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "phone"');
      }
      const apiPath = "/account/tokens/phone";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createVerification(url) {
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/account/verification";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateVerification(userId, secret) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/verification";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async createPhoneVerification() {
      const apiPath = "/account/verification/phone";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updatePhoneVerification(userId, secret) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/account/verification/phone";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
  }
  exports.Account = Account;
});

// node_modules/node-appwrite/dist/services/avatars.js
var require_avatars = __commonJS((exports) => {
  var client = require_client();

  class Avatars {
    constructor(client2) {
      this.client = client2;
    }
    async getBrowser(code, width, height, quality) {
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      const apiPath = "/avatars/browsers/{code}".replace("{code}", code);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getCreditCard(code, width, height, quality) {
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      const apiPath = "/avatars/credit-cards/{code}".replace("{code}", code);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getFavicon(url) {
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/avatars/favicon";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getFlag(code, width, height, quality) {
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      const apiPath = "/avatars/flags/{code}".replace("{code}", code);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getImage(url, width, height) {
      if (typeof url === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "url"');
      }
      const apiPath = "/avatars/image";
      const payload = {};
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getInitials(name, width, height, background) {
      const apiPath = "/avatars/initials";
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof background !== "undefined") {
        payload["background"] = background;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getQR(text, size, margin, download) {
      if (typeof text === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "text"');
      }
      const apiPath = "/avatars/qr";
      const payload = {};
      if (typeof text !== "undefined") {
        payload["text"] = text;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof margin !== "undefined") {
        payload["margin"] = margin;
      }
      if (typeof download !== "undefined") {
        payload["download"] = download;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
  }
  exports.Avatars = Avatars;
});

// node_modules/node-appwrite/dist/services/databases.js
var require_databases = __commonJS((exports) => {
  var client = require_client();

  class Databases {
    constructor(client2) {
      this.client = client2;
    }
    async list(queries, search) {
      const apiPath = "/databases";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async create(databaseId, name, enabled) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases";
      const payload = {};
      if (typeof databaseId !== "undefined") {
        payload["databaseId"] = databaseId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async get(databaseId) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async update(databaseId, name, enabled) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async delete(databaseId) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/databases/{databaseId}".replace("{databaseId}", databaseId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listCollections(databaseId, queries, search) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      const apiPath = "/databases/{databaseId}/collections".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases/{databaseId}/collections".replace("{databaseId}", databaseId);
      const payload = {};
      if (typeof collectionId !== "undefined") {
        payload["collectionId"] = collectionId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof documentSecurity !== "undefined") {
        payload["documentSecurity"] = documentSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getCollection(databaseId, collectionId) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateCollection(databaseId, collectionId, name, permissions, documentSecurity, enabled) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof documentSecurity !== "undefined") {
        payload["documentSecurity"] = documentSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async deleteCollection(databaseId, collectionId) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listAttributes(databaseId, collectionId, queries) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createBooleanAttribute(databaseId, collectionId, key, required3, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/boolean".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateBooleanAttribute(databaseId, collectionId, key, required3, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createDatetimeAttribute(databaseId, collectionId, key, required3, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/datetime".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateDatetimeAttribute(databaseId, collectionId, key, required3, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createEmailAttribute(databaseId, collectionId, key, required3, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/email".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateEmailAttribute(databaseId, collectionId, key, required3, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createEnumAttribute(databaseId, collectionId, key, elements, required3, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof elements === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "elements"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/enum".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof elements !== "undefined") {
        payload["elements"] = elements;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateEnumAttribute(databaseId, collectionId, key, elements, required3, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof elements === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "elements"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof elements !== "undefined") {
        payload["elements"] = elements;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createFloatAttribute(databaseId, collectionId, key, required3, min, max, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/float".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateFloatAttribute(databaseId, collectionId, key, required3, min, max, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof min === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "min"');
      }
      if (typeof max === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "max"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createIntegerAttribute(databaseId, collectionId, key, required3, min, max, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/integer".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateIntegerAttribute(databaseId, collectionId, key, required3, min, max, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof min === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "min"');
      }
      if (typeof max === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "max"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof min !== "undefined") {
        payload["min"] = min;
      }
      if (typeof max !== "undefined") {
        payload["max"] = max;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createIpAttribute(databaseId, collectionId, key, required3, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/ip".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateIpAttribute(databaseId, collectionId, key, required3, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createRelationshipAttribute(databaseId, collectionId, relatedCollectionId, type3, twoWay, key, twoWayKey, onDelete) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof relatedCollectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "relatedCollectionId"');
      }
      if (typeof type3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/relationship".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof relatedCollectionId !== "undefined") {
        payload["relatedCollectionId"] = relatedCollectionId;
      }
      if (typeof type3 !== "undefined") {
        payload["type"] = type3;
      }
      if (typeof twoWay !== "undefined") {
        payload["twoWay"] = twoWay;
      }
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof twoWayKey !== "undefined") {
        payload["twoWayKey"] = twoWayKey;
      }
      if (typeof onDelete !== "undefined") {
        payload["onDelete"] = onDelete;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createStringAttribute(databaseId, collectionId, key, size, required3, xdefault, array3, encrypt) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof size === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "size"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/string".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      if (typeof encrypt !== "undefined") {
        payload["encrypt"] = encrypt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateStringAttribute(databaseId, collectionId, key, required3, xdefault, size, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof size !== "undefined") {
        payload["size"] = size;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createUrlAttribute(databaseId, collectionId, key, required3, xdefault, array3) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/url".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof array3 !== "undefined") {
        payload["array"] = array3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateUrlAttribute(databaseId, collectionId, key, required3, xdefault, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof required3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "required"');
      }
      if (typeof xdefault === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "xdefault"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof required3 !== "undefined") {
        payload["required"] = required3;
      }
      if (typeof xdefault !== "undefined") {
        payload["default"] = xdefault;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getAttribute(databaseId, collectionId, key) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteAttribute(databaseId, collectionId, key) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async updateRelationshipAttribute(databaseId, collectionId, key, onDelete, newKey) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      if (typeof onDelete !== "undefined") {
        payload["onDelete"] = onDelete;
      }
      if (typeof newKey !== "undefined") {
        payload["newKey"] = newKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async listDocuments(databaseId, collectionId, queries) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createDocument(databaseId, collectionId, documentId, data, permissions) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      if (typeof data === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "data"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof documentId !== "undefined") {
        payload["documentId"] = documentId;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getDocument(databaseId, collectionId, documentId, queries) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateDocument(databaseId, collectionId, documentId, data, permissions) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteDocument(databaseId, collectionId, documentId) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof documentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "documentId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{documentId}", documentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listIndexes(databaseId, collectionId, queries) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createIndex(databaseId, collectionId, key, type3, attributes, orders) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof type3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      if (typeof attributes === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "attributes"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof type3 !== "undefined") {
        payload["type"] = type3;
      }
      if (typeof attributes !== "undefined") {
        payload["attributes"] = attributes;
      }
      if (typeof orders !== "undefined") {
        payload["orders"] = orders;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getIndex(databaseId, collectionId, key) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteIndex(databaseId, collectionId, key) {
      if (typeof databaseId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "databaseId"');
      }
      if (typeof collectionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "collectionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/databases/{databaseId}/collections/{collectionId}/indexes/{key}".replace("{databaseId}", databaseId).replace("{collectionId}", collectionId).replace("{key}", key);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Databases = Databases;
});

// node_modules/node-appwrite/dist/services/functions.js
var require_functions = __commonJS((exports) => {
  var client = require_client();

  class Functions {
    constructor(client2) {
      this.client = client2;
    }
    async list(queries, search) {
      const apiPath = "/functions";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async create(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, scopes, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory, templateRepository, templateOwner, templateRootDirectory, templateVersion, specification) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof runtime === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "runtime"');
      }
      const apiPath = "/functions";
      const payload = {};
      if (typeof functionId !== "undefined") {
        payload["functionId"] = functionId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof runtime !== "undefined") {
        payload["runtime"] = runtime;
      }
      if (typeof execute !== "undefined") {
        payload["execute"] = execute;
      }
      if (typeof events !== "undefined") {
        payload["events"] = events;
      }
      if (typeof schedule !== "undefined") {
        payload["schedule"] = schedule;
      }
      if (typeof timeout !== "undefined") {
        payload["timeout"] = timeout;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof logging !== "undefined") {
        payload["logging"] = logging;
      }
      if (typeof entrypoint !== "undefined") {
        payload["entrypoint"] = entrypoint;
      }
      if (typeof commands !== "undefined") {
        payload["commands"] = commands;
      }
      if (typeof scopes !== "undefined") {
        payload["scopes"] = scopes;
      }
      if (typeof installationId !== "undefined") {
        payload["installationId"] = installationId;
      }
      if (typeof providerRepositoryId !== "undefined") {
        payload["providerRepositoryId"] = providerRepositoryId;
      }
      if (typeof providerBranch !== "undefined") {
        payload["providerBranch"] = providerBranch;
      }
      if (typeof providerSilentMode !== "undefined") {
        payload["providerSilentMode"] = providerSilentMode;
      }
      if (typeof providerRootDirectory !== "undefined") {
        payload["providerRootDirectory"] = providerRootDirectory;
      }
      if (typeof templateRepository !== "undefined") {
        payload["templateRepository"] = templateRepository;
      }
      if (typeof templateOwner !== "undefined") {
        payload["templateOwner"] = templateOwner;
      }
      if (typeof templateRootDirectory !== "undefined") {
        payload["templateRootDirectory"] = templateRootDirectory;
      }
      if (typeof templateVersion !== "undefined") {
        payload["templateVersion"] = templateVersion;
      }
      if (typeof specification !== "undefined") {
        payload["specification"] = specification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async listRuntimes() {
      const apiPath = "/functions/runtimes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listSpecifications() {
      const apiPath = "/functions/specifications";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async get(functionId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async update(functionId, name, runtime, execute, events, schedule, timeout, enabled, logging, entrypoint, commands, scopes, installationId, providerRepositoryId, providerBranch, providerSilentMode, providerRootDirectory, specification) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof runtime !== "undefined") {
        payload["runtime"] = runtime;
      }
      if (typeof execute !== "undefined") {
        payload["execute"] = execute;
      }
      if (typeof events !== "undefined") {
        payload["events"] = events;
      }
      if (typeof schedule !== "undefined") {
        payload["schedule"] = schedule;
      }
      if (typeof timeout !== "undefined") {
        payload["timeout"] = timeout;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof logging !== "undefined") {
        payload["logging"] = logging;
      }
      if (typeof entrypoint !== "undefined") {
        payload["entrypoint"] = entrypoint;
      }
      if (typeof commands !== "undefined") {
        payload["commands"] = commands;
      }
      if (typeof scopes !== "undefined") {
        payload["scopes"] = scopes;
      }
      if (typeof installationId !== "undefined") {
        payload["installationId"] = installationId;
      }
      if (typeof providerRepositoryId !== "undefined") {
        payload["providerRepositoryId"] = providerRepositoryId;
      }
      if (typeof providerBranch !== "undefined") {
        payload["providerBranch"] = providerBranch;
      }
      if (typeof providerSilentMode !== "undefined") {
        payload["providerSilentMode"] = providerSilentMode;
      }
      if (typeof providerRootDirectory !== "undefined") {
        payload["providerRootDirectory"] = providerRootDirectory;
      }
      if (typeof specification !== "undefined") {
        payload["specification"] = specification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async delete(functionId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listDeployments(functionId, queries, search) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createDeployment(functionId, code, activate, entrypoint, commands, onProgress = (progress) => {
    }) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof code === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "code"');
      }
      if (typeof activate === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "activate"');
      }
      const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
      const payload = {};
      if (typeof entrypoint !== "undefined") {
        payload["entrypoint"] = entrypoint;
      }
      if (typeof commands !== "undefined") {
        payload["commands"] = commands;
      }
      if (typeof code !== "undefined") {
        payload["code"] = code;
      }
      if (typeof activate !== "undefined") {
        payload["activate"] = activate;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "multipart/form-data"
      };
      return await this.client.chunkedUpload("post", uri, apiHeaders, payload, onProgress);
    }
    async getDeployment(functionId, deploymentId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateDeployment(functionId, deploymentId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteDeployment(functionId, deploymentId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async createBuild(functionId, deploymentId, buildId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}/build".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      if (typeof buildId !== "undefined") {
        payload["buildId"] = buildId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateDeploymentBuild(functionId, deploymentId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}/build".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getDeploymentDownload(functionId, deploymentId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof deploymentId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "deploymentId"');
      }
      const apiPath = "/functions/{functionId}/deployments/{deploymentId}/download".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async listExecutions(functionId, queries, search) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createExecution(functionId, body, async, xpath, method, headers, scheduledAt) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
      const payload = {};
      if (typeof body !== "undefined") {
        payload["body"] = body;
      }
      if (typeof async !== "undefined") {
        payload["async"] = async;
      }
      if (typeof xpath !== "undefined") {
        payload["path"] = xpath;
      }
      if (typeof method !== "undefined") {
        payload["method"] = method;
      }
      if (typeof headers !== "undefined") {
        payload["headers"] = headers;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getExecution(functionId, executionId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof executionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "executionId"');
      }
      const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteExecution(functionId, executionId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof executionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "executionId"');
      }
      const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listVariables(functionId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createVariable(functionId, key, value2) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      if (typeof value2 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "value"');
      }
      const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof value2 !== "undefined") {
        payload["value"] = value2;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getVariable(functionId, variableId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateVariable(functionId, variableId, key, value2) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      if (typeof key === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "key"');
      }
      const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
      const payload = {};
      if (typeof key !== "undefined") {
        payload["key"] = key;
      }
      if (typeof value2 !== "undefined") {
        payload["value"] = value2;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async deleteVariable(functionId, variableId) {
      if (typeof functionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "functionId"');
      }
      if (typeof variableId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "variableId"');
      }
      const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Functions = Functions;
});

// node_modules/node-appwrite/dist/services/graphql.js
var require_graphql = __commonJS((exports) => {
  var client = require_client();

  class Graphql {
    constructor(client2) {
      this.client = client2;
    }
    async query(query) {
      if (typeof query === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "query"');
      }
      const apiPath = "/graphql";
      const payload = {};
      if (typeof query !== "undefined") {
        payload["query"] = query;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "x-sdk-graphql": "true",
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async mutation(query) {
      if (typeof query === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "query"');
      }
      const apiPath = "/graphql/mutation";
      const payload = {};
      if (typeof query !== "undefined") {
        payload["query"] = query;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "x-sdk-graphql": "true",
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
  }
  exports.Graphql = Graphql;
});

// node_modules/node-appwrite/dist/services/health.js
var require_health = __commonJS((exports) => {
  var client = require_client();

  class Health {
    constructor(client2) {
      this.client = client2;
    }
    async get() {
      const apiPath = "/health";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getAntivirus() {
      const apiPath = "/health/anti-virus";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getCache() {
      const apiPath = "/health/cache";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getCertificate(domain) {
      const apiPath = "/health/certificate";
      const payload = {};
      if (typeof domain !== "undefined") {
        payload["domain"] = domain;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getDB() {
      const apiPath = "/health/db";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getPubSub() {
      const apiPath = "/health/pubsub";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueue() {
      const apiPath = "/health/queue";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueBuilds(threshold) {
      const apiPath = "/health/queue/builds";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueCertificates(threshold) {
      const apiPath = "/health/queue/certificates";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueDatabases(name, threshold) {
      const apiPath = "/health/queue/databases";
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueDeletes(threshold) {
      const apiPath = "/health/queue/deletes";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getFailedJobs(name, threshold) {
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/health/queue/failed/{name}".replace("{name}", name);
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueFunctions(threshold) {
      const apiPath = "/health/queue/functions";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueLogs(threshold) {
      const apiPath = "/health/queue/logs";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueMails(threshold) {
      const apiPath = "/health/queue/mails";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueMessaging(threshold) {
      const apiPath = "/health/queue/messaging";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueMigrations(threshold) {
      const apiPath = "/health/queue/migrations";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueUsage(threshold) {
      const apiPath = "/health/queue/usage";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueUsageDump(threshold) {
      const apiPath = "/health/queue/usage-dump";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getQueueWebhooks(threshold) {
      const apiPath = "/health/queue/webhooks";
      const payload = {};
      if (typeof threshold !== "undefined") {
        payload["threshold"] = threshold;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getStorage() {
      const apiPath = "/health/storage";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getStorageLocal() {
      const apiPath = "/health/storage/local";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getTime() {
      const apiPath = "/health/time";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
  }
  exports.Health = Health;
});

// node_modules/node-appwrite/dist/services/locale.js
var require_locale = __commonJS((exports) => {
  class Locale {
    constructor(client) {
      this.client = client;
    }
    async get() {
      const apiPath = "/locale";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listCodes() {
      const apiPath = "/locale/codes";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listContinents() {
      const apiPath = "/locale/continents";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listCountries() {
      const apiPath = "/locale/countries";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listCountriesEU() {
      const apiPath = "/locale/countries/eu";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listCountriesPhones() {
      const apiPath = "/locale/countries/phones";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listCurrencies() {
      const apiPath = "/locale/currencies";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listLanguages() {
      const apiPath = "/locale/languages";
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
  }
  exports.Locale = Locale;
});

// node_modules/node-appwrite/dist/services/messaging.js
var require_messaging = __commonJS((exports) => {
  var client = require_client();

  class Messaging {
    constructor(client2) {
      this.client = client2;
    }
    async listMessages(queries, search) {
      const apiPath = "/messaging/messages";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createEmail(messageId, subject, content, topics, users, targets, cc, bcc, attachments, draft, html, scheduledAt) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      if (typeof subject === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subject"');
      }
      if (typeof content === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "content"');
      }
      const apiPath = "/messaging/messages/email";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof subject !== "undefined") {
        payload["subject"] = subject;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof cc !== "undefined") {
        payload["cc"] = cc;
      }
      if (typeof bcc !== "undefined") {
        payload["bcc"] = bcc;
      }
      if (typeof attachments !== "undefined") {
        payload["attachments"] = attachments;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof html !== "undefined") {
        payload["html"] = html;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateEmail(messageId, topics, users, targets, subject, content, draft, html, cc, bcc, scheduledAt, attachments) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/email/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof subject !== "undefined") {
        payload["subject"] = subject;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof html !== "undefined") {
        payload["html"] = html;
      }
      if (typeof cc !== "undefined") {
        payload["cc"] = cc;
      }
      if (typeof bcc !== "undefined") {
        payload["bcc"] = bcc;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      if (typeof attachments !== "undefined") {
        payload["attachments"] = attachments;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createPush(messageId, title, body, topics, users, targets, data, action, image, icon, sound, color, tag, badge, draft, scheduledAt) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      if (typeof title === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "title"');
      }
      if (typeof body === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "body"');
      }
      const apiPath = "/messaging/messages/push";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof title !== "undefined") {
        payload["title"] = title;
      }
      if (typeof body !== "undefined") {
        payload["body"] = body;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof action !== "undefined") {
        payload["action"] = action;
      }
      if (typeof image !== "undefined") {
        payload["image"] = image;
      }
      if (typeof icon !== "undefined") {
        payload["icon"] = icon;
      }
      if (typeof sound !== "undefined") {
        payload["sound"] = sound;
      }
      if (typeof color !== "undefined") {
        payload["color"] = color;
      }
      if (typeof tag !== "undefined") {
        payload["tag"] = tag;
      }
      if (typeof badge !== "undefined") {
        payload["badge"] = badge;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updatePush(messageId, topics, users, targets, title, body, data, action, image, icon, sound, color, tag, badge, draft, scheduledAt) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/push/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof title !== "undefined") {
        payload["title"] = title;
      }
      if (typeof body !== "undefined") {
        payload["body"] = body;
      }
      if (typeof data !== "undefined") {
        payload["data"] = data;
      }
      if (typeof action !== "undefined") {
        payload["action"] = action;
      }
      if (typeof image !== "undefined") {
        payload["image"] = image;
      }
      if (typeof icon !== "undefined") {
        payload["icon"] = icon;
      }
      if (typeof sound !== "undefined") {
        payload["sound"] = sound;
      }
      if (typeof color !== "undefined") {
        payload["color"] = color;
      }
      if (typeof tag !== "undefined") {
        payload["tag"] = tag;
      }
      if (typeof badge !== "undefined") {
        payload["badge"] = badge;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createSms(messageId, content, topics, users, targets, draft, scheduledAt) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      if (typeof content === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "content"');
      }
      const apiPath = "/messaging/messages/sms";
      const payload = {};
      if (typeof messageId !== "undefined") {
        payload["messageId"] = messageId;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateSms(messageId, topics, users, targets, content, draft, scheduledAt) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/sms/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      if (typeof topics !== "undefined") {
        payload["topics"] = topics;
      }
      if (typeof users !== "undefined") {
        payload["users"] = users;
      }
      if (typeof targets !== "undefined") {
        payload["targets"] = targets;
      }
      if (typeof content !== "undefined") {
        payload["content"] = content;
      }
      if (typeof draft !== "undefined") {
        payload["draft"] = draft;
      }
      if (typeof scheduledAt !== "undefined") {
        payload["scheduledAt"] = scheduledAt;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getMessage(messageId) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async delete(messageId) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}".replace("{messageId}", messageId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listMessageLogs(messageId, queries) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}/logs".replace("{messageId}", messageId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listTargets(messageId, queries) {
      if (typeof messageId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "messageId"');
      }
      const apiPath = "/messaging/messages/{messageId}/targets".replace("{messageId}", messageId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listProviders(queries, search) {
      const apiPath = "/messaging/providers";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createApnsProvider(providerId, name, authKey, authKeyId, teamId, bundleId, sandbox, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/apns";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof authKeyId !== "undefined") {
        payload["authKeyId"] = authKeyId;
      }
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof bundleId !== "undefined") {
        payload["bundleId"] = bundleId;
      }
      if (typeof sandbox !== "undefined") {
        payload["sandbox"] = sandbox;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateApnsProvider(providerId, name, enabled, authKey, authKeyId, teamId, bundleId, sandbox) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/apns/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof authKeyId !== "undefined") {
        payload["authKeyId"] = authKeyId;
      }
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof bundleId !== "undefined") {
        payload["bundleId"] = bundleId;
      }
      if (typeof sandbox !== "undefined") {
        payload["sandbox"] = sandbox;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createFcmProvider(providerId, name, serviceAccountJSON, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/fcm";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof serviceAccountJSON !== "undefined") {
        payload["serviceAccountJSON"] = serviceAccountJSON;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateFcmProvider(providerId, name, enabled, serviceAccountJSON) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/fcm/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof serviceAccountJSON !== "undefined") {
        payload["serviceAccountJSON"] = serviceAccountJSON;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createMailgunProvider(providerId, name, apiKey, domain, isEuRegion, fromName, fromEmail, replyToName, replyToEmail, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/mailgun";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof domain !== "undefined") {
        payload["domain"] = domain;
      }
      if (typeof isEuRegion !== "undefined") {
        payload["isEuRegion"] = isEuRegion;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateMailgunProvider(providerId, name, apiKey, domain, isEuRegion, enabled, fromName, fromEmail, replyToName, replyToEmail) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/mailgun/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof domain !== "undefined") {
        payload["domain"] = domain;
      }
      if (typeof isEuRegion !== "undefined") {
        payload["isEuRegion"] = isEuRegion;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createMsg91Provider(providerId, name, templateId, senderId, authKey, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/msg91";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof templateId !== "undefined") {
        payload["templateId"] = templateId;
      }
      if (typeof senderId !== "undefined") {
        payload["senderId"] = senderId;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateMsg91Provider(providerId, name, enabled, templateId, senderId, authKey) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/msg91/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof templateId !== "undefined") {
        payload["templateId"] = templateId;
      }
      if (typeof senderId !== "undefined") {
        payload["senderId"] = senderId;
      }
      if (typeof authKey !== "undefined") {
        payload["authKey"] = authKey;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createSendgridProvider(providerId, name, apiKey, fromName, fromEmail, replyToName, replyToEmail, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/sendgrid";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateSendgridProvider(providerId, name, enabled, apiKey, fromName, fromEmail, replyToName, replyToEmail) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/sendgrid/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createSmtpProvider(providerId, name, host, port, username, password, encryption, autoTLS, mailer, fromName, fromEmail, replyToName, replyToEmail, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      if (typeof host === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "host"');
      }
      const apiPath = "/messaging/providers/smtp";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof host !== "undefined") {
        payload["host"] = host;
      }
      if (typeof port !== "undefined") {
        payload["port"] = port;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof autoTLS !== "undefined") {
        payload["autoTLS"] = autoTLS;
      }
      if (typeof mailer !== "undefined") {
        payload["mailer"] = mailer;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateSmtpProvider(providerId, name, host, port, username, password, encryption, autoTLS, mailer, fromName, fromEmail, replyToName, replyToEmail, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/smtp/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof host !== "undefined") {
        payload["host"] = host;
      }
      if (typeof port !== "undefined") {
        payload["port"] = port;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof autoTLS !== "undefined") {
        payload["autoTLS"] = autoTLS;
      }
      if (typeof mailer !== "undefined") {
        payload["mailer"] = mailer;
      }
      if (typeof fromName !== "undefined") {
        payload["fromName"] = fromName;
      }
      if (typeof fromEmail !== "undefined") {
        payload["fromEmail"] = fromEmail;
      }
      if (typeof replyToName !== "undefined") {
        payload["replyToName"] = replyToName;
      }
      if (typeof replyToEmail !== "undefined") {
        payload["replyToEmail"] = replyToEmail;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createTelesignProvider(providerId, name, from, customerId, apiKey, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/telesign";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof customerId !== "undefined") {
        payload["customerId"] = customerId;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateTelesignProvider(providerId, name, enabled, customerId, apiKey, from) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/telesign/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof customerId !== "undefined") {
        payload["customerId"] = customerId;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createTextmagicProvider(providerId, name, from, username, apiKey, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/textmagic";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateTextmagicProvider(providerId, name, enabled, username, apiKey, from) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/textmagic/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof username !== "undefined") {
        payload["username"] = username;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createTwilioProvider(providerId, name, from, accountSid, authToken, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/twilio";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof accountSid !== "undefined") {
        payload["accountSid"] = accountSid;
      }
      if (typeof authToken !== "undefined") {
        payload["authToken"] = authToken;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateTwilioProvider(providerId, name, enabled, accountSid, authToken, from) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/twilio/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof accountSid !== "undefined") {
        payload["accountSid"] = accountSid;
      }
      if (typeof authToken !== "undefined") {
        payload["authToken"] = authToken;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createVonageProvider(providerId, name, from, apiKey, apiSecret, enabled) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/providers/vonage";
      const payload = {};
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof apiSecret !== "undefined") {
        payload["apiSecret"] = apiSecret;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateVonageProvider(providerId, name, enabled, apiKey, apiSecret, from) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/vonage/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof apiKey !== "undefined") {
        payload["apiKey"] = apiKey;
      }
      if (typeof apiSecret !== "undefined") {
        payload["apiSecret"] = apiSecret;
      }
      if (typeof from !== "undefined") {
        payload["from"] = from;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getProvider(providerId) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteProvider(providerId) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/{providerId}".replace("{providerId}", providerId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listProviderLogs(providerId, queries) {
      if (typeof providerId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerId"');
      }
      const apiPath = "/messaging/providers/{providerId}/logs".replace("{providerId}", providerId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listSubscriberLogs(subscriberId, queries) {
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      const apiPath = "/messaging/subscribers/{subscriberId}/logs".replace("{subscriberId}", subscriberId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listTopics(queries, search) {
      const apiPath = "/messaging/topics";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createTopic(topicId, name, subscribe) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/messaging/topics";
      const payload = {};
      if (typeof topicId !== "undefined") {
        payload["topicId"] = topicId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof subscribe !== "undefined") {
        payload["subscribe"] = subscribe;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getTopic(topicId) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateTopic(topicId, name, subscribe) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof subscribe !== "undefined") {
        payload["subscribe"] = subscribe;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteTopic(topicId) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}".replace("{topicId}", topicId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listTopicLogs(topicId, queries) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}/logs".replace("{topicId}", topicId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listSubscribers(topicId, queries, search) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers".replace("{topicId}", topicId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createSubscriber(topicId, subscriberId, targetId) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers".replace("{topicId}", topicId);
      const payload = {};
      if (typeof subscriberId !== "undefined") {
        payload["subscriberId"] = subscriberId;
      }
      if (typeof targetId !== "undefined") {
        payload["targetId"] = targetId;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getSubscriber(topicId, subscriberId) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers/{subscriberId}".replace("{topicId}", topicId).replace("{subscriberId}", subscriberId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteSubscriber(topicId, subscriberId) {
      if (typeof topicId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "topicId"');
      }
      if (typeof subscriberId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "subscriberId"');
      }
      const apiPath = "/messaging/topics/{topicId}/subscribers/{subscriberId}".replace("{topicId}", topicId).replace("{subscriberId}", subscriberId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
  }
  exports.Messaging = Messaging;
});

// node_modules/node-appwrite/dist/services/storage.js
var require_storage = __commonJS((exports) => {
  var client = require_client();

  class Storage {
    constructor(client2) {
      this.client = client2;
    }
    async listBuckets(queries, search) {
      const apiPath = "/storage/buckets";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/storage/buckets";
      const payload = {};
      if (typeof bucketId !== "undefined") {
        payload["bucketId"] = bucketId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof fileSecurity !== "undefined") {
        payload["fileSecurity"] = fileSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof maximumFileSize !== "undefined") {
        payload["maximumFileSize"] = maximumFileSize;
      }
      if (typeof allowedFileExtensions !== "undefined") {
        payload["allowedFileExtensions"] = allowedFileExtensions;
      }
      if (typeof compression !== "undefined") {
        payload["compression"] = compression;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof antivirus !== "undefined") {
        payload["antivirus"] = antivirus;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getBucket(bucketId) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateBucket(bucketId, name, permissions, fileSecurity, enabled, maximumFileSize, allowedFileExtensions, compression, encryption, antivirus) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      if (typeof fileSecurity !== "undefined") {
        payload["fileSecurity"] = fileSecurity;
      }
      if (typeof enabled !== "undefined") {
        payload["enabled"] = enabled;
      }
      if (typeof maximumFileSize !== "undefined") {
        payload["maximumFileSize"] = maximumFileSize;
      }
      if (typeof allowedFileExtensions !== "undefined") {
        payload["allowedFileExtensions"] = allowedFileExtensions;
      }
      if (typeof compression !== "undefined") {
        payload["compression"] = compression;
      }
      if (typeof encryption !== "undefined") {
        payload["encryption"] = encryption;
      }
      if (typeof antivirus !== "undefined") {
        payload["antivirus"] = antivirus;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async deleteBucket(bucketId) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      const apiPath = "/storage/buckets/{bucketId}".replace("{bucketId}", bucketId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listFiles(bucketId, queries, search) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createFile(bucketId, fileId, file, permissions, onProgress = (progress) => {
    }) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      if (typeof file === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "file"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files".replace("{bucketId}", bucketId);
      const payload = {};
      if (typeof fileId !== "undefined") {
        payload["fileId"] = fileId;
      }
      if (typeof file !== "undefined") {
        payload["file"] = file;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "multipart/form-data"
      };
      return await this.client.chunkedUpload("post", uri, apiHeaders, payload, onProgress);
    }
    async getFile(bucketId, fileId) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateFile(bucketId, fileId, name, permissions) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof permissions !== "undefined") {
        payload["permissions"] = permissions;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async deleteFile(bucketId, fileId) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async getFileDownload(bucketId, fileId) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/download".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getFilePreview(bucketId, fileId, width, height, gravity, quality, borderWidth, borderColor, borderRadius, opacity, rotation, background, output) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/preview".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      if (typeof width !== "undefined") {
        payload["width"] = width;
      }
      if (typeof height !== "undefined") {
        payload["height"] = height;
      }
      if (typeof gravity !== "undefined") {
        payload["gravity"] = gravity;
      }
      if (typeof quality !== "undefined") {
        payload["quality"] = quality;
      }
      if (typeof borderWidth !== "undefined") {
        payload["borderWidth"] = borderWidth;
      }
      if (typeof borderColor !== "undefined") {
        payload["borderColor"] = borderColor;
      }
      if (typeof borderRadius !== "undefined") {
        payload["borderRadius"] = borderRadius;
      }
      if (typeof opacity !== "undefined") {
        payload["opacity"] = opacity;
      }
      if (typeof rotation !== "undefined") {
        payload["rotation"] = rotation;
      }
      if (typeof background !== "undefined") {
        payload["background"] = background;
      }
      if (typeof output !== "undefined") {
        payload["output"] = output;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
    async getFileView(bucketId, fileId) {
      if (typeof bucketId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "bucketId"');
      }
      if (typeof fileId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "fileId"');
      }
      const apiPath = "/storage/buckets/{bucketId}/files/{fileId}/view".replace("{bucketId}", bucketId).replace("{fileId}", fileId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload, "arrayBuffer");
    }
  }
  exports.Storage = Storage;
});

// node_modules/node-appwrite/dist/services/teams.js
var require_teams = __commonJS((exports) => {
  var client = require_client();

  class Teams {
    constructor(client2) {
      this.client = client2;
    }
    async list(queries, search) {
      const apiPath = "/teams";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async create(teamId, name, roles) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/teams";
      const payload = {};
      if (typeof teamId !== "undefined") {
        payload["teamId"] = teamId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async get(teamId) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateName(teamId, name) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async delete(teamId) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}".replace("{teamId}", teamId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listMemberships(teamId, queries, search) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createMembership(teamId, roles, email, userId, phone, url, name) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof roles === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "roles"');
      }
      const apiPath = "/teams/{teamId}/memberships".replace("{teamId}", teamId);
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      if (typeof url !== "undefined") {
        payload["url"] = url;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getMembership(teamId, membershipId) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateMembership(teamId, membershipId, roles) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      if (typeof roles === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "roles"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      if (typeof roles !== "undefined") {
        payload["roles"] = roles;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteMembership(teamId, membershipId) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async updateMembershipStatus(teamId, membershipId, userId, secret) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof membershipId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "membershipId"');
      }
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof secret === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "secret"');
      }
      const apiPath = "/teams/{teamId}/memberships/{membershipId}/status".replace("{teamId}", teamId).replace("{membershipId}", membershipId);
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof secret !== "undefined") {
        payload["secret"] = secret;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getPrefs(teamId) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      const apiPath = "/teams/{teamId}/prefs".replace("{teamId}", teamId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updatePrefs(teamId, prefs) {
      if (typeof teamId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "teamId"');
      }
      if (typeof prefs === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "prefs"');
      }
      const apiPath = "/teams/{teamId}/prefs".replace("{teamId}", teamId);
      const payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
  }
  exports.Teams = Teams;
});

// node_modules/node-appwrite/dist/services/users.js
var require_users = __commonJS((exports) => {
  var client = require_client();

  class Users {
    constructor(client2) {
      this.client = client2;
    }
    async list(queries, search) {
      const apiPath = "/users";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async create(userId, email, phone, password, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof phone !== "undefined") {
        payload["phone"] = phone;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createArgon2User(userId, email, password, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/argon2";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createBcryptUser(userId, email, password, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/bcrypt";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async listIdentities(queries, search) {
      const apiPath = "/users/identities";
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      if (typeof search !== "undefined") {
        payload["search"] = search;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async deleteIdentity(identityId) {
      if (typeof identityId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "identityId"');
      }
      const apiPath = "/users/identities/{identityId}".replace("{identityId}", identityId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async createMD5User(userId, email, password, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/md5";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createPHPassUser(userId, email, password, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/phpass";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createScryptUser(userId, email, password, passwordSalt, passwordCpu, passwordMemory, passwordParallel, passwordLength, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      if (typeof passwordSalt === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSalt"');
      }
      if (typeof passwordCpu === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordCpu"');
      }
      if (typeof passwordMemory === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordMemory"');
      }
      if (typeof passwordParallel === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordParallel"');
      }
      if (typeof passwordLength === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordLength"');
      }
      const apiPath = "/users/scrypt";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordSalt !== "undefined") {
        payload["passwordSalt"] = passwordSalt;
      }
      if (typeof passwordCpu !== "undefined") {
        payload["passwordCpu"] = passwordCpu;
      }
      if (typeof passwordMemory !== "undefined") {
        payload["passwordMemory"] = passwordMemory;
      }
      if (typeof passwordParallel !== "undefined") {
        payload["passwordParallel"] = passwordParallel;
      }
      if (typeof passwordLength !== "undefined") {
        payload["passwordLength"] = passwordLength;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createScryptModifiedUser(userId, email, password, passwordSalt, passwordSaltSeparator, passwordSignerKey, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      if (typeof passwordSalt === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSalt"');
      }
      if (typeof passwordSaltSeparator === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSaltSeparator"');
      }
      if (typeof passwordSignerKey === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "passwordSignerKey"');
      }
      const apiPath = "/users/scrypt-modified";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordSalt !== "undefined") {
        payload["passwordSalt"] = passwordSalt;
      }
      if (typeof passwordSaltSeparator !== "undefined") {
        payload["passwordSaltSeparator"] = passwordSaltSeparator;
      }
      if (typeof passwordSignerKey !== "undefined") {
        payload["passwordSignerKey"] = passwordSignerKey;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async createSHAUser(userId, email, password, passwordVersion, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/sha";
      const payload = {};
      if (typeof userId !== "undefined") {
        payload["userId"] = userId;
      }
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      if (typeof passwordVersion !== "undefined") {
        payload["passwordVersion"] = passwordVersion;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async get(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async delete(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async updateEmail(userId, email) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof email === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "email"');
      }
      const apiPath = "/users/{userId}/email".replace("{userId}", userId);
      const payload = {};
      if (typeof email !== "undefined") {
        payload["email"] = email;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async createJWT(userId, sessionId, duration) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/jwts".replace("{userId}", userId);
      const payload = {};
      if (typeof sessionId !== "undefined") {
        payload["sessionId"] = sessionId;
      }
      if (typeof duration !== "undefined") {
        payload["duration"] = duration;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateLabels(userId, labels) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof labels === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "labels"');
      }
      const apiPath = "/users/{userId}/labels".replace("{userId}", userId);
      const payload = {};
      if (typeof labels !== "undefined") {
        payload["labels"] = labels;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async listLogs(userId, queries) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/logs".replace("{userId}", userId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async listMemberships(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/memberships".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateMfa(userId, mfa) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof mfa === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "mfa"');
      }
      const apiPath = "/users/{userId}/mfa".replace("{userId}", userId);
      const payload = {};
      if (typeof mfa !== "undefined") {
        payload["mfa"] = mfa;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteMfaAuthenticator(userId, type3) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof type3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "type"');
      }
      const apiPath = "/users/{userId}/mfa/authenticators/{type}".replace("{userId}", userId).replace("{type}", type3);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async listMfaFactors(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/factors".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async getMfaRecoveryCodes(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateMfaRecoveryCodes(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("put", uri, apiHeaders, payload);
    }
    async createMfaRecoveryCodes(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/mfa/recovery-codes".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updateName(userId, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof name === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "name"');
      }
      const apiPath = "/users/{userId}/name".replace("{userId}", userId);
      const payload = {};
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updatePassword(userId, password) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof password === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "password"');
      }
      const apiPath = "/users/{userId}/password".replace("{userId}", userId);
      const payload = {};
      if (typeof password !== "undefined") {
        payload["password"] = password;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updatePhone(userId, number3) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof number3 === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "number"');
      }
      const apiPath = "/users/{userId}/phone".replace("{userId}", userId);
      const payload = {};
      if (typeof number3 !== "undefined") {
        payload["number"] = number3;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async getPrefs(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/prefs".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updatePrefs(userId, prefs) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof prefs === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "prefs"');
      }
      const apiPath = "/users/{userId}/prefs".replace("{userId}", userId);
      const payload = {};
      if (typeof prefs !== "undefined") {
        payload["prefs"] = prefs;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async listSessions(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createSession(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async deleteSessions(userId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/sessions".replace("{userId}", userId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async deleteSession(userId, sessionId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof sessionId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "sessionId"');
      }
      const apiPath = "/users/{userId}/sessions/{sessionId}".replace("{userId}", userId).replace("{sessionId}", sessionId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async updateStatus(userId, status) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof status === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "status"');
      }
      const apiPath = "/users/{userId}/status".replace("{userId}", userId);
      const payload = {};
      if (typeof status !== "undefined") {
        payload["status"] = status;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async listTargets(userId, queries) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/targets".replace("{userId}", userId);
      const payload = {};
      if (typeof queries !== "undefined") {
        payload["queries"] = queries;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async createTarget(userId, targetId, providerType, identifier, providerId, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      if (typeof providerType === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "providerType"');
      }
      if (typeof identifier === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "identifier"');
      }
      const apiPath = "/users/{userId}/targets".replace("{userId}", userId);
      const payload = {};
      if (typeof targetId !== "undefined") {
        payload["targetId"] = targetId;
      }
      if (typeof providerType !== "undefined") {
        payload["providerType"] = providerType;
      }
      if (typeof identifier !== "undefined") {
        payload["identifier"] = identifier;
      }
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async getTarget(userId, targetId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("get", uri, apiHeaders, payload);
    }
    async updateTarget(userId, targetId, identifier, providerId, name) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
      const payload = {};
      if (typeof identifier !== "undefined") {
        payload["identifier"] = identifier;
      }
      if (typeof providerId !== "undefined") {
        payload["providerId"] = providerId;
      }
      if (typeof name !== "undefined") {
        payload["name"] = name;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async deleteTarget(userId, targetId) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof targetId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "targetId"');
      }
      const apiPath = "/users/{userId}/targets/{targetId}".replace("{userId}", userId).replace("{targetId}", targetId);
      const payload = {};
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("delete", uri, apiHeaders, payload);
    }
    async createToken(userId, length, expire) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      const apiPath = "/users/{userId}/tokens".replace("{userId}", userId);
      const payload = {};
      if (typeof length !== "undefined") {
        payload["length"] = length;
      }
      if (typeof expire !== "undefined") {
        payload["expire"] = expire;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("post", uri, apiHeaders, payload);
    }
    async updateEmailVerification(userId, emailVerification) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof emailVerification === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "emailVerification"');
      }
      const apiPath = "/users/{userId}/verification".replace("{userId}", userId);
      const payload = {};
      if (typeof emailVerification !== "undefined") {
        payload["emailVerification"] = emailVerification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
    async updatePhoneVerification(userId, phoneVerification) {
      if (typeof userId === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "userId"');
      }
      if (typeof phoneVerification === "undefined") {
        throw new client.AppwriteException('Missing required parameter: "phoneVerification"');
      }
      const apiPath = "/users/{userId}/verification/phone".replace("{userId}", userId);
      const payload = {};
      if (typeof phoneVerification !== "undefined") {
        payload["phoneVerification"] = phoneVerification;
      }
      const uri = new URL(this.client.config.endpoint + apiPath);
      const apiHeaders = {
        "content-type": "application/json"
      };
      return await this.client.call("patch", uri, apiHeaders, payload);
    }
  }
  exports.Users = Users;
});

// node_modules/node-appwrite/dist/permission.js
var require_permission = __commonJS((exports) => {
  class Permission {
  }
  Permission.read = (role) => {
    return `read("${role}")`;
  };
  Permission.write = (role) => {
    return `write("${role}")`;
  };
  Permission.create = (role) => {
    return `create("${role}")`;
  };
  Permission.update = (role) => {
    return `update("${role}")`;
  };
  Permission.delete = (role) => {
    return `delete("${role}")`;
  };
  exports.Permission = Permission;
});

// node_modules/node-appwrite/dist/role.js
var require_role = __commonJS((exports) => {
  class Role {
    static any() {
      return "any";
    }
    static user(id, status = "") {
      if (status === "") {
        return `user:${id}`;
      }
      return `user:${id}/${status}`;
    }
    static users(status = "") {
      if (status === "") {
        return "users";
      }
      return `users/${status}`;
    }
    static guests() {
      return "guests";
    }
    static team(id, role = "") {
      if (role === "") {
        return `team:${id}`;
      }
      return `team:${id}/${role}`;
    }
    static member(id) {
      return `member:${id}`;
    }
    static label(name) {
      return `label:${name}`;
    }
  }
  exports.Role = Role;
});

// node_modules/node-appwrite/dist/id.js
var require_id = __commonJS((exports) => {
  class ID {
    static #hexTimestamp() {
      const now = /* @__PURE__ */ new Date;
      const sec = Math.floor(now.getTime() / 1000);
      const msec = now.getMilliseconds();
      const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, "0");
      return hexTimestamp;
    }
    static custom(id) {
      return id;
    }
    static unique(padding = 7) {
      const baseId = ID.#hexTimestamp();
      let randomPadding = "";
      for (let i4 = 0;i4 < padding; i4++) {
        const randomHexDigit = Math.floor(Math.random() * 16).toString(16);
        randomPadding += randomHexDigit;
      }
      return baseId + randomPadding;
    }
  }
  exports.ID = ID;
});

// node_modules/node-appwrite/dist/enums/authenticator-type.js
var require_authenticator_type = __commonJS((exports) => {
  var AuthenticatorType = /* @__PURE__ */ ((AuthenticatorType2) => {
    AuthenticatorType2["Totp"] = "totp";
    return AuthenticatorType2;
  })(AuthenticatorType || {});
  exports.AuthenticatorType = AuthenticatorType;
});

// node_modules/node-appwrite/dist/enums/authentication-factor.js
var require_authentication_factor = __commonJS((exports) => {
  var AuthenticationFactor = /* @__PURE__ */ ((AuthenticationFactor2) => {
    AuthenticationFactor2["Email"] = "email";
    AuthenticationFactor2["Phone"] = "phone";
    AuthenticationFactor2["Totp"] = "totp";
    AuthenticationFactor2["Recoverycode"] = "recoverycode";
    return AuthenticationFactor2;
  })(AuthenticationFactor || {});
  exports.AuthenticationFactor = AuthenticationFactor;
});

// node_modules/node-appwrite/dist/enums/o-auth-provider.js
var require_o_auth_provider = __commonJS((exports) => {
  var OAuthProvider = /* @__PURE__ */ ((OAuthProvider2) => {
    OAuthProvider2["Amazon"] = "amazon";
    OAuthProvider2["Apple"] = "apple";
    OAuthProvider2["Auth0"] = "auth0";
    OAuthProvider2["Authentik"] = "authentik";
    OAuthProvider2["Autodesk"] = "autodesk";
    OAuthProvider2["Bitbucket"] = "bitbucket";
    OAuthProvider2["Bitly"] = "bitly";
    OAuthProvider2["Box"] = "box";
    OAuthProvider2["Dailymotion"] = "dailymotion";
    OAuthProvider2["Discord"] = "discord";
    OAuthProvider2["Disqus"] = "disqus";
    OAuthProvider2["Dropbox"] = "dropbox";
    OAuthProvider2["Etsy"] = "etsy";
    OAuthProvider2["Facebook"] = "facebook";
    OAuthProvider2["Github"] = "github";
    OAuthProvider2["Gitlab"] = "gitlab";
    OAuthProvider2["Google"] = "google";
    OAuthProvider2["Linkedin"] = "linkedin";
    OAuthProvider2["Microsoft"] = "microsoft";
    OAuthProvider2["Notion"] = "notion";
    OAuthProvider2["Oidc"] = "oidc";
    OAuthProvider2["Okta"] = "okta";
    OAuthProvider2["Paypal"] = "paypal";
    OAuthProvider2["PaypalSandbox"] = "paypalSandbox";
    OAuthProvider2["Podio"] = "podio";
    OAuthProvider2["Salesforce"] = "salesforce";
    OAuthProvider2["Slack"] = "slack";
    OAuthProvider2["Spotify"] = "spotify";
    OAuthProvider2["Stripe"] = "stripe";
    OAuthProvider2["Tradeshift"] = "tradeshift";
    OAuthProvider2["TradeshiftBox"] = "tradeshiftBox";
    OAuthProvider2["Twitch"] = "twitch";
    OAuthProvider2["Wordpress"] = "wordpress";
    OAuthProvider2["Yahoo"] = "yahoo";
    OAuthProvider2["Yammer"] = "yammer";
    OAuthProvider2["Yandex"] = "yandex";
    OAuthProvider2["Zoho"] = "zoho";
    OAuthProvider2["Zoom"] = "zoom";
    OAuthProvider2["Mock"] = "mock";
    return OAuthProvider2;
  })(OAuthProvider || {});
  exports.OAuthProvider = OAuthProvider;
});

// node_modules/node-appwrite/dist/enums/browser.js
var require_browser = __commonJS((exports) => {
  var Browser = /* @__PURE__ */ ((Browser2) => {
    Browser2["AvantBrowser"] = "aa";
    Browser2["AndroidWebViewBeta"] = "an";
    Browser2["GoogleChrome"] = "ch";
    Browser2["GoogleChromeIOS"] = "ci";
    Browser2["GoogleChromeMobile"] = "cm";
    Browser2["Chromium"] = "cr";
    Browser2["MozillaFirefox"] = "ff";
    Browser2["Safari"] = "sf";
    Browser2["MobileSafari"] = "mf";
    Browser2["MicrosoftEdge"] = "ps";
    Browser2["MicrosoftEdgeIOS"] = "oi";
    Browser2["OperaMini"] = "om";
    Browser2["Opera"] = "op";
    Browser2["OperaNext"] = "on";
    return Browser2;
  })(Browser || {});
  exports.Browser = Browser;
});

// node_modules/node-appwrite/dist/enums/credit-card.js
var require_credit_card = __commonJS((exports) => {
  var CreditCard = /* @__PURE__ */ ((CreditCard2) => {
    CreditCard2["AmericanExpress"] = "amex";
    CreditCard2["Argencard"] = "argencard";
    CreditCard2["Cabal"] = "cabal";
    CreditCard2["Cencosud"] = "cencosud";
    CreditCard2["DinersClub"] = "diners";
    CreditCard2["Discover"] = "discover";
    CreditCard2["Elo"] = "elo";
    CreditCard2["Hipercard"] = "hipercard";
    CreditCard2["JCB"] = "jcb";
    CreditCard2["Mastercard"] = "mastercard";
    CreditCard2["Naranja"] = "naranja";
    CreditCard2["TarjetaShopping"] = "targeta-shopping";
    CreditCard2["UnionChinaPay"] = "union-china-pay";
    CreditCard2["Visa"] = "visa";
    CreditCard2["MIR"] = "mir";
    CreditCard2["Maestro"] = "maestro";
    return CreditCard2;
  })(CreditCard || {});
  exports.CreditCard = CreditCard;
});

// node_modules/node-appwrite/dist/enums/flag.js
var require_flag = __commonJS((exports) => {
  var Flag = /* @__PURE__ */ ((Flag2) => {
    Flag2["Afghanistan"] = "af";
    Flag2["Angola"] = "ao";
    Flag2["Albania"] = "al";
    Flag2["Andorra"] = "ad";
    Flag2["UnitedArabEmirates"] = "ae";
    Flag2["Argentina"] = "ar";
    Flag2["Armenia"] = "am";
    Flag2["AntiguaAndBarbuda"] = "ag";
    Flag2["Australia"] = "au";
    Flag2["Austria"] = "at";
    Flag2["Azerbaijan"] = "az";
    Flag2["Burundi"] = "bi";
    Flag2["Belgium"] = "be";
    Flag2["Benin"] = "bj";
    Flag2["BurkinaFaso"] = "bf";
    Flag2["Bangladesh"] = "bd";
    Flag2["Bulgaria"] = "bg";
    Flag2["Bahrain"] = "bh";
    Flag2["Bahamas"] = "bs";
    Flag2["BosniaAndHerzegovina"] = "ba";
    Flag2["Belarus"] = "by";
    Flag2["Belize"] = "bz";
    Flag2["Bolivia"] = "bo";
    Flag2["Brazil"] = "br";
    Flag2["Barbados"] = "bb";
    Flag2["BruneiDarussalam"] = "bn";
    Flag2["Bhutan"] = "bt";
    Flag2["Botswana"] = "bw";
    Flag2["CentralAfricanRepublic"] = "cf";
    Flag2["Canada"] = "ca";
    Flag2["Switzerland"] = "ch";
    Flag2["Chile"] = "cl";
    Flag2["China"] = "cn";
    Flag2["CoteDIvoire"] = "ci";
    Flag2["Cameroon"] = "cm";
    Flag2["DemocraticRepublicOfTheCongo"] = "cd";
    Flag2["RepublicOfTheCongo"] = "cg";
    Flag2["Colombia"] = "co";
    Flag2["Comoros"] = "km";
    Flag2["CapeVerde"] = "cv";
    Flag2["CostaRica"] = "cr";
    Flag2["Cuba"] = "cu";
    Flag2["Cyprus"] = "cy";
    Flag2["CzechRepublic"] = "cz";
    Flag2["Germany"] = "de";
    Flag2["Djibouti"] = "dj";
    Flag2["Dominica"] = "dm";
    Flag2["Denmark"] = "dk";
    Flag2["DominicanRepublic"] = "do";
    Flag2["Algeria"] = "dz";
    Flag2["Ecuador"] = "ec";
    Flag2["Egypt"] = "eg";
    Flag2["Eritrea"] = "er";
    Flag2["Spain"] = "es";
    Flag2["Estonia"] = "ee";
    Flag2["Ethiopia"] = "et";
    Flag2["Finland"] = "fi";
    Flag2["Fiji"] = "fj";
    Flag2["France"] = "fr";
    Flag2["MicronesiaFederatedStatesOf"] = "fm";
    Flag2["Gabon"] = "ga";
    Flag2["UnitedKingdom"] = "gb";
    Flag2["Georgia"] = "ge";
    Flag2["Ghana"] = "gh";
    Flag2["Guinea"] = "gn";
    Flag2["Gambia"] = "gm";
    Flag2["GuineaBissau"] = "gw";
    Flag2["EquatorialGuinea"] = "gq";
    Flag2["Greece"] = "gr";
    Flag2["Grenada"] = "gd";
    Flag2["Guatemala"] = "gt";
    Flag2["Guyana"] = "gy";
    Flag2["Honduras"] = "hn";
    Flag2["Croatia"] = "hr";
    Flag2["Haiti"] = "ht";
    Flag2["Hungary"] = "hu";
    Flag2["Indonesia"] = "id";
    Flag2["India"] = "in";
    Flag2["Ireland"] = "ie";
    Flag2["IranIslamicRepublicOf"] = "ir";
    Flag2["Iraq"] = "iq";
    Flag2["Iceland"] = "is";
    Flag2["Israel"] = "il";
    Flag2["Italy"] = "it";
    Flag2["Jamaica"] = "jm";
    Flag2["Jordan"] = "jo";
    Flag2["Japan"] = "jp";
    Flag2["Kazakhstan"] = "kz";
    Flag2["Kenya"] = "ke";
    Flag2["Kyrgyzstan"] = "kg";
    Flag2["Cambodia"] = "kh";
    Flag2["Kiribati"] = "ki";
    Flag2["SaintKittsAndNevis"] = "kn";
    Flag2["SouthKorea"] = "kr";
    Flag2["Kuwait"] = "kw";
    Flag2["LaoPeopleSDemocraticRepublic"] = "la";
    Flag2["Lebanon"] = "lb";
    Flag2["Liberia"] = "lr";
    Flag2["Libya"] = "ly";
    Flag2["SaintLucia"] = "lc";
    Flag2["Liechtenstein"] = "li";
    Flag2["SriLanka"] = "lk";
    Flag2["Lesotho"] = "ls";
    Flag2["Lithuania"] = "lt";
    Flag2["Luxembourg"] = "lu";
    Flag2["Latvia"] = "lv";
    Flag2["Morocco"] = "ma";
    Flag2["Monaco"] = "mc";
    Flag2["Moldova"] = "md";
    Flag2["Madagascar"] = "mg";
    Flag2["Maldives"] = "mv";
    Flag2["Mexico"] = "mx";
    Flag2["MarshallIslands"] = "mh";
    Flag2["NorthMacedonia"] = "mk";
    Flag2["Mali"] = "ml";
    Flag2["Malta"] = "mt";
    Flag2["Myanmar"] = "mm";
    Flag2["Montenegro"] = "me";
    Flag2["Mongolia"] = "mn";
    Flag2["Mozambique"] = "mz";
    Flag2["Mauritania"] = "mr";
    Flag2["Mauritius"] = "mu";
    Flag2["Malawi"] = "mw";
    Flag2["Malaysia"] = "my";
    Flag2["Namibia"] = "na";
    Flag2["Niger"] = "ne";
    Flag2["Nigeria"] = "ng";
    Flag2["Nicaragua"] = "ni";
    Flag2["Netherlands"] = "nl";
    Flag2["Norway"] = "no";
    Flag2["Nepal"] = "np";
    Flag2["Nauru"] = "nr";
    Flag2["NewZealand"] = "nz";
    Flag2["Oman"] = "om";
    Flag2["Pakistan"] = "pk";
    Flag2["Panama"] = "pa";
    Flag2["Peru"] = "pe";
    Flag2["Philippines"] = "ph";
    Flag2["Palau"] = "pw";
    Flag2["PapuaNewGuinea"] = "pg";
    Flag2["Poland"] = "pl";
    Flag2["FrenchPolynesia"] = "pf";
    Flag2["NorthKorea"] = "kp";
    Flag2["Portugal"] = "pt";
    Flag2["Paraguay"] = "py";
    Flag2["Qatar"] = "qa";
    Flag2["Romania"] = "ro";
    Flag2["Russia"] = "ru";
    Flag2["Rwanda"] = "rw";
    Flag2["SaudiArabia"] = "sa";
    Flag2["Sudan"] = "sd";
    Flag2["Senegal"] = "sn";
    Flag2["Singapore"] = "sg";
    Flag2["SolomonIslands"] = "sb";
    Flag2["SierraLeone"] = "sl";
    Flag2["ElSalvador"] = "sv";
    Flag2["SanMarino"] = "sm";
    Flag2["Somalia"] = "so";
    Flag2["Serbia"] = "rs";
    Flag2["SouthSudan"] = "ss";
    Flag2["SaoTomeAndPrincipe"] = "st";
    Flag2["Suriname"] = "sr";
    Flag2["Slovakia"] = "sk";
    Flag2["Slovenia"] = "si";
    Flag2["Sweden"] = "se";
    Flag2["Eswatini"] = "sz";
    Flag2["Seychelles"] = "sc";
    Flag2["Syria"] = "sy";
    Flag2["Chad"] = "td";
    Flag2["Togo"] = "tg";
    Flag2["Thailand"] = "th";
    Flag2["Tajikistan"] = "tj";
    Flag2["Turkmenistan"] = "tm";
    Flag2["TimorLeste"] = "tl";
    Flag2["Tonga"] = "to";
    Flag2["TrinidadAndTobago"] = "tt";
    Flag2["Tunisia"] = "tn";
    Flag2["Turkey"] = "tr";
    Flag2["Tuvalu"] = "tv";
    Flag2["Tanzania"] = "tz";
    Flag2["Uganda"] = "ug";
    Flag2["Ukraine"] = "ua";
    Flag2["Uruguay"] = "uy";
    Flag2["UnitedStates"] = "us";
    Flag2["Uzbekistan"] = "uz";
    Flag2["VaticanCity"] = "va";
    Flag2["SaintVincentAndTheGrenadines"] = "vc";
    Flag2["Venezuela"] = "ve";
    Flag2["Vietnam"] = "vn";
    Flag2["Vanuatu"] = "vu";
    Flag2["Samoa"] = "ws";
    Flag2["Yemen"] = "ye";
    Flag2["SouthAfrica"] = "za";
    Flag2["Zambia"] = "zm";
    Flag2["Zimbabwe"] = "zw";
    return Flag2;
  })(Flag || {});
  exports.Flag = Flag;
});

// node_modules/node-appwrite/dist/enums/relationship-type.js
var require_relationship_type = __commonJS((exports) => {
  var RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {
    RelationshipType2["OneToOne"] = "oneToOne";
    RelationshipType2["ManyToOne"] = "manyToOne";
    RelationshipType2["ManyToMany"] = "manyToMany";
    RelationshipType2["OneToMany"] = "oneToMany";
    return RelationshipType2;
  })(RelationshipType || {});
  exports.RelationshipType = RelationshipType;
});

// node_modules/node-appwrite/dist/enums/relation-mutate.js
var require_relation_mutate = __commonJS((exports) => {
  var RelationMutate = /* @__PURE__ */ ((RelationMutate2) => {
    RelationMutate2["Cascade"] = "cascade";
    RelationMutate2["Restrict"] = "restrict";
    RelationMutate2["SetNull"] = "setNull";
    return RelationMutate2;
  })(RelationMutate || {});
  exports.RelationMutate = RelationMutate;
});

// node_modules/node-appwrite/dist/enums/index-type.js
var require_index_type = __commonJS((exports) => {
  var IndexType = /* @__PURE__ */ ((IndexType2) => {
    IndexType2["Key"] = "key";
    IndexType2["Fulltext"] = "fulltext";
    IndexType2["Unique"] = "unique";
    return IndexType2;
  })(IndexType || {});
  exports.IndexType = IndexType;
});

// node_modules/node-appwrite/dist/enums/runtime.js
var require_runtime = __commonJS((exports) => {
  var Runtime = /* @__PURE__ */ ((Runtime2) => {
    Runtime2["Node145"] = "node-14.5";
    Runtime2["Node160"] = "node-16.0";
    Runtime2["Node180"] = "node-18.0";
    Runtime2["Node190"] = "node-19.0";
    Runtime2["Node200"] = "node-20.0";
    Runtime2["Node210"] = "node-21.0";
    Runtime2["Php80"] = "php-8.0";
    Runtime2["Php81"] = "php-8.1";
    Runtime2["Php82"] = "php-8.2";
    Runtime2["Php83"] = "php-8.3";
    Runtime2["Ruby30"] = "ruby-3.0";
    Runtime2["Ruby31"] = "ruby-3.1";
    Runtime2["Ruby32"] = "ruby-3.2";
    Runtime2["Ruby33"] = "ruby-3.3";
    Runtime2["Python38"] = "python-3.8";
    Runtime2["Python39"] = "python-3.9";
    Runtime2["Python310"] = "python-3.10";
    Runtime2["Python311"] = "python-3.11";
    Runtime2["Python312"] = "python-3.12";
    Runtime2["Pythonml311"] = "python-ml-3.11";
    Runtime2["Deno140"] = "deno-1.40";
    Runtime2["Dart215"] = "dart-2.15";
    Runtime2["Dart216"] = "dart-2.16";
    Runtime2["Dart217"] = "dart-2.17";
    Runtime2["Dart218"] = "dart-2.18";
    Runtime2["Dart30"] = "dart-3.0";
    Runtime2["Dart31"] = "dart-3.1";
    Runtime2["Dart33"] = "dart-3.3";
    Runtime2["Dotnet31"] = "dotnet-3.1";
    Runtime2["Dotnet60"] = "dotnet-6.0";
    Runtime2["Dotnet70"] = "dotnet-7.0";
    Runtime2["Java80"] = "java-8.0";
    Runtime2["Java110"] = "java-11.0";
    Runtime2["Java170"] = "java-17.0";
    Runtime2["Java180"] = "java-18.0";
    Runtime2["Java210"] = "java-21.0";
    Runtime2["Swift55"] = "swift-5.5";
    Runtime2["Swift58"] = "swift-5.8";
    Runtime2["Swift59"] = "swift-5.9";
    Runtime2["Kotlin16"] = "kotlin-1.6";
    Runtime2["Kotlin18"] = "kotlin-1.8";
    Runtime2["Kotlin19"] = "kotlin-1.9";
    Runtime2["Cpp17"] = "cpp-17";
    Runtime2["Cpp20"] = "cpp-20";
    Runtime2["Bun10"] = "bun-1.0";
    Runtime2["Go123"] = "go-1.23";
    return Runtime2;
  })(Runtime || {});
  exports.Runtime = Runtime;
});

// node_modules/node-appwrite/dist/enums/execution-method.js
var require_execution_method = __commonJS((exports) => {
  var ExecutionMethod = /* @__PURE__ */ ((ExecutionMethod2) => {
    ExecutionMethod2["GET"] = "GET";
    ExecutionMethod2["POST"] = "POST";
    ExecutionMethod2["PUT"] = "PUT";
    ExecutionMethod2["PATCH"] = "PATCH";
    ExecutionMethod2["DELETE"] = "DELETE";
    ExecutionMethod2["OPTIONS"] = "OPTIONS";
    return ExecutionMethod2;
  })(ExecutionMethod || {});
  exports.ExecutionMethod = ExecutionMethod;
});

// node_modules/node-appwrite/dist/enums/name.js
var require_name = __commonJS((exports) => {
  var Name = /* @__PURE__ */ ((Name2) => {
    Name2["V1database"] = "v1-database";
    Name2["V1deletes"] = "v1-deletes";
    Name2["V1audits"] = "v1-audits";
    Name2["V1mails"] = "v1-mails";
    Name2["V1functions"] = "v1-functions";
    Name2["V1usage"] = "v1-usage";
    Name2["V1usagedump"] = "v1-usage-dump";
    Name2["V1webhooks"] = "v1-webhooks";
    Name2["V1certificates"] = "v1-certificates";
    Name2["V1builds"] = "v1-builds";
    Name2["V1messaging"] = "v1-messaging";
    Name2["V1migrations"] = "v1-migrations";
    return Name2;
  })(Name || {});
  exports.Name = Name;
});

// node_modules/node-appwrite/dist/enums/smtp-encryption.js
var require_smtp_encryption = __commonJS((exports) => {
  var SmtpEncryption = /* @__PURE__ */ ((SmtpEncryption2) => {
    SmtpEncryption2["None"] = "none";
    SmtpEncryption2["Ssl"] = "ssl";
    SmtpEncryption2["Tls"] = "tls";
    return SmtpEncryption2;
  })(SmtpEncryption || {});
  exports.SmtpEncryption = SmtpEncryption;
});

// node_modules/node-appwrite/dist/enums/compression.js
var require_compression = __commonJS((exports) => {
  var Compression = /* @__PURE__ */ ((Compression2) => {
    Compression2["None"] = "none";
    Compression2["Gzip"] = "gzip";
    Compression2["Zstd"] = "zstd";
    return Compression2;
  })(Compression || {});
  exports.Compression = Compression;
});

// node_modules/node-appwrite/dist/enums/image-gravity.js
var require_image_gravity = __commonJS((exports) => {
  var ImageGravity = /* @__PURE__ */ ((ImageGravity2) => {
    ImageGravity2["Center"] = "center";
    ImageGravity2["Topleft"] = "top-left";
    ImageGravity2["Top"] = "top";
    ImageGravity2["Topright"] = "top-right";
    ImageGravity2["Left"] = "left";
    ImageGravity2["Right"] = "right";
    ImageGravity2["Bottomleft"] = "bottom-left";
    ImageGravity2["Bottom"] = "bottom";
    ImageGravity2["Bottomright"] = "bottom-right";
    return ImageGravity2;
  })(ImageGravity || {});
  exports.ImageGravity = ImageGravity;
});

// node_modules/node-appwrite/dist/enums/image-format.js
var require_image_format = __commonJS((exports) => {
  var ImageFormat = /* @__PURE__ */ ((ImageFormat2) => {
    ImageFormat2["Jpg"] = "jpg";
    ImageFormat2["Jpeg"] = "jpeg";
    ImageFormat2["Gif"] = "gif";
    ImageFormat2["Png"] = "png";
    ImageFormat2["Webp"] = "webp";
    return ImageFormat2;
  })(ImageFormat || {});
  exports.ImageFormat = ImageFormat;
});

// node_modules/node-appwrite/dist/enums/password-hash.js
var require_password_hash = __commonJS((exports) => {
  var PasswordHash = /* @__PURE__ */ ((PasswordHash2) => {
    PasswordHash2["Sha1"] = "sha1";
    PasswordHash2["Sha224"] = "sha224";
    PasswordHash2["Sha256"] = "sha256";
    PasswordHash2["Sha384"] = "sha384";
    PasswordHash2["Sha512224"] = "sha512/224";
    PasswordHash2["Sha512256"] = "sha512/256";
    PasswordHash2["Sha512"] = "sha512";
    PasswordHash2["Sha3224"] = "sha3-224";
    PasswordHash2["Sha3256"] = "sha3-256";
    PasswordHash2["Sha3384"] = "sha3-384";
    PasswordHash2["Sha3512"] = "sha3-512";
    return PasswordHash2;
  })(PasswordHash || {});
  exports.PasswordHash = PasswordHash;
});

// node_modules/node-appwrite/dist/enums/messaging-provider-type.js
var require_messaging_provider_type = __commonJS((exports) => {
  var MessagingProviderType = /* @__PURE__ */ ((MessagingProviderType2) => {
    MessagingProviderType2["Email"] = "email";
    MessagingProviderType2["Sms"] = "sms";
    MessagingProviderType2["Push"] = "push";
    return MessagingProviderType2;
  })(MessagingProviderType || {});
  exports.MessagingProviderType = MessagingProviderType;
});

// node_modules/node-appwrite/dist/index.js
var require_dist = __commonJS((exports) => {
  var client = require_client();
  var account = require_account();
  var avatars = require_avatars();
  var databases = require_databases();
  var functions = require_functions();
  var graphql = require_graphql();
  var health = require_health();
  var locale = require_locale();
  var messaging = require_messaging();
  var storage = require_storage();
  var teams = require_teams();
  var users = require_users();
  var permission = require_permission();
  var role = require_role();
  var id = require_id();
  var authenticatorType = require_authenticator_type();
  var authenticationFactor = require_authentication_factor();
  var oAuthProvider = require_o_auth_provider();
  var browser = require_browser();
  var creditCard = require_credit_card();
  var flag = require_flag();
  var relationshipType = require_relationship_type();
  var relationMutate = require_relation_mutate();
  var indexType = require_index_type();
  var runtime = require_runtime();
  var executionMethod = require_execution_method();
  var name = require_name();
  var smtpEncryption = require_smtp_encryption();
  var compression = require_compression();
  var imageGravity = require_image_gravity();
  var imageFormat = require_image_format();
  var passwordHash = require_password_hash();
  var messagingProviderType = require_messaging_provider_type();
  Object.defineProperty(exports, "AppwriteException", {
    enumerable: true,
    get: function() {
      return client.AppwriteException;
    }
  });
  Object.defineProperty(exports, "Client", {
    enumerable: true,
    get: function() {
      return client.Client;
    }
  });
  Object.defineProperty(exports, "Query", {
    enumerable: true,
    get: function() {
      return client.Query;
    }
  });
  Object.defineProperty(exports, "Account", {
    enumerable: true,
    get: function() {
      return account.Account;
    }
  });
  Object.defineProperty(exports, "Avatars", {
    enumerable: true,
    get: function() {
      return avatars.Avatars;
    }
  });
  Object.defineProperty(exports, "Databases", {
    enumerable: true,
    get: function() {
      return databases.Databases;
    }
  });
  Object.defineProperty(exports, "Functions", {
    enumerable: true,
    get: function() {
      return functions.Functions;
    }
  });
  Object.defineProperty(exports, "Graphql", {
    enumerable: true,
    get: function() {
      return graphql.Graphql;
    }
  });
  Object.defineProperty(exports, "Health", {
    enumerable: true,
    get: function() {
      return health.Health;
    }
  });
  Object.defineProperty(exports, "Locale", {
    enumerable: true,
    get: function() {
      return locale.Locale;
    }
  });
  Object.defineProperty(exports, "Messaging", {
    enumerable: true,
    get: function() {
      return messaging.Messaging;
    }
  });
  Object.defineProperty(exports, "Storage", {
    enumerable: true,
    get: function() {
      return storage.Storage;
    }
  });
  Object.defineProperty(exports, "Teams", {
    enumerable: true,
    get: function() {
      return teams.Teams;
    }
  });
  Object.defineProperty(exports, "Users", {
    enumerable: true,
    get: function() {
      return users.Users;
    }
  });
  Object.defineProperty(exports, "Permission", {
    enumerable: true,
    get: function() {
      return permission.Permission;
    }
  });
  Object.defineProperty(exports, "Role", {
    enumerable: true,
    get: function() {
      return role.Role;
    }
  });
  Object.defineProperty(exports, "ID", {
    enumerable: true,
    get: function() {
      return id.ID;
    }
  });
  Object.defineProperty(exports, "AuthenticatorType", {
    enumerable: true,
    get: function() {
      return authenticatorType.AuthenticatorType;
    }
  });
  Object.defineProperty(exports, "AuthenticationFactor", {
    enumerable: true,
    get: function() {
      return authenticationFactor.AuthenticationFactor;
    }
  });
  Object.defineProperty(exports, "OAuthProvider", {
    enumerable: true,
    get: function() {
      return oAuthProvider.OAuthProvider;
    }
  });
  Object.defineProperty(exports, "Browser", {
    enumerable: true,
    get: function() {
      return browser.Browser;
    }
  });
  Object.defineProperty(exports, "CreditCard", {
    enumerable: true,
    get: function() {
      return creditCard.CreditCard;
    }
  });
  Object.defineProperty(exports, "Flag", {
    enumerable: true,
    get: function() {
      return flag.Flag;
    }
  });
  Object.defineProperty(exports, "RelationshipType", {
    enumerable: true,
    get: function() {
      return relationshipType.RelationshipType;
    }
  });
  Object.defineProperty(exports, "RelationMutate", {
    enumerable: true,
    get: function() {
      return relationMutate.RelationMutate;
    }
  });
  Object.defineProperty(exports, "IndexType", {
    enumerable: true,
    get: function() {
      return indexType.IndexType;
    }
  });
  Object.defineProperty(exports, "Runtime", {
    enumerable: true,
    get: function() {
      return runtime.Runtime;
    }
  });
  Object.defineProperty(exports, "ExecutionMethod", {
    enumerable: true,
    get: function() {
      return executionMethod.ExecutionMethod;
    }
  });
  Object.defineProperty(exports, "Name", {
    enumerable: true,
    get: function() {
      return name.Name;
    }
  });
  Object.defineProperty(exports, "SmtpEncryption", {
    enumerable: true,
    get: function() {
      return smtpEncryption.SmtpEncryption;
    }
  });
  Object.defineProperty(exports, "Compression", {
    enumerable: true,
    get: function() {
      return compression.Compression;
    }
  });
  Object.defineProperty(exports, "ImageGravity", {
    enumerable: true,
    get: function() {
      return imageGravity.ImageGravity;
    }
  });
  Object.defineProperty(exports, "ImageFormat", {
    enumerable: true,
    get: function() {
      return imageFormat.ImageFormat;
    }
  });
  Object.defineProperty(exports, "PasswordHash", {
    enumerable: true,
    get: function() {
      return passwordHash.PasswordHash;
    }
  });
  Object.defineProperty(exports, "MessagingProviderType", {
    enumerable: true,
    get: function() {
      return messagingProviderType.MessagingProviderType;
    }
  });
});

// node_modules/@phc/format/index.js
var require_format = __commonJS((exports, module) => {
  function objToKeyVal(obj) {
    return objectKeys(obj).map((k3) => [k3, obj[k3]].join("=")).join(",");
  }
  function keyValtoObj(str) {
    const obj = {};
    str.split(",").forEach((ps) => {
      const pss = ps.split("=");
      if (pss.length < 2) {
        throw new TypeError(`params must be in the format name=value`);
      }
      obj[pss.shift()] = pss.join("=");
    });
    return obj;
  }
  function objectKeys(object3) {
    return Object.keys(object3);
  }
  function objectValues(object3) {
    if (typeof Object.values === "function")
      return Object.values(object3);
    return objectKeys(object3).map((k3) => object3[k3]);
  }
  function serialize(opts) {
    const fields = [""];
    if (typeof opts !== "object" || opts === null) {
      throw new TypeError("opts must be an object");
    }
    if (typeof opts.id !== "string") {
      throw new TypeError("id must be a string");
    }
    if (!idRegex.test(opts.id)) {
      throw new TypeError(`id must satisfy ${idRegex}`);
    }
    fields.push(opts.id);
    if (typeof opts.version !== "undefined") {
      if (typeof opts.version !== "number" || opts.version < 0 || !Number.isInteger(opts.version)) {
        throw new TypeError("version must be a positive integer number");
      }
      fields.push(`v=${opts.version}`);
    }
    if (typeof opts.params !== "undefined") {
      if (typeof opts.params !== "object" || opts.params === null) {
        throw new TypeError("params must be an object");
      }
      const pk = objectKeys(opts.params);
      if (!pk.every((p3) => nameRegex.test(p3))) {
        throw new TypeError(`params names must satisfy ${nameRegex}`);
      }
      pk.forEach((k3) => {
        if (typeof opts.params[k3] === "number") {
          opts.params[k3] = opts.params[k3].toString();
        } else if (Buffer.isBuffer(opts.params[k3])) {
          opts.params[k3] = opts.params[k3].toString("base64").split("=")[0];
        }
      });
      const pv = objectValues(opts.params);
      if (!pv.every((v3) => typeof v3 === "string")) {
        throw new TypeError("params values must be strings");
      }
      if (!pv.every((v3) => valueRegex.test(v3))) {
        throw new TypeError(`params values must satisfy ${valueRegex}`);
      }
      const strpar = objToKeyVal(opts.params);
      fields.push(strpar);
    }
    if (typeof opts.salt !== "undefined") {
      if (!Buffer.isBuffer(opts.salt)) {
        throw new TypeError("salt must be a Buffer");
      }
      fields.push(opts.salt.toString("base64").split("=")[0]);
      if (typeof opts.hash !== "undefined") {
        if (!Buffer.isBuffer(opts.hash)) {
          throw new TypeError("hash must be a Buffer");
        }
        fields.push(opts.hash.toString("base64").split("=")[0]);
      }
    }
    const phcstr = fields.join("$");
    return phcstr;
  }
  function deserialize(phcstr) {
    if (typeof phcstr !== "string" || phcstr === "") {
      throw new TypeError("pchstr must be a non-empty string");
    }
    if (phcstr[0] !== "$") {
      throw new TypeError("pchstr must contain a $ as first char");
    }
    const fields = phcstr.split("$");
    fields.shift();
    let maxf = 5;
    if (!versionRegex.test(fields[1]))
      maxf--;
    if (fields.length > maxf) {
      throw new TypeError(`pchstr contains too many fileds: ${fields.length}/${maxf}`);
    }
    const id = fields.shift();
    if (!idRegex.test(id)) {
      throw new TypeError(`id must satisfy ${idRegex}`);
    }
    let version;
    if (versionRegex.test(fields[0])) {
      version = parseInt(fields.shift().match(versionRegex)[1], 10);
    }
    let hash3;
    let salt;
    if (b64Regex.test(fields[fields.length - 1])) {
      if (fields.length > 1 && b64Regex.test(fields[fields.length - 2])) {
        hash3 = Buffer.from(fields.pop(), "base64");
        salt = Buffer.from(fields.pop(), "base64");
      } else {
        salt = Buffer.from(fields.pop(), "base64");
      }
    }
    let params;
    if (fields.length > 0) {
      const parstr = fields.pop();
      params = keyValtoObj(parstr);
      if (!objectKeys(params).every((p3) => nameRegex.test(p3))) {
        throw new TypeError(`params names must satisfy ${nameRegex}`);
      }
      const pv = objectValues(params);
      if (!pv.every((v3) => valueRegex.test(v3))) {
        throw new TypeError(`params values must satisfy ${valueRegex}`);
      }
      const pk = objectKeys(params);
      pk.forEach((k3) => {
        params[k3] = decimalRegex.test(params[k3]) ? parseInt(params[k3], 10) : params[k3];
      });
    }
    if (fields.length > 0) {
      throw new TypeError(`pchstr contains unrecognized fileds: ${fields}`);
    }
    const phcobj = { id };
    if (version)
      phcobj.version = version;
    if (params)
      phcobj.params = params;
    if (salt)
      phcobj.salt = salt;
    if (hash3)
      phcobj.hash = hash3;
    return phcobj;
  }
  var idRegex = /^[a-z0-9-]{1,32}$/;
  var nameRegex = /^[a-z0-9-]{1,32}$/;
  var valueRegex = /^[a-zA-Z0-9/+.-]+$/;
  var b64Regex = /^([a-zA-Z0-9/+.-]+|)$/;
  var decimalRegex = /^((-)?[1-9]\d*|0)$/;
  var versionRegex = /^v=(\d+)$/;
  module.exports = {
    serialize,
    deserialize
  };
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  function load(dir) {
    return runtimeRequire(load.resolve(dir));
  }
  function readdirSync(dir) {
    try {
      return fs2.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  }
  function matchTuple(platform2, arch2) {
    return function(tuple3) {
      if (tuple3 == null)
        return false;
      if (tuple3.platform !== platform2)
        return false;
      return tuple3.architectures.includes(arch2);
    };
  }
  function compareTuples(a3, b) {
    return a3.architectures.length - b.architectures.length;
  }
  function parseTags(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i4 = 0;i4 < arr.length; i4++) {
      var tag = arr[i4];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  }
  function matchTags(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi && tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  }
  function runtimeAgnostic(tags) {
    return tags.runtime === "node" && tags.napi;
  }
  function compareTags(runtime2) {
    return function(a3, b) {
      if (a3.runtime !== b.runtime) {
        return a3.runtime === runtime2 ? -1 : 1;
      } else if (a3.abi !== b.abi) {
        return a3.abi ? -1 : 1;
      } else if (a3.specificity !== b.specificity) {
        return a3.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isAlpine(platform2) {
    return platform2 === "linux" && fs2.existsSync("/etc/alpine-release");
  }
  var fs2 = import.meta.require("fs");
  var path = import.meta.require("path");
  var os = import.meta.require("os");
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : import.meta.require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os.arch();
  var platform = process.env.npm_config_platform || os.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  module.exports = load;
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {
    }
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug)
        return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple3 = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple3)
        return;
      var prebuilds = path.join(dir2, "prebuilds", tuple3.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS((exports, module) => {
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : import.meta.require;
  if (typeof runtimeRequire.addon === "function") {
    module.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// node_modules/argon2/argon2.cjs
var require_argon2 = __commonJS((exports, module) => {
  async function hash3(password, options) {
    let { raw, salt, ...rest3 } = { ...defaults, ...options };
    for (const [key, { min, max }] of Object.entries(limits)) {
      const value2 = rest3[key];
      assert(min <= value2 && value2 <= max, `Invalid ${key}, must be between ${min} and ${max}.`);
    }
    salt = salt ?? await generateSalt(16);
    const {
      hashLength,
      secret = Buffer.alloc(0),
      type: type3,
      version,
      memoryCost: m3,
      timeCost: t4,
      parallelism: p3,
      associatedData: data = Buffer.alloc(0)
    } = rest3;
    const hash4 = await bindingsHash({
      password: Buffer.from(password),
      salt,
      secret,
      data,
      hashLength,
      m: m3,
      t: t4,
      p: p3,
      version,
      type: type3
    });
    if (raw) {
      return hash4;
    }
    return serialize({
      id: names[type3],
      version,
      params: { m: m3, t: t4, p: p3, ...data.byteLength > 0 ? { data } : {} },
      salt,
      hash: hash4
    });
  }
  function needsRehash(digest, options = {}) {
    const { memoryCost, timeCost, version } = { ...defaults, ...options };
    const {
      version: v3,
      params: { m: m3, t: t4 }
    } = deserialize(digest);
    return +v3 !== +version || +m3 !== +memoryCost || +t4 !== +timeCost;
  }
  async function verify(digest, password, options = {}) {
    const { id, ...rest3 } = deserialize(digest);
    if (!(id in types)) {
      return false;
    }
    const {
      version = 16,
      params: { m: m3, t: t4, p: p3, data = "" },
      salt,
      hash: hash4
    } = rest3;
    const { secret = Buffer.alloc(0) } = options;
    return timingSafeEqual(await bindingsHash({
      password: Buffer.from(password),
      salt,
      secret,
      data: Buffer.from(data, "base64"),
      hashLength: hash4.byteLength,
      m: +m3,
      t: +t4,
      p: +p3,
      version: +version,
      type: types[id]
    }), hash4);
  }
  var __dirname = "/Users/technopartnerindonesia/Desktop/charging-station-server/node_modules/argon2";
  var assert = import.meta.require("assert");
  var { randomBytes, timingSafeEqual } = import.meta.require("crypto");
  var { promisify } = import.meta.require("util");
  var { deserialize, serialize } = require_format();
  var gypBuild = require_node_gyp_build2();
  var { hash: bindingsHash } = gypBuild(__dirname);
  var generateSalt = promisify(randomBytes);
  var argon2d = 0;
  var argon2i = 1;
  var argon2id = 2;
  exports.argon2d = argon2d;
  exports.argon2i = argon2i;
  exports.argon2id = argon2id;
  var types = Object.freeze({ argon2d, argon2i, argon2id });
  var names = Object.freeze({
    [types.argon2d]: "argon2d",
    [types.argon2i]: "argon2i",
    [types.argon2id]: "argon2id"
  });
  var defaults = Object.freeze({
    hashLength: 32,
    timeCost: 3,
    memoryCost: 1 << 16,
    parallelism: 4,
    type: argon2id,
    version: 19
  });
  var limits = Object.freeze({
    hashLength: { min: 4, max: 2 ** 32 - 1 },
    memoryCost: { min: 1 << 10, max: 2 ** 32 - 1 },
    timeCost: { min: 2, max: 2 ** 32 - 1 },
    parallelism: { min: 1, max: 2 ** 24 - 1 }
  });
  exports.limits = limits;
  exports.hash = hash3;
  exports.needsRehash = needsRehash;
  exports.verify = verify;
});

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}
// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}
// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key);
    Visit3(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== undefined;
}
function Create(errorType, schema, path, value) {
  return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };
}
function* FromAny(schema, references, path, value) {
}
function* FromArray3(schema, references, path, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit4(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator(schema, references, path, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt(schema, references, path, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean(schema, references, path, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor(schema, references, path, value) {
  yield* Visit4(schema.returns, references, path, value.prototype);
}
function* FromDate(schema, references, path, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction(schema, references, path, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromInteger(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect3(schema, references, path, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral2(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot(schema, references, path, value) {
  if (Visit4(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull(schema, references, path, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromRegExp(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral2(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromTuple3(schema, references, path, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined(schema, references, path, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion5(schema, references, path, value) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors = [...Visit4(subschema, references, path, value)];
    if (errors.length === 0)
      return;
    count += errors.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value);
  }
}
function* FromUint8Array(schema, references, path, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown(schema, references, path, value) {
}
function* FromVoid(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind(schema, references, path, value) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit4(schema, references, path, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value);
    case "Date":
      return yield* FromDate(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value);
    case "Never":
      return yield* FromNever(schema_, references_, path, value);
    case "Not":
      return yield* FromNot(schema_, references_, path, value);
    case "Null":
      return yield* FromNull(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value);
    case "Object":
      return yield* FromObject(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value);
    case "String":
      return yield* FromString(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value);
    case "This":
      return yield* FromThis(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator2 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator2);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  constructor(iterator2) {
    this.iterator = iterator2;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
}
function FromStringRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== undefined;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element) => Clone2(element));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object2 = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object2.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal2 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union3, references, value) {
  const schemas = union3.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union3, references, value) {
  if ("default" in union3) {
    return typeof value === "function" ? union3.default : Clone2(union3.default);
  } else {
    const schema = SelectUnion(union3, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped2 = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped2) ? mapped2 : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (key in schema.properties) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key of Object.keys(value)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value[key]) : value[key];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  return value === undefined && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone2 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function ObjectType6(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType4(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit13(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
function Default4(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value, error2);
  }
}
function FromArray11(schema, references, path, value) {
  return IsArray(value) ? Default4(schema, path, value.map((value2, index) => Visit14(schema.items, references, `${path}/${index}`, value2))) : Default4(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromNot5(schema, references, path, value) {
  return Default4(schema, path, Visit14(schema.not, references, path, value));
}
function FromObject9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRecord9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromTuple11(schema, references, path, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value[index]))) : Default4(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path, value);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value);
}
function Visit14(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject9(schema_, references_, path, value);
    case "Record":
      return FromRecord9(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "Symbol":
      return Default4(schema_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}

class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
function Default5(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value, error2);
  }
}
function FromArray12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  return IsArray(defaulted) ? defaulted.map((value2, index) => Visit15(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default5(schema.not, path, Default5(schema, path, value));
}
function FromObject10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromThis9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromTuple12(schema, references, path, value) {
  const value1 = Default5(schema, path, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path, value);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value);
}
function Visit15(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef9(schema_, references_, path, value);
    case "This":
      return FromThis9(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default5(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}

class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly(FromValue(value2[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value2, root) {
  return IsAsyncIterator2(value2) ? ConditionalReadonly(Any(), root) : IsIterator2(value2) ? ConditionalReadonly(Any(), root) : IsArray2(value2) ? Readonly(Tuple(FromArray14(value2))) : IsUint8Array2(value2) ? Uint8Array2() : IsDate2(value2) ? Date2() : IsObject2(value2) ? ConditionalReadonly(Object2(FromProperties8(value2)), root) : IsFunction2(value2) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value2) ? Undefined() : IsNull2(value2) ? Null() : IsSymbol2(value2) ? Symbol2() : IsBigInt2(value2) ? BigInt2() : IsNumber2(value2) ? Literal(value2) : IsBoolean2(value2) ? Literal(value2) : IsString2(value2) ? Literal(value2) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard2 = Discard(target, ["$id"]);
  return Deref2(discard2, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal(value2));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value2) => Literal(value2));
  const mapped2 = FromRest6(literals, mode);
  const union3 = Union(mapped2);
  return TemplateLiteral([union3], options);
}
function FromLiteralValue(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern2 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern2, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}

class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value2) => schema2[TransformKind].Encode(encode2(value2));
    const Decode2 = (value2) => this.decode(schema2[TransformKind].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value2) {
    return Errors(this.schema, this.references, value2);
  }
  Check(value2) {
    return this.checkFunc(value2);
  }
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value2) : value2;
  }
  Encode(value2) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i = 0;i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      const check3 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check3)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object3, key) {
    return IsAccessor(key) ? `${object3}.${key}` : `${object3}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value2} === 'number'` : `Number.isFinite(${value2})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value2) {
    yield "true";
  }
  function* FromArray16(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value2}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value2}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check3 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check3}})(${value2})`;
    }
    if (schema3.uniqueItems === true) {
      const check3 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check3} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* FromBigInt6(schema3, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value2} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value2} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value2} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value2} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value2} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value2) {
    yield* Visit17(schema3.returns, references, `${value2}.prototype`);
  }
  function* FromDate6(schema3, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* FromInteger6(schema3, references, value2) {
    yield `Number.isInteger(${value2})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value2) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value2)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* FromLiteral7(schema3, references, value2) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value2} === ${schema3.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value2) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value2) {
    const expression = CreateExpression(schema3.not, references, value2);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value2) {
    yield `(${value2} === null)`;
  }
  function* FromNumber6(schema3, references, value2) {
    yield Policy.IsNumberLike(value2);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value2) {
    yield Policy.IsObjectLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value2) {
    yield Policy.IsRecordLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value2) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value2) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
    yield* Visit17(target, references, value2);
  }
  function* FromRegExp5(schema3, references, value2) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value2})`;
  }
  function* FromString6(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value2})`;
    }
  }
  function* FromSymbol6(schema3, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* FromThis11(schema3, references, value2) {
    yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
  }
  function* FromTuple15(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema3.items === undefined)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value2}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value2) {
    yield `${value2} === undefined`;
  }
  function* FromUnion20(schema3, references, value2) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value2}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value2}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value2) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* FromKind4(schema3, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value2})`;
  }
  function* Visit17(schema3, references, value2, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value2);
      case "Array":
        return yield* FromArray16(schema_, references_, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value2);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value2);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value2);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value2);
      case "Date":
        return yield* FromDate6(schema_, references_, value2);
      case "Function":
        return yield* FromFunction7(schema_, references_, value2);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value2);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value2);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value2);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value2);
      case "Never":
        return yield* FromNever6(schema_, references_, value2);
      case "Not":
        return yield* FromNot8(schema_, references_, value2);
      case "Null":
        return yield* FromNull6(schema_, references_, value2);
      case "Number":
        return yield* FromNumber6(schema_, references_, value2);
      case "Object":
        return yield* FromObject13(schema_, references_, value2);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value2);
      case "Record":
        return yield* FromRecord12(schema_, references_, value2);
      case "Ref":
        return yield* FromRef12(schema_, references_, value2);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value2);
      case "String":
        return yield* FromString6(schema_, references_, value2);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value2);
      case "This":
        return yield* FromThis11(schema_, references_, value2);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value2);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value2);
      case "Union":
        return yield* FromUnion20(schema_, references_, value2);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value2);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value2);
      case "Void":
        return yield* FromVoid5(schema_, references_, value2);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value2, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value2, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type3) {
    const annotation = state.language === "typescript" ? `: ${type3}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type3) {
    return state.language === "typescript" ? `: ${type3}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value2);
    }
    function formatRegistryFunction(format, value2) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return Hash(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
function h2($) {
  return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
}
function n1($) {
  const W = m2.exec($);
  if (!W)
    return false;
  const X = +W[1], Z = +W[2], j = +W[3];
  return Z >= 1 && Z <= 12 && j >= 1 && j <= (Z === 2 && h2(X) ? 29 : d2[Z]);
}
function F1($) {
  return function W(X) {
    const Z = c2.exec(X);
    if (!Z)
      return false;
    const j = +Z[1], J = +Z[2], Q = +Z[3], Y = Z[4], K = Z[5] === "-" ? -1 : 1, B = +(Z[6] || 0), U = +(Z[7] || 0);
    if (B > 23 || U > 59 || $ && !Y)
      return false;
    if (j <= 23 && J <= 59 && Q < 60)
      return true;
    const w = J - U * K, F = j - B * K - (w < 0 ? 1 : 0);
    return (F === 23 || F === -1) && (w === 59 || w === -1) && Q < 61;
  };
}
function p1($) {
  const W = F1($);
  return function X(Z) {
    const j = Z.split(p2);
    return j.length === 2 && n1(j[0]) && W(j[1]);
  };
}
function n2($) {
  return l2.test($) && i2.test($);
}
function t2($) {
  return l1.lastIndex = 0, l1.test($);
}
function a2($) {
  return Number.isInteger($) && $ <= r2 && $ >= s2;
}
function o2($) {
  return Number.isInteger($);
}
function i1() {
  return true;
}
function $3($) {
  if (e2.test($))
    return false;
  try {
    return new RegExp($), true;
  } catch (W) {
    return false;
  }
}
function G3($, W) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var X = {}, Z = W || {}, j = Z.decode || B3, J = 0;
  while (J < $.length) {
    var Q = $.indexOf("=", J);
    if (Q === -1)
      break;
    var Y = $.indexOf(";", J);
    if (Y === -1)
      Y = $.length;
    else if (Y < Q) {
      J = $.lastIndexOf(";", Q - 1) + 1;
      continue;
    }
    var K = $.slice(J, Q).trim();
    if (X[K] === undefined) {
      var B = $.slice(Q + 1, Y).trim();
      if (B.charCodeAt(0) === 34)
        B = B.slice(1, -1);
      X[K] = w3(B, j);
    }
    J = Y + 1;
  }
  return X;
}
function Y3($, W, X) {
  var Z = X || {}, j = Z.encode || K3;
  if (typeof j !== "function")
    throw new TypeError("option encode is invalid");
  if (!o0.test($))
    throw new TypeError("argument name is invalid");
  var J = j(W);
  if (J && !o0.test(J))
    throw new TypeError("argument val is invalid");
  var Q = $ + "=" + J;
  if (Z.maxAge != null) {
    var Y = Z.maxAge - 0;
    if (isNaN(Y) || !isFinite(Y))
      throw new TypeError("option maxAge is invalid");
    Q += "; Max-Age=" + Math.floor(Y);
  }
  if (Z.domain) {
    if (!o0.test(Z.domain))
      throw new TypeError("option domain is invalid");
    Q += "; Domain=" + Z.domain;
  }
  if (Z.path) {
    if (!o0.test(Z.path))
      throw new TypeError("option path is invalid");
    Q += "; Path=" + Z.path;
  }
  if (Z.expires) {
    var K = Z.expires;
    if (!U3(K) || isNaN(K.valueOf()))
      throw new TypeError("option expires is invalid");
    Q += "; Expires=" + K.toUTCString();
  }
  if (Z.httpOnly)
    Q += "; HttpOnly";
  if (Z.secure)
    Q += "; Secure";
  if (Z.partitioned)
    Q += "; Partitioned";
  if (Z.priority) {
    var B = typeof Z.priority === "string" ? Z.priority.toLowerCase() : Z.priority;
    switch (B) {
      case "low":
        Q += "; Priority=Low";
        break;
      case "medium":
        Q += "; Priority=Medium";
        break;
      case "high":
        Q += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (Z.sameSite) {
    var U = typeof Z.sameSite === "string" ? Z.sameSite.toLowerCase() : Z.sameSite;
    switch (U) {
      case true:
        Q += "; SameSite=Strict";
        break;
      case "lax":
        Q += "; SameSite=Lax";
        break;
      case "strict":
        Q += "; SameSite=Strict";
        break;
      case "none":
        Q += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Q;
}
function B3($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
}
function K3($) {
  return encodeURIComponent($);
}
function U3($) {
  return Q3.call($) === "[object Date]" || $ instanceof Date;
}
function w3($, W) {
  try {
    return W($);
  } catch (X) {
    return $;
  }
}
async function* m0($) {
  const W = $.body;
  if (!W)
    return;
  const X = W.getReader(), Z = new TextDecoder;
  try {
    while (true) {
      const { done: j, value: J } = await X.read();
      if (j)
        break;
      yield Z.decode(J);
    }
  } finally {
    X.releaseLock();
  }
}
function O3($) {
  let W = $;
  while (W.endsWith("="))
    W = W.slice(0, -1);
  return W;
}
function B1($) {
  const W = {};
  if (typeof $ !== "string")
    return W;
  let X = "", Z = "", j = -1, J = -1, Q = 0;
  const Y = $.length;
  for (let K = 0;K < Y; K++)
    switch ($.charCodeAt(K)) {
      case 38:
        const B = J > j;
        if (!B)
          J = K;
        if (X = $.slice(j + 1, J), B || X.length > 0) {
          if (Q & 1)
            X = X.replace(y0, " ");
          if (Q & 2)
            X = V0.default(X) || X;
          if (!W[X]) {
            if (B) {
              if (Z = $.slice(J + 1, K), Q & 4)
                Z = Z.replace(y0, " ");
              if (Q & 8)
                Z = V0.default(Z) || Z;
            }
            W[X] = Z;
          }
        }
        X = "", Z = "", j = K, J = K, Q = 0;
        break;
      case 61:
        if (J <= j)
          J = K;
        else
          Q |= 8;
        break;
      case 43:
        if (J > j)
          Q |= 4;
        else
          Q |= 1;
        break;
      case 37:
        if (J > j)
          Q |= 8;
        else
          Q |= 2;
        break;
    }
  if (j < Y) {
    const K = J > j;
    if (X = $.slice(j + 1, K ? J : Y), K || X.length > 0) {
      if (Q & 1)
        X = X.replace(y0, " ");
      if (Q & 2)
        X = V0.default(X) || X;
      if (!W[X]) {
        if (K) {
          if (Z = $.slice(J + 1, Y), Q & 4)
            Z = Z.replace(y0, " ");
          if (Q & 8)
            Z = V0.default(Z) || Z;
        }
        W[X] = Z;
      }
    }
  }
  return W;
}
var T2 = Object.create;
var { getPrototypeOf: q2, defineProperty: v1, getOwnPropertyNames: E2 } = Object;
var H2 = Object.prototype.hasOwnProperty;
var w1 = ($, W, X) => {
  X = $ != null ? T2(q2($)) : {};
  const Z = W || !$ || !$.__esModule ? v1(X, "default", { value: $, enumerable: true }) : X;
  for (let j of E2($))
    if (!H2.call(Z, j))
      v1(Z, j, { get: () => $[j], enumerable: true });
  return Z;
};
var R2 = ($, W) => () => (W || $((W = { exports: {} }).exports, W), W.exports);
var e0 = R2((Y8, W2) => {
  function F3($) {
    var W = $.indexOf("%");
    if (W === -1)
      return $;
    var X = $.length, Z = "", j = 0, J = 0, Q = W, Y = e1;
    while (W > -1 && W < X) {
      var K = $2($[W + 1], 4), B = $2($[W + 2], 0), U = K | B, w = P1[U];
      if (Y = P1[256 + Y + w], J = J << 6 | U & P1[364 + w], Y === e1)
        Z += $.slice(j, Q), Z += J <= 65535 ? String.fromCharCode(J) : String.fromCharCode(55232 + (J >> 10), 56320 + (J & 1023)), J = 0, j = W + 3, W = Q = $.indexOf("%", j);
      else if (Y === _3)
        return null;
      else {
        if (W += 3, W < X && $.charCodeAt(W) === 37)
          continue;
        return null;
      }
    }
    return Z + $.slice(j);
  }
  function $2($, W) {
    var X = M3[$];
    return X === undefined ? 255 : X << W;
  }
  var e1 = 12, _3 = 0, P1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], M3 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  W2.exports = F3;
});
var q0 = ($, W) => {
  const X = W?.length ? {} : null;
  if (X)
    for (let Z of W)
      X[Z.part.charCodeAt(0)] = Z;
  return { part: $, store: null, inert: X, params: null, wildcardStore: null };
};
var u1 = ($, W) => ({ ...$, part: W });
var h1 = ($) => ({ name: $, store: null, inert: null });

class M0 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add($, W, X, { ignoreError: Z = false, ignoreHistory: j = false } = {}) {
    if (typeof W !== "string")
      throw new TypeError("Route path must be a string");
    if (W === "")
      W = "/";
    else if (W[0] !== "/")
      W = `/${W}`;
    const J = W[W.length - 1] === "*", Q = W.match(M0.regex.optionalParams);
    if (Q) {
      const w = W.replaceAll("?", "");
      this.add($, w, X, { ignoreError: Z });
      for (let F = 0;F < Q.length; F++) {
        let G = W.replace("/" + Q[F], "");
        this.add($, G, X, { ignoreError: true });
      }
      return X;
    }
    if (Q)
      W = W.replaceAll("?", "");
    if (this.history.find(([w, F, G]) => w === $ && F === W))
      return X;
    if (J || Q && W.charCodeAt(W.length - 1) === 63)
      W = W.slice(0, -1);
    if (!j)
      this.history.push([$, W, X]);
    const Y = W.split(M0.regex.static), K = W.match(M0.regex.params) || [];
    if (Y[Y.length - 1] === "")
      Y.pop();
    let B;
    if (!this.root[$])
      B = this.root[$] = q0("/");
    else
      B = this.root[$];
    let U = 0;
    for (let w = 0;w < Y.length; ++w) {
      let F = Y[w];
      if (w > 0) {
        const G = K[U++].slice(1);
        if (B.params === null)
          B.params = h1(G);
        else if (B.params.name !== G)
          if (Z)
            return X;
          else
            throw new Error(`Cannot create route "${W}" with parameter "${G}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
        const z = B.params;
        if (z.inert === null) {
          B = z.inert = q0(F);
          continue;
        }
        B = z.inert;
      }
      for (let G = 0;; ) {
        if (G === F.length) {
          if (G < B.part.length) {
            const z = u1(B, B.part.slice(G));
            Object.assign(B, q0(F, [z]));
          }
          break;
        }
        if (G === B.part.length) {
          if (B.inert === null)
            B.inert = {};
          const z = B.inert[F.charCodeAt(G)];
          if (z) {
            B = z, F = F.slice(G), G = 0;
            continue;
          }
          const D = q0(F.slice(G));
          B.inert[F.charCodeAt(G)] = D, B = D;
          break;
        }
        if (F[G] !== B.part[G]) {
          const z = u1(B, B.part.slice(G)), D = q0(F.slice(G));
          Object.assign(B, q0(B.part.slice(0, G), [z, D])), B = D;
          break;
        }
        ++G;
      }
    }
    if (U < K.length) {
      const w = K[U].slice(1);
      if (B.params === null)
        B.params = h1(w);
      else if (B.params.name !== w)
        if (Z)
          return X;
        else
          throw new Error(`Cannot create route "${W}" with parameter "${w}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
      if (B.params.store === null)
        B.params.store = X;
      return B.params.store;
    }
    if (J) {
      if (B.wildcardStore === null)
        B.wildcardStore = X;
      return B.wildcardStore;
    }
    if (B.store === null)
      B.store = X;
    return B.store;
  }
  find($, W) {
    const X = this.root[$];
    if (!X)
      return null;
    return _1(W, W.length, X, 0);
  }
}
var _1 = ($, W, X, Z) => {
  const j = X.part, J = j.length, Q = Z + J;
  if (J > 1) {
    if (Q > W)
      return null;
    if (J < 15) {
      for (let Y = 1, K = Z + 1;Y < J; ++Y, ++K)
        if (j.charCodeAt(Y) !== $.charCodeAt(K))
          return null;
    } else if ($.slice(Z, Q) !== j)
      return null;
  }
  if (Q === W) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    const Y = X.inert[$.charCodeAt(Q)];
    if (Y !== undefined) {
      const K = _1($, W, Y, Q);
      if (K !== null)
        return K;
    }
  }
  if (X.params !== null) {
    const { store: Y, name: K, inert: B } = X.params, U = $.indexOf("/", Q);
    if (U !== Q) {
      if (U === -1 || U >= W) {
        if (Y !== null) {
          const w = {};
          return w[K] = $.substring(Q, W), { store: Y, params: w };
        }
      } else if (B !== null) {
        const w = _1($, W, B, U);
        if (w !== null)
          return w.params[K] = $.substring(Q, U), w;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Q, W) } };
  return null;
};
var E0 = ($) => {
  const W = typeof $ === "object" ? $.fn.toString() : typeof $ === "string" ? $.toString() : $, X = W.indexOf(")");
  if (W.charCodeAt(X + 2) === 61 && W.charCodeAt(X + 5) !== 123)
    return true;
  return W.includes("return");
};
var b2 = ($) => {
  if ($.startsWith("async"))
    $ = $.slice(5);
  $ = $.trimStart();
  let W = -1;
  if ($.charCodeAt(0) === 40) {
    if (W = $.indexOf("=>", $.indexOf(")")), W !== -1) {
      let j = W;
      while (j > 0)
        if ($.charCodeAt(--j) === 41)
          break;
      let J = $.slice(W + 2);
      if (J.charCodeAt(0) === 32)
        J = J.trimStart();
      return [$.slice(1, j), J, { isArrowReturn: J.charCodeAt(0) !== 123 }];
    }
  }
  if ($.startsWith("function")) {
    W = $.indexOf("(");
    const j = $.indexOf(")");
    return [$.slice(W + 1, j), $.slice(j + 2), { isArrowReturn: false }];
  }
  const X = $.indexOf("(");
  if (X !== -1) {
    const j = $.indexOf("\n", 2), J = $.slice(0, j), Q = J.lastIndexOf(")") + 1, Y = $.slice(j + 1);
    return [J.slice(X, Q), "{" + Y, { isArrowReturn: false }];
  }
  const Z = $.split("\n", 2);
  return [Z[0], Z[1], { isArrowReturn: false }];
};
var x2 = ($) => {
  const W = $.indexOf("{");
  if (W === -1)
    return [-1, 0];
  let X = W + 1, Z = 1;
  for (;X < $.length; X++) {
    const j = $.charCodeAt(X);
    if (j === 123)
      Z++;
    else if (j === 125)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [0, $.length];
  return [W, X + 1];
};
var g2 = ($) => {
  const W = $.lastIndexOf("}");
  if (W === -1)
    return [-1, 0];
  let X = W - 1, Z = 1;
  for (;X >= 0; X--) {
    const j = $.charCodeAt(X);
    if (j === 125)
      Z++;
    else if (j === 123)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [-1, 0];
  return [X, W + 1];
};
var m1 = ($) => {
  while (true) {
    const W = $.indexOf(":");
    if (W === -1)
      break;
    let X = $.indexOf(",", W);
    if (X === -1)
      X = $.indexOf("}", W) - 1;
    if (X === -2)
      X = $.length;
    $ = $.slice(0, W) + $.slice(X);
  }
  return $;
};
var d1 = ($) => {
  let W = false;
  if ($.charCodeAt(0) === 40)
    $ = $.slice(1, -1);
  if ($.charCodeAt(0) === 123)
    W = true, $ = $.slice(1, -1);
  $ = $.replace(/( |\t|\n)/g, "").trim();
  let X = [];
  while (true) {
    let [j, J] = x2($);
    if (j === -1)
      break;
    if (X.push($.slice(0, j - 1)), $.charCodeAt(J) === 44)
      J++;
    $ = $.slice(J);
  }
  if ($ = m1($), $)
    X = X.concat($.split(","));
  const Z = [];
  for (let j of X) {
    if (j.indexOf(",") === -1) {
      Z.push(j);
      continue;
    }
    for (let J of j.split(","))
      Z.push(J.trim());
  }
  return X = Z, { hasParenthesis: W, parameters: X };
};
var f2 = ($, W) => {
  const { parameters: X, hasParenthesis: Z } = d1($);
  if (!W.query && X.includes("query"))
    W.query = true;
  if (!W.headers && X.includes("headers"))
    W.headers = true;
  if (!W.body && X.includes("body"))
    W.body = true;
  if (!W.cookie && X.includes("cookie"))
    W.cookie = true;
  if (!W.set && X.includes("set"))
    W.set = true;
  if (!W.server && X.includes("server"))
    W.server = true;
  if (Z)
    return `{ ${X.join(", ")} }`;
  return X.join(", ");
};
var y2 = ($, W, X) => {
  const Z = W.indexOf($ + "\n", X), j = W.indexOf($ + "\t", X), J = W.indexOf($ + ",", X), Q = W.indexOf($ + ";", X), Y = W.indexOf($ + " ", X);
  return [Z, j, J, Q, Y].filter((K) => K > 0).sort((K, B) => K - B)[0] || -1;
};
var c1 = ($, W, X = 0) => {
  if (X > 5)
    return [];
  const Z = [];
  let j = W;
  while (true) {
    let J = y2(" = " + $, j);
    if (J === -1) {
      const K = j.indexOf(" = " + $);
      if (K + 3 + $.length !== j.length)
        break;
      J = K;
    }
    const Q = j.slice(0, J);
    let Y = Q.slice(Q.lastIndexOf(" ") + 1);
    if (Y === "}") {
      const [K, B] = g2(Q);
      Z.push(m1(j.slice(K, B))), j = j.slice(J + 3 + $.length);
      continue;
    }
    while (Y.charCodeAt(0) === 44)
      Y = Y.slice(1);
    while (Y.charCodeAt(0) === 9)
      Y = Y.slice(1);
    if (!Y.includes("("))
      Z.push(Y);
    j = j.slice(J + 3 + $.length);
  }
  for (let J of Z) {
    if (J.charCodeAt(0) === 123)
      continue;
    const Q = c1(J, W);
    if (Q.length > 0)
      Z.push(...Q);
  }
  return Z;
};
var k2 = ($) => {
  if (!$)
    return;
  if ($.charCodeAt(0) !== 123)
    return $;
  if ($ = $.slice(2, -2), !$.includes(",")) {
    if ($.includes("..."))
      return $.slice($.indexOf("...") + 3);
    return;
  }
  const X = $.indexOf("...");
  if (X === -1)
    return;
  return $.slice(X + 3).trimEnd();
};
var v2 = ($, W, X) => {
  const Z = (j, J) => $.includes(J + "." + j) || $.includes(J + '["' + j + '"]') || $.includes(J + "['" + j + "']");
  for (let j of W) {
    if (!j)
      continue;
    if (j.charCodeAt(0) === 123) {
      const J = d1(j).parameters;
      if (!X.query && J.includes("query"))
        X.query = true;
      if (!X.headers && J.includes("headers"))
        X.headers = true;
      if (!X.body && J.includes("body"))
        X.body = true;
      if (!X.cookie && J.includes("cookie"))
        X.cookie = true;
      if (!X.set && J.includes("set"))
        X.set = true;
      if (!X.query && J.includes("server"))
        X.server = true;
      continue;
    }
    if (!X.query && Z("query", j))
      X.query = true;
    if ($.includes("return " + j) || $.includes("return " + j + ".query"))
      X.query = true;
    if (!X.headers && Z("headers", j))
      X.headers = true;
    if (!X.body && Z("body", j))
      X.body = true;
    if (!X.cookie && Z("cookie", j))
      X.cookie = true;
    if (!X.set && Z("set", j))
      X.set = true;
    if (!X.server && Z("server", j))
      X.server = true;
    if (X.query && X.headers && X.body && X.cookie && X.set && X.server)
      break;
  }
  return W;
};
var u2 = ($, W, X) => {
  try {
    const Z = new RegExp(`(?:\\w)\\((?:.*)?${$}`, "gs");
    Z.test(W);
    const j = W.charCodeAt(Z.lastIndex);
    if (j === 41 || j === 44)
      return X.query = true, X.headers = true, X.body = true, X.cookie = true, X.set = true, X.server = true, true;
    return false;
  } catch (Z) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(W), console.log("--- context ---"), console.log($), true;
  }
};
var r0 = ($, W = { query: false, headers: false, body: false, cookie: false, set: false, server: false }) => {
  const X = [];
  if ($.handler && typeof $.handler === "function")
    X.push($.handler);
  if ($.request?.length)
    X.push(...$.request);
  if ($.beforeHandle?.length)
    X.push(...$.beforeHandle);
  if ($.parse?.length)
    X.push(...$.parse);
  if ($.error?.length)
    X.push(...$.error);
  if ($.transform?.length)
    X.push(...$.transform);
  if ($.afterHandle?.length)
    X.push(...$.afterHandle);
  if ($.mapResponse?.length)
    X.push(...$.mapResponse);
  if ($.afterResponse?.length)
    X.push(...$.afterResponse);
  for (let Z of X) {
    if (!Z)
      continue;
    const j = "fn" in Z ? Z.fn : Z, [J, Q, { isArrowReturn: Y }] = b2(j.toString()), K = f2(J, W), B = k2(K);
    if (B) {
      const U = c1(B, Q);
      if (U.splice(0, -1, B), !u2(B, Q, W))
        v2(Q, U, W);
      if (!W.query && Q.includes("return " + B + ".query"))
        W.query = true;
    }
    if (W.query && W.headers && W.body && W.cookie && W.set && W.server)
      break;
  }
  return W;
};
var a0 = { date: n1, time: F1(true), "date-time": p1(true), "iso-time": F1(false), "iso-date-time": p1(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: n2, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: $3, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: t2, int32: { type: "number", validate: a2 }, int64: { type: "number", validate: o2 }, float: { type: "number", validate: i1 }, double: { type: "number", validate: i1 }, password: true, binary: true };
var m2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var d2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var c2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var p2 = /t|\s/i;
var l2 = /\/|:/;
var i2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var l1 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var s2 = -2147483648;
var r2 = 2147483647;
var e2 = /[^\\]\\Z/;
var r1 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var a1 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var o1 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var X3 = a0.date;
var Z3 = a0["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", ($) => {
    const W = $.replace(/"/g, "");
    if (r1.test(W) || a1.test(W) || o1.test(W) || X3(W)) {
      const X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", ($) => {
    const W = $.replace(/"/g, "");
    if (r1.test(W) || a1.test(W) || o1.test(W) || Z3(W)) {
      const X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
Object.entries(a0).forEach(($) => {
  const [W, X] = $;
  if (!exports_format.Has(W)) {
    if (X instanceof RegExp)
      TypeSystem.Format(W, (Z) => X.test(Z));
    else if (typeof X === "function")
      TypeSystem.Format(W, X);
  }
});
var V = Object.assign({}, Type);
var s1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var M1 = ($, W) => {
  if (!(W instanceof Blob))
    return false;
  if ($.minSize && W.size < s1($.minSize))
    return false;
  if ($.maxSize && W.size > s1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!W.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (W.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var j3 = exports_type.Get("Files") ?? TypeSystem.Type("File", M1);
var J3 = exports_type.Get("Files") ?? TypeSystem.Type("Files", ($, W) => {
  if (!Array.isArray(W))
    return M1($, W);
  if ($.minItems && W.length < $.minItems)
    return false;
  if ($.maxItems && W.length > $.maxItems)
    return false;
  for (let X = 0;X < W.length; X++)
    if (!M1($, W[X]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", ($) => $ === "true" || $ === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
exports_type.Set("UnionEnum", ($, W) => {
  return (typeof W === "number" || typeof W === "string" || W === null) && $.enum.includes(W);
});
var X0 = { Numeric: ($) => {
  const W = Type.Number($);
  return V.Transform(V.Union([V.String({ format: "numeric", default: 0 }), V.Number($)], $)).Decode((X) => {
    const Z = +X;
    if (isNaN(Z))
      return X;
    if ($ && !exports_value2.Check(W, Z))
      throw new E("property", W, Z);
    return Z;
  }).Encode((X) => X);
}, Date: ($) => {
  const W = Type.Date($);
  return V.Transform(V.Union([Type.Date($), V.String({ format: "date", default: new Date().toISOString() }), V.String({ format: "date-time", default: new Date().toISOString() })], $)).Decode((X) => {
    if (X instanceof Date)
      return X;
    const Z = new Date(X);
    if (!exports_value2.Check(W, Z))
      throw new E("property", W, Z);
    return Z;
  }).Encode((X) => {
    if (typeof X === "string")
      return new Date(X);
    return X;
  });
}, BooleanString: ($) => {
  const W = Type.Boolean($);
  return V.Transform(V.Union([V.String({ format: "boolean", default: false }), V.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value2.Check(W, X))
      throw new E("property", W, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, W) => {
  const X = V.Object($, W), Z = JSON.stringify(exports_value2.Create(X));
  let j;
  try {
    j = TypeCompiler.Compile(X);
  } catch {
  }
  return V.Transform(V.Union([V.String({ format: "ObjectString", default: Z }), X])).Decode((J) => {
    if (typeof J === "string") {
      if (J.charCodeAt(0) !== 123)
        throw new E("property", X, J);
      try {
        J = JSON.parse(J);
      } catch {
        throw new E("property", X, J);
      }
      if (j) {
        if (!j.Check(J))
          throw new E("property", X, J);
        return j.Decode(J);
      }
      if (!exports_value2.Check(X, J))
        throw new E("property", X, J);
      return exports_value2.Decode(X, J);
    }
    return J;
  }).Encode((J) => {
    if (typeof J === "string")
      try {
        J = JSON.parse(J);
      } catch {
        throw new E("property", X, J);
      }
    if (!exports_value2.Check(X, J))
      throw new E("property", X, J);
    return JSON.stringify(J);
  });
}, ArrayString: ($ = {}, W) => {
  const X = V.Array($, W), Z = JSON.stringify(exports_value2.Create(X));
  let j;
  try {
    j = TypeCompiler.Compile(X);
  } catch {
  }
  return V.Transform(V.Union([V.String({ format: "ArrayString", default: Z }), X])).Decode((J) => {
    if (typeof J === "string") {
      if (J.charCodeAt(0) !== 91)
        throw new E("property", X, J);
      try {
        J = JSON.parse(J);
      } catch {
        throw new E("property", X, J);
      }
      if (j) {
        if (!j.Check(J))
          throw new E("property", X, J);
        return j.Decode(J);
      }
      if (!exports_value2.Check(X, J))
        throw new E("property", X, J);
      return exports_value2.Decode(X, J);
    }
    return J;
  }).Encode((J) => {
    if (typeof J === "string")
      try {
        J = JSON.parse(J);
      } catch {
        throw new E("property", X, J);
      }
    if (!exports_value2.Check(X, J))
      throw new E("property", X, J);
    return JSON.stringify(J);
  });
}, File: j3, Files: ($ = {}) => V.Transform(J3($)).Decode((W) => {
  if (Array.isArray(W))
    return W;
  return [W];
}).Encode((W) => W), Nullable: ($) => V.Union([$, V.Null()]), MaybeEmpty: ($) => V.Union([$, V.Null(), V.Undefined()]), Cookie: ($, { domain: W, expires: X, httpOnly: Z, maxAge: j, path: J, priority: Q, sameSite: Y, secure: K, secrets: B, sign: U, ...w } = {}) => {
  const F = V.Object($, w);
  return F.config = { domain: W, expires: X, httpOnly: Z, maxAge: j, path: J, priority: Q, sameSite: Y, secure: K, secrets: B, sign: U }, F;
}, UnionEnum: ($, W = {}) => {
  const X = $.every((Z) => typeof Z === "string") ? { type: "string" } : $.every((Z) => typeof Z === "number") ? { type: "number" } : $.every((Z) => Z === null) ? { type: "null" } : {};
  if ($.some((Z) => typeof Z === "object" && Z !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: $[0], ...W, [Kind]: "UnionEnum", ...X, enum: $ };
} };
V.BooleanString = X0.BooleanString;
V.ObjectString = X0.ObjectString;
V.ArrayString = X0.ArrayString;
V.Numeric = X0.Numeric;
V.File = ($ = {}) => X0.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
V.Files = ($ = {}) => X0.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
V.Nullable = ($) => X0.Nullable($);
V.MaybeEmpty = X0.MaybeEmpty;
V.Cookie = X0.Cookie;
V.Date = X0.Date;
V.UnionEnum = X0.UnionEnum;
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var D1 = G3;
var N1 = Y3;
var Q3 = Object.prototype.toString;
var o0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var Z2 = w1(e0(), 1);

class w0 {
  $;
  W;
  X;
  constructor($, W, X = {}) {
    this.name = $;
    this.jar = W;
    this.initial = X;
  }
  get cookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set cookie($) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = $;
  }
  get value() {
    return this.cookie.value;
  }
  set value($) {
    this.cookie.value = $;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires($) {
    this.cookie.expires = $, console.log(this.cookie);
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge($) {
    this.cookie.maxAge = $;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain($) {
    this.cookie.domain = $;
  }
  get path() {
    return this.cookie.path;
  }
  set path($) {
    this.cookie.path = $;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure($) {
    this.cookie.secure = $;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly($) {
    this.cookie.httpOnly = $;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite($) {
    this.cookie.sameSite = $;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority($) {
    this.cookie.priority = $;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned($) {
    this.cookie.partitioned = $;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets($) {
    this.cookie.secrets = $;
  }
  update($) {
    return this.cookie = Object.assign(this.cookie, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  set($) {
    return this.cookie = Object.assign({ ...this.initial, value: this.value }, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var X2 = ($, W, X) => {
  if (!$.cookie)
    $.cookie = {};
  return new Proxy(W, { get(Z, j) {
    if (j in W)
      return new w0(j, $.cookie, Object.assign({}, X ?? {}, W[j]));
    return new w0(j, $.cookie, Object.assign({}, X));
  } });
};
var $1 = async ($, W, { secrets: X, sign: Z, ...j } = {}) => {
  if (!W)
    return X2($, {}, j);
  const J = typeof X === "string";
  if (Z && Z !== true && !Array.isArray(Z))
    Z = [Z];
  const Q = {}, Y = D1(W);
  for (let [K, B] of Object.entries(Y)) {
    let U = Z2.default(B);
    if (Z === true || Z?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (J) {
        const w = await I1(U, X);
        if (w === false)
          throw new u0(K);
        U = w;
      } else {
        let w = true;
        for (let F = 0;F < X.length; F++) {
          const G = await I1(U, X[F]);
          if (G !== false) {
            w = true, U = G;
            break;
          }
        }
        if (!w)
          throw new u0(K);
      }
    }
    Q[K] = { value: U };
  }
  return X2($, Q, j);
};
var j2 = "toJSON" in new Headers;
var p = ($) => {
  if (!$)
    return false;
  for (let W in $)
    return true;
  return false;
};
var h0 = ($, W) => {
  const X = $.size;
  if (!W && X || X && W && W.status !== 206 && W.status !== 304 && W.status !== 412 && W.status !== 416) {
    if (W && p(W.headers)) {
      if (W.headers instanceof Headers) {
        if (j2)
          W.headers = W.headers.toJSON();
        else
          for (let [Z, j] of W.headers.entries())
            if (Z in W.headers)
              W.headers[Z] = j;
      }
      return new Response($, { status: W.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, W.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}`, "transfer-encoding": "chunked" } });
  }
  return new Response($);
};
var J2 = ($, W) => {
  if (!$)
    return $;
  $.delete("set-cookie");
  for (let X = 0;X < W.length; X++) {
    const Z = W[X].indexOf("=");
    $.append("set-cookie", `${W[X].slice(0, Z)}=${W[X].slice(Z + 1) || ""}`);
  }
  return $;
};
var Q2 = ($) => {
  if (!$ || !p($))
    return;
  const W = [];
  for (let [X, Z] of Object.entries($)) {
    if (!X || !Z)
      continue;
    const j = Z.value;
    if (j === undefined || j === null)
      continue;
    W.push(N1(X, typeof j === "object" ? JSON.stringify(j) : j + "", Z));
  }
  if (W.length === 0)
    return;
  if (W.length === 1)
    return W[0];
  return W;
};
var B0 = async ($, W, X) => {
  let Z = $.next();
  if (Z instanceof Promise)
    Z = await Z;
  if (Z.done) {
    if (W)
      return g(Z.value, W, X);
    return Z0(Z.value, X);
  }
  return new Response(new ReadableStream({ async start(j) {
    let J = false;
    if (X?.signal.addEventListener("abort", () => {
      J = true;
      try {
        j.close();
      } catch {
      }
    }), Z.value !== undefined && Z.value !== null)
      if (typeof Z.value === "object")
        try {
          j.enqueue(Buffer.from(JSON.stringify(Z.value)));
        } catch {
          j.enqueue(Buffer.from(Z.value.toString()));
        }
      else
        j.enqueue(Buffer.from(Z.value.toString()));
    for await (let Q of $) {
      if (J)
        break;
      if (Q === undefined || Q === null)
        continue;
      if (typeof Q === "object")
        try {
          j.enqueue(Buffer.from(JSON.stringify(Q)));
        } catch {
          j.enqueue(Buffer.from(Q.toString()));
        }
      else
        j.enqueue(Buffer.from(Q.toString()));
      await new Promise((Y) => setTimeout(() => Y(), 0));
    }
    try {
      j.close();
    } catch {
    }
  } }), { ...W, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...W?.headers } });
};
var g = ($, W, X) => {
  if (p(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && p(W.cookie)) {
      const Z = Q2(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = J2(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        const Z = $[d];
        if (Z)
          return W.status = Z, g($.response, W, X);
        for (let J in Object.values($))
          switch (J?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($));
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return new Response("", W);
        return Response.json($, W);
      case "Response":
        let j = false;
        if (W.headers instanceof Headers)
          for (let J of W.headers.keys())
            if (J === "set-cookie") {
              if (j)
                continue;
              j = true;
              for (let Q of W.headers.getSetCookie())
                $.headers.append("set-cookie", Q);
            } else
              $.headers.append(J, W.headers?.get(J) ?? "");
        else
          for (let J in W.headers)
            $.headers.append(J, W.headers[J]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((J) => g(J, W));
      case "Function":
        return g($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response) {
          let J = false;
          if (W.headers instanceof Headers)
            for (let Q of W.headers.keys())
              if (Q === "set-cookie") {
                if (J)
                  continue;
                J = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(Q, W.headers?.get(Q) ?? "");
          else
            for (let Q in W.headers)
              $.headers.append(Q, W.headers[Q]);
          if (j2)
            W.headers = $.headers.toJSON();
          else
            for (let [Q, Y] of $.headers.entries())
              if (Q in W.headers)
                W.headers[Q] = Y;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => g(J, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return g($.toResponse(), W);
        if ("charCodeAt" in $) {
          const J = $.charCodeAt(0);
          if (J === 123 || J === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        const Z = $[d];
        if (Z)
          return W.status = Z, g($.response, W, X);
        for (let j in Object.values($))
          switch (j?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($), W);
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((j) => {
          const J = Z0(j, X);
          if (J !== undefined)
            return J;
          return new Response("");
        });
      case "Function":
        return Z0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response)
          return $;
        if ($ instanceof Promise)
          return $.then((j) => g(j, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return g($.toResponse(), W);
        if ("charCodeAt" in $) {
          const j = $.charCodeAt(0);
          if (j === 123 || j === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var k = ($, W, X) => {
  if ($ === undefined || $ === null)
    return;
  if (p(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && p(W.cookie)) {
      const Z = Q2(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = J2(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        const Z = $[d];
        if (Z)
          return W.status = Z, k($.response, W, X);
        for (let J in Object.values($))
          switch (J?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($), W);
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return;
        return Response.json($, W);
      case "Response":
        let j = false;
        if (W.headers instanceof Headers)
          for (let J of W.headers.keys())
            if (J === "set-cookie") {
              if (j)
                continue;
              j = true;
              for (let Q of W.headers.getSetCookie())
                $.headers.append("set-cookie", Q);
            } else
              $.headers.append(J, W.headers?.get(J) ?? "");
        else
          for (let J in W.headers)
            $.headers.append(J, W.headers[J]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Promise":
        return $.then((J) => {
          const Q = k(J, W);
          if (Q !== undefined)
            return Q;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return k($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "FormData":
        return new Response($);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response) {
          let J = false;
          if (W.headers instanceof Headers)
            for (let Q of W.headers.keys())
              if (Q === "set-cookie") {
                if (J)
                  continue;
                J = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(Q, W.headers?.get(Q) ?? "");
          else
            for (let Q in W.headers)
              $.headers.append(Q, W.headers[Q]);
          if ($.status !== W.status)
            W.status = $.status;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => k(J, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return k($.toResponse(), W);
        if ("charCodeAt" in $) {
          const J = $.charCodeAt(0);
          if (J === 123 || J === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        const Z = $[d];
        if (Z)
          return W.status = Z, k($.response, W, X);
        for (let j in Object.values($))
          switch (j?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($), W);
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($));
        return $;
      case "Promise":
        return $.then((j) => {
          const J = k(j, W);
          if (J !== undefined)
            return J;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return Z0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($);
      default:
        if ($ instanceof Response)
          return $;
        if ($ instanceof Promise)
          return $.then((j) => k(j, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return k($.toResponse(), W);
        if ("charCodeAt" in $) {
          const j = $.charCodeAt(0);
          if (j === 123 || j === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var Z0 = ($, W) => {
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return h0($);
    case "Array":
      return Response.json($);
    case "Object":
      if ($[d])
        return g($.response, { status: $[d], headers: {} });
      $:
        for (let X of Object.values($))
          switch (X?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($));
            case "Object":
              break $;
            default:
              break;
          }
      return Response.json($);
    case "ReadableStream":
      return W?.signal.addEventListener("abort", { handleEvent() {
        if (!W?.signal.aborted)
          $.cancel(W);
      } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      if ($.headers.get("transfer-encoding") === "chunked")
        return B0(m0($));
      return $;
    case "Error":
      return K0($);
    case "Promise":
      return $.then((X) => Z0(X, W));
    case "Function":
      return Z0($(), W);
    case "Number":
    case "Boolean":
      return new Response($.toString());
    case "FormData":
      return new Response($);
    default:
      if ($ instanceof Response)
        return $;
      if ($ instanceof Promise)
        return $.then((X) => Z0(X, W));
      if ($ instanceof Error)
        return K0($);
      if (typeof $?.next === "function")
        return B0($, undefined, W);
      if ("toResponse" in $)
        return Z0($.toResponse());
      if ("charCodeAt" in $) {
        const X = $.charCodeAt(0);
        if (X === 123 || X === 91)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      }
      return new Response($);
  }
};
var K0 = ($, W) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: W?.status !== 200 ? W?.status ?? 500 : 500, headers: W?.headers });
var G2 = ($, W, X = {}) => {
  if (typeof $ === "function")
    return;
  const Z = g($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0)
    return Z.clone.bind(Z);
};
var Y2 = ($, W, X = {}) => {
  if (typeof $ === "function" || $ instanceof Blob)
    return;
  const Z = g($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0) {
    if (!Z.headers.has("content-type"))
      Z.headers.append("content-type", "text/plain;charset=utf-8");
    return Z.clone.bind(Z);
  }
};
var b0 = ($, W) => {
  const X = new URL($);
  return X.pathname = W, X.toString();
};
var z3 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") && $.toString() !== "[object Object]" || p(Object.getPrototypeOf($));
var A1 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var c = ($, W, { skipKeys: X, override: Z = true } = {}) => {
  if (!A1($) || !A1(W))
    return $;
  for (let [j, J] of Object.entries(W)) {
    if (X?.includes(j))
      continue;
    if (!A1(J) || !(j in $) || z3(J)) {
      if (Z || !(j in $))
        $[j] = J;
      continue;
    }
    $[j] = c($[j], J, { skipKeys: X, override: Z });
  }
  return $;
};
var D3 = ($, W) => {
  const { properties: X, ...Z } = $ ?? {}, { properties: j, ...J } = W ?? {};
  return c(Z, J);
};
var f = ($ = [], W = []) => {
  if (!$)
    return [];
  if (!W)
    return $;
  const X = [], Z = [];
  if (!Array.isArray($))
    $ = [$];
  if (!Array.isArray(W))
    W = [W];
  for (let j of $)
    if (X.push(j), j.checksum)
      Z.push(j.checksum);
  for (let j of W)
    if (!Z.includes(j.checksum))
      X.push(j);
  return X;
};
var N3 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var P3 = N3.reduce(($, W) => ($[W] = true, $), {});
var w2 = ($, W) => {
  const X = (Z) => typeof Z === "object" && Object.keys(Z).every(j1);
  if (X($) && X(W))
    return { ...$, ...W };
  return W ?? $;
};
var x0 = ($, W) => {
  return { body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: w2($?.response, W?.response) };
};
var i = ($, W) => {
  return { ...$, ...W, body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: w2($?.response, W?.response), type: $?.type || W?.type, detail: c(W?.detail ?? {}, $?.detail ?? {}), parse: f($?.parse, W?.parse), transform: f($?.transform, W?.transform), beforeHandle: f($?.beforeHandle, W?.beforeHandle), afterHandle: f($?.afterHandle, W?.afterHandle), mapResponse: f($?.mapResponse, W?.mapResponse), afterResponse: f($?.afterResponse, W?.afterResponse), trace: f($?.trace, W?.trace), error: f($?.error, W?.error) };
};
var C1 = ($, W, X = true) => {
  if (!Array.isArray(W))
    return h($, W, X);
  for (let Z of W)
    $ = h($, Z, X);
  return $;
};
var h = ($, W, X = true) => {
  if (!$)
    return $;
  if (W.untilObjectFound && !X && $.type === "object")
    return $;
  const Z = W.from[Kind];
  if ($.oneOf) {
    for (let Q = 0;Q < $.oneOf.length; Q++)
      $.oneOf[Q] = h($.oneOf[Q], W, X);
    return $;
  }
  if ($.anyOf) {
    for (let Q = 0;Q < $.anyOf.length; Q++)
      $.anyOf[Q] = h($.anyOf[Q], W, X);
    return $;
  }
  if ($.allOf) {
    for (let Q = 0;Q < $.allOf.length; Q++)
      $.allOf[Q] = h($.allOf[Q], W, X);
    return $;
  }
  if ($.not) {
    for (let Q = 0;Q < $.not.length; Q++)
      $.not[Q] = h($.not[Q], W, X);
    return $;
  }
  const j = X && !!W.excludeRoot;
  if ($[Kind] === Z) {
    const { anyOf: Q, oneOf: Y, allOf: K, not: B, properties: U, items: w, ...F } = $, G = W.to(F);
    let z;
    const D = (M) => {
      if (U && M.type === "object") {
        const O = {};
        for (let [P, b] of Object.entries(U))
          O[P] = h(b, W, false);
        return { ...F, ...M, properties: O };
      }
      if (w && M.type === "array")
        return { ...F, ...M, items: h(w, W, false) };
      const I = { ...F, ...M };
      if (delete I.required, U && M.type === "string" && M.format === "ObjectString" && M.default === "{}")
        z = V.ObjectString(U, F), I.default = JSON.stringify(exports_value2.Create(V.Object(U))), I.properties = U;
      if (w && M.type === "string" && M.format === "ArrayString" && M.default === "[]")
        z = V.ArrayString(w, F), I.default = JSON.stringify(exports_value2.Create(V.Array(w))), I.items = w;
      return I;
    };
    if (j) {
      if (U) {
        const M = {};
        for (let [I, O] of Object.entries(U))
          M[I] = h(O, W, false);
        return { ...F, properties: M };
      } else if (w?.map)
        return { ...F, items: w.map((M) => h(M, W, false)) };
      return F;
    }
    if (G.anyOf)
      for (let M = 0;M < G.anyOf.length; M++)
        G.anyOf[M] = D(G.anyOf[M]);
    else if (G.oneOf)
      for (let M = 0;M < G.oneOf.length; M++)
        G.oneOf[M] = D(G.oneOf[M]);
    else if (G.allOf)
      for (let M = 0;M < G.allOf.length; M++)
        G.allOf[M] = D(G.allOf[M]);
    else if (G.not)
      for (let M = 0;M < G.not.length; M++)
        G.not[M] = D(G.not[M]);
    if (z)
      G[TransformKind] = z[TransformKind];
    if (G.anyOf || G.oneOf || G.allOf || G.not)
      return G;
    if (U) {
      const M = {};
      for (let [I, O] of Object.entries(U))
        M[I] = h(O, W, false);
      return { ...F, ...G, properties: M };
    } else if (w?.map)
      return { ...F, ...G, items: w.map((M) => h(M, W, false)) };
    return { ...F, ...G };
  }
  const J = $?.properties;
  if (J && X && W.rootOnly !== true)
    for (let [Q, Y] of Object.entries(J))
      switch (Y[Kind]) {
        case Z:
          const { anyOf: K, oneOf: B, allOf: U, not: w, type: F, ...G } = Y, z = W.to(G);
          if (z.anyOf)
            for (let D = 0;D < z.anyOf.length; D++)
              z.anyOf[D] = { ...G, ...z.anyOf[D] };
          else if (z.oneOf)
            for (let D = 0;D < z.oneOf.length; D++)
              z.oneOf[D] = { ...G, ...z.oneOf[D] };
          else if (z.allOf)
            for (let D = 0;D < z.allOf.length; D++)
              z.allOf[D] = { ...G, ...z.allOf[D] };
          else if (z.not)
            for (let D = 0;D < z.not.length; D++)
              z.not[D] = { ...G, ...z.not[D] };
          J[Q] = { ...G, ...h(G, W, false) };
          break;
        case "Object":
        case "Union":
          J[Q] = h(Y, W, false);
          break;
        default:
          if (Y.items)
            for (let D = 0;D < Y.items.length; D++)
              Y.items[D] = h(Y.items[D], W, false);
          else if (Y.anyOf || Y.oneOf || Y.allOf || Y.not)
            J[Q] = h(Y, W, false);
          break;
      }
  return $;
};
var m = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: j = false, coerce: J = false, additionalCoerce: Q = [] } = {}) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  let Y = typeof $ === "string" ? W[$] : $;
  if (J || Q)
    if (J)
      Y = C1(Y, [{ from: V.Number(), to: (U) => V.Numeric(U), untilObjectFound: true }, { from: V.Boolean(), to: (U) => V.BooleanString(U), untilObjectFound: true }, ...Array.isArray(Q) ? Q : [Q]]);
    else
      Y = C1(Y, [...Array.isArray(Q) ? Q : [Q]]);
  if (Y.type === "object" && "additionalProperties" in Y === false)
    Y.additionalProperties = j;
  const K = (U) => exports_value2.Clean(Y, U);
  if (X) {
    const U = { schema: Y, references: "", checkFunc: () => {
    }, code: "", Check: (w) => exports_value2.Check(Y, w), Errors: (w) => exports_value2.Errors(Y, w), Code: () => "", Clean: K, Decode: (w) => exports_value2.Decode(Y, w), Encode: (w) => exports_value2.Encode(Y, w) };
    if (Z && Y.additionalProperties === false)
      U.Clean = K;
    if (Y.config) {
      if (U.config = Y.config, U?.schema?.config)
        delete U.schema.config;
    }
    return U.parse = (w) => {
      try {
        return U.Decode(w);
      } catch (F) {
        throw [...U.Errors(w)].map(o);
      }
    }, U.safeParse = (w) => {
      try {
        return { success: true, data: U.Decode(w), error: null };
      } catch (F) {
        const G = [...B.Errors(w)].map(o);
        return { success: false, data: null, error: G[0]?.summary, errors: G };
      }
    }, U;
  }
  const B = TypeCompiler.Compile(Y, Object.values(W));
  if (B.Clean = K, Y.config) {
    if (B.config = Y.config, B?.schema?.config)
      delete B.schema.config;
  }
  return B.parse = (U) => {
    try {
      return B.Decode(U);
    } catch (w) {
      throw [...B.Errors(U)].map(o);
    }
  }, B.safeParse = (U) => {
    try {
      return { success: true, data: B.Decode(U), error: null };
    } catch (w) {
      const F = [...B.Errors(U)].map(o);
      return { success: false, data: null, error: F[0]?.summary, errors: F };
    }
  }, B;
};
var W1 = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: j = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  const J = typeof $ === "string" ? W[$] : $, Q = (K, B) => {
    const U = (F) => {
      if (!F || typeof F !== "object")
        return exports_value2.Clean(K, F);
      if (Array.isArray(F))
        F = exports_value2.Clean(K, F);
      else
        F = exports_value2.Clean(K, F);
      return F;
    };
    if (X)
      return { schema: K, references: "", checkFunc: () => {
      }, code: "", Check: (F) => exports_value2.Check(K, F), Errors: (F) => exports_value2.Errors(K, F), Code: () => "", Decode: (F) => exports_value2.Decode(K, F), Encode: (F) => exports_value2.Encode(K, F) };
    const w = TypeCompiler.Compile(K, B);
    if (Z && K.additionalProperties === false)
      w.Clean = U;
    return w;
  };
  if (Kind in J) {
    if ("additionalProperties" in J === false)
      J.additionalProperties = j;
    return { 200: Q(J, Object.values(W)) };
  }
  const Y = {};
  return Object.keys(J).forEach((K) => {
    const B = J[+K];
    if (typeof B === "string") {
      if (B in W) {
        const U = W[B];
        U.type === "object" && "additionalProperties" in U, Y[+K] = Kind in U ? Q(U, Object.values(W)) : U;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = j;
    Y[+K] = Kind in B ? Q(B, Object.values(W)) : B;
  }), Y;
};
var I3 = typeof Bun !== "undefined";
var A3 = I3 && typeof Bun.hash === "function";
var P0 = ($) => {
  if (A3)
    return Bun.hash($);
  let W = 9;
  for (let X = 0;X < $.length; )
    W = Math.imul(W ^ $.charCodeAt(X++), 387420489);
  return W = W ^ W >>> 9;
};
var O1;
var D0 = () => {
  if (!O1)
    O1 = [{ from: V.Object({}), to: () => V.ObjectString({}), excludeRoot: true }, { from: V.Array(V.Any()), to: () => V.ArrayString(V.Any()) }];
  return O1;
};
var V1;
var S1 = () => {
  if (!V1)
    V1 = [{ from: V.Number(), to: ($) => V.Numeric($), rootOnly: true }, { from: V.Boolean(), to: ($) => V.BooleanString($), rootOnly: true }];
  return V1;
};
var X1 = ({ validator: $, defaultConfig: W = {}, config: X, dynamic: Z, models: j }) => {
  let J = m($, { dynamic: Z, models: j, additionalProperties: true, coerce: true, additionalCoerce: D0() });
  if (p(W))
    if (J)
      J.config = D3(J.config, X);
    else
      J = m(V.Cookie({}), { dynamic: Z, models: j, additionalProperties: true }), J.config = W;
  return J;
};
var j0 = ($, W) => {
  if (!W)
    return;
  if (!Array.isArray(W)) {
    const Z = W;
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
    return Z;
  }
  const X = [...W];
  for (let Z of X) {
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
  }
  return X;
};
var L1 = ($, W, X) => {
  return { start: f($.start, j0(X, W?.start)), request: f($.request, j0(X, W?.request)), parse: f($.parse, j0(X, W?.parse)), transform: f($.transform, j0(X, W?.transform)), beforeHandle: f($.beforeHandle, j0(X, W?.beforeHandle)), afterHandle: f($.afterHandle, j0(X, W?.afterHandle)), mapResponse: f($.mapResponse, j0(X, W?.mapResponse)), afterResponse: f($.afterResponse, j0(X, W?.afterResponse)), trace: f($.trace, j0(X, W?.trace)), error: f($.error, j0(X, W?.error)), stop: f($.stop, j0(X, W?.stop)) };
};
var _2 = ($, W, { skipIfHasType: X = false } = {}) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (X)
      $.scope ??= W;
    else
      $.scope = W;
    return $;
  }
  for (let Z of $)
    if (X)
      Z.scope ??= W;
    else
      Z.scope = W;
  return $;
};
var z0 = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($))
    switch ($.scope) {
      case "global":
      case "scoped":
        return { ...$ };
      default:
        return { fn: $ };
    }
  const W = [];
  for (let X of $)
    switch (X.scope) {
      case "global":
      case "scoped":
        W.push({ ...X });
        break;
    }
  return W;
};
var T1 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: z0($?.parse), transform: z0($?.transform), beforeHandle: z0($?.beforeHandle), afterHandle: z0($?.afterHandle), mapResponse: z0($?.mapResponse), afterResponse: z0($?.afterResponse), error: z0($?.error), trace: z0($?.trace) };
};
var _0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var Z1 = Object.fromEntries(Object.entries(_0).map(([$, W]) => [W, $]));
var K2 = new TextEncoder;
var g0 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const X = await crypto.subtle.importKey("raw", K2.encode(W), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), Z = await crypto.subtle.sign("HMAC", X, K2.encode($));
  return $ + "." + O3(Buffer.from(Z).toString("base64"));
};
var I1 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const X = $.slice(0, $.lastIndexOf("."));
  return await g0(X, W) === $ ? X : false;
};
var F2 = ($, W) => {
  if (!$ || typeof $ !== "object" || !W)
    return;
  for (let [X, Z] of Object.entries(W)) {
    if (X in P3 || !(X in $))
      continue;
    const j = $[X];
    if (typeof j === "function")
      j(Z), delete W[X];
  }
};
var M2 = ({ globalHook: $, localHook: W }) => (X) => (Z, j) => {
  if (typeof Z === "function")
    Z = { fn: Z };
  if ("fn" in Z || Array.isArray(Z)) {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (Array.isArray(Z))
      W[X] = W[X].concat(Z);
    else
      W[X].push(Z);
    return;
  }
  const { insert: J = "after", stack: Q = "local" } = Z;
  if (typeof j === "function")
    j = { fn: j };
  if (Q === "global")
    if (!Array.isArray(j))
      if (J === "before")
        $[X].unshift(j);
      else
        $[X].push(j);
    else if (J === "before")
      $[X] = j.concat($[X]);
    else
      $[X] = $[X].concat(j);
  else {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (!Array.isArray(j))
      if (J === "before")
        W[X].unshift(j);
      else
        W[X].push(j);
    else if (J === "before")
      W[X] = j.concat(W[X]);
    else
      W[X] = W[X].concat(j);
  }
};
var V3 = ($) => {
  if (typeof $ === "number")
    return $;
  if ($.length < 16) {
    if ($.trim().length === 0)
      return null;
    const W = Number($);
    if (Number.isNaN(W))
      return null;
    return W;
  }
  if ($.length === 16) {
    if ($.trim().length === 0)
      return null;
    const W = Number($);
    if (Number.isNaN(W) || W.toString() !== $)
      return null;
    return W;
  }
  return null;
};
var j1 = ($) => V3($) !== null;

class q1 {
  $;
  root = null;
  promises = [];
  constructor($ = console.error) {
    this.onError = $;
  }
  get size() {
    return this.promises.length;
  }
  add($) {
    return this.promises.push($), this.root ||= this.drain(), $;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch ($) {
        this.onError($);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then($, W) {
    return (this.root ?? Promise.resolve()).then($, W);
  }
}
var n = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (typeof $ === "function")
      return { fn: $ };
    else if ("fn" in $)
      return $;
  }
  const W = [];
  for (let X of $)
    if (typeof X === "function")
      W.push({ fn: X });
    else if ("fn" in X)
      W.push(X);
  return W;
};
var z2 = ($) => {
  return { ...$, start: n($?.start), request: n($?.request), parse: n($?.parse), transform: n($?.transform), beforeHandle: n($?.beforeHandle), afterHandle: n($?.afterHandle), mapResponse: n($?.mapResponse), afterResponse: n($?.afterResponse), trace: n($?.trace), error: n($?.error), stop: n($?.stop) };
};
var E1 = ($) => {
  return { ...$, start: $.start?.map((W) => W.fn), request: $.request?.map((W) => W.fn), parse: $.parse?.map((W) => W.fn), transform: $.transform?.map((W) => W.fn), beforeHandle: $.beforeHandle?.map((W) => W.fn), afterHandle: $.afterHandle?.map((W) => W.fn), afterResponse: $.afterResponse?.map((W) => W.fn), mapResponse: $.mapResponse?.map((W) => W.fn), trace: $.trace?.map((W) => W.fn), error: $.error?.map((W) => W.fn), stop: $.stop?.map((W) => W.fn) };
};
var d0 = ($) => ({ body: $.body, cookie: $.cookie, headers: $.headers, query: $.query, set: $.set, server: $.server });
var c0 = ($, W = 302) => Response.redirect($, W);
var C3 = Symbol("ElysiaFormData");
var I0 = Symbol("ElysiaRequestId");
var N0 = ($) => {
  const W = new FormData;
  for (let [X, Z] of Object.entries($)) {
    if (Array.isArray(Z)) {
      for (let j of Z) {
        if (Z instanceof File)
          W.append(X, Z, Z.name);
        W.append(X, j);
      }
      continue;
    }
    if (Z instanceof File)
      W.append(X, Z, Z.name);
    W.append(X, Z);
  }
  return W;
};
var J1 = () => crypto.getRandomValues(new Uint32Array(1))[0];
var Q1 = ($) => {
  const W = [];
  for (let X = 0;X < $.length; X++) {
    const Z = $[X];
    if (Z.checksum) {
      if (W.includes(Z.checksum))
        $.splice(X, 1), X--;
      W.push(Z.checksum);
    }
  }
  return $;
};
var v = ($, W = "scoped") => {
  if (W === "scoped") {
    for (let X of $)
      if ("scope" in X && X.scope === "local")
        X.scope = "scoped";
    return;
  }
  for (let X of $)
    if ("scope" in X)
      X.scope = "global";
};
var D2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var A0 = Symbol("ElysiaErrorCode");
var d = Symbol("ElysiaResponse");
var l0 = (D2?.NODE_ENV ?? D2?.ENV) === "production";
var H1 = ($, W) => {
  const X = W ?? ($ in Z1 ? Z1[$] : $);
  return { [d]: _0[$] ?? $, response: X, _type: undefined, error: new Error(X) };
};

class G1 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class O0 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}

class Y1 extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Failed to parse body");
  }
}

class u0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, W) {
    super(W ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}
var o = ($) => {
  if (!$)
    return { summary: undefined };
  const { message: W, path: X, value: Z, type: j } = $, J = X.slice(1).replaceAll("/", "."), Q = X === "";
  switch (j) {
    case 42:
      return { ...$, summary: Q ? "Value should not be provided" : `Property '${J}' should not be provided` };
    case 45:
      return { ...$, summary: Q ? "Value is missing" : `Property '${J}' is missing` };
    case 50:
      const Y = W.indexOf("'"), K = W.slice(Y + 1, W.indexOf("'", Y + 1));
      return { ...$, summary: Q ? "Value should be an email" : `Property '${J}' should be ${K}` };
    case 54:
      return { ...$, summary: `${W.slice(0, 9)} property '${J}' to be ${W.slice(8)} but found: ${Z}` };
    case 62:
      const B = $.schema.anyOf.map((U) => `'${U?.format ?? U.type}'`).join(", ");
      return { ...$, summary: Q ? `Value should be one of ${B}` : `Property '${J}' should be one of: ${B}` };
    default:
      return { summary: W, ...$ };
  }
};

class E extends Error {
  $;
  W;
  X;
  code = "VALIDATION";
  status = 422;
  constructor($, W, X) {
    if (X && typeof X === "object" && d in X)
      X = X.response;
    const Z = l0 ? undefined : ("Errors" in W) ? W.Errors(X).First() : exports_value2.Errors(W, X).First(), j = Z?.schema.error !== undefined ? typeof Z.schema.error === "function" ? Z.schema.error({ type: $, validator: W, value: X, get errors() {
      return [...W.Errors(X)].map(o);
    } }) : Z.schema.error : undefined, J = Z?.path || "root";
    let Q = "";
    if (j !== undefined)
      Q = typeof j === "object" ? JSON.stringify(j) : j + "";
    else if (l0)
      Q = JSON.stringify({ type: "validation", on: $, summary: o(Z).summary, message: Z?.message, found: X });
    else {
      const Y = W?.schema ?? W, K = "Errors" in W ? [...W.Errors(X)].map(o) : [...exports_value2.Errors(W, X)].map(o);
      let B;
      try {
        B = exports_value2.Create(Y);
      } catch (U) {
        B = { type: "Could not create expected value", message: U?.message, error: U };
      }
      Q = JSON.stringify({ type: "validation", on: $, summary: K[0]?.summary, property: J, message: Z?.message, expected: B, found: X, errors: K }, null, 2);
    }
    super(Q);
    this.type = $;
    this.validator = W;
    this.value = X;
    Object.setPrototypeOf(this, E.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(o) : [...exports_value2.Errors(this.validator, this.value)].map(o);
  }
  static simplifyModel($) {
    const W = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(W);
    } catch {
      return W;
    }
  }
  get model() {
    return E.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: { ...$, "content-type": "application/json" } });
  }
}
var R1 = { open($) {
  $.data.open?.($);
}, message($, W) {
  $.data.message?.($, W);
}, drain($) {
  $.data.drain?.($);
}, close($, W, X) {
  $.data.close?.($, W, X);
} };

class f0 {
  $;
  W;
  validator;
  _validator;
  constructor($, W) {
    this.raw = $;
    this.data = W;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else
      this.id = J1().toString();
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, W = undefined, X) => {
      if (this.validator?.Check(W) === false)
        throw new E("message", this.validator, W);
      if (typeof W === "object")
        W = JSON.stringify(W);
      return this.raw.publish($, W, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new E("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var b1 = "1.1.17";
var V0 = w1(e0(), 1);
var y0 = /\+/g;
var i0 = ($) => {
  const W = {};
  if (typeof $ !== "string")
    return W;
  const X = $.length;
  let Z = "", j = "", J = -1, Q = -1, Y = false, K = false, B = false, U = false, w = false, F = 0;
  for (let G = 0;G < X + 1; G++) {
    if (G !== X)
      F = $.charCodeAt(G);
    else
      F = 38;
    switch (F) {
      case 38: {
        if (w = Q > J, !w)
          Q = G;
        if (Z = $.slice(J + 1, Q), w || Z.length > 0) {
          if (B)
            Z = Z.replace(y0, " ");
          if (Y)
            Z = V0.default(Z) || Z;
          if (w) {
            if (j = $.slice(Q + 1, G), U)
              j = j.replace(y0, " ");
            if (K)
              j = V0.default(j) || j;
          }
          const z = W[Z];
          if (z === undefined)
            W[Z] = j;
          else if (z.pop)
            z.push(j);
          else
            W[Z] = [z, j];
        }
        j = "", J = G, Q = G, Y = false, K = false, B = false, U = false;
        break;
      }
      case 61:
        if (Q <= J)
          Q = G;
        else
          K = true;
        break;
      case 43:
        if (Q > J)
          U = true;
        else
          B = true;
        break;
      case 37:
        if (Q > J)
          K = true;
        else
          Y = true;
        break;
    }
  }
  return W;
};
var P2 = w1(e0(), 1);
var n0 = Symbol("ElysiaTrace");
var F0 = () => {
  const { promise: $, resolve: W } = Promise.withResolvers(), { promise: X, resolve: Z } = Promise.withResolvers(), { promise: j, resolve: J } = Promise.withResolvers(), Q = [], Y = [];
  return [(K) => {
    if (K)
      Q.push(K);
    return $;
  }, (K) => {
    const B = [], U = [];
    let w = null;
    for (let G = 0;G < (K.total ?? 0); G++) {
      const { promise: z, resolve: D } = Promise.withResolvers(), { promise: M, resolve: I } = Promise.withResolvers(), { promise: O, resolve: P } = Promise.withResolvers(), b = [], T = [];
      B.push((q) => {
        if (q)
          b.push(q);
        return z;
      }), U.push((q) => {
        const s = { ...q, end: M, error: O, index: G, onStop(L) {
          if (L)
            T.push(L);
          return M;
        } };
        D(s);
        for (let L = 0;L < b.length; L++)
          b[L](s);
        return (L = null) => {
          const x = performance.now();
          if (L)
            w = L;
          const R = { end: x, error: L, get elapsed() {
            return x - q.begin;
          } };
          for (let G0 = 0;G0 < T.length; G0++)
            T[G0](R);
          I(x), P(L);
        };
      });
    }
    const F = { ...K, end: X, error: j, onEvent(G) {
      for (let z = 0;z < B.length; z++)
        B[z](G);
    }, onStop(G) {
      if (G)
        Y.push(G);
      return X;
    } };
    W(F);
    for (let G = 0;G < Q.length; G++)
      Q[G](F);
    return { resolveChild: U, resolve(G = null) {
      const z = performance.now();
      if (!G && w)
        G = w;
      const D = { end: z, error: G, get elapsed() {
        return z - K.begin;
      } };
      for (let M = 0;M < Y.length; M++)
        Y[M](D);
      Z(z), J(G);
    } };
  }];
};
var N2 = ($) => {
  return (W) => {
    const [X, Z] = F0(), [j, J] = F0(), [Q, Y] = F0(), [K, B] = F0(), [U, w] = F0(), [F, G] = F0(), [z, D] = F0(), [M, I] = F0(), [O, P] = F0();
    return $({ id: W[I0], context: W, set: W.set, onRequest: X, onParse: j, onTransform: Q, onBeforeHandle: K, onHandle: U, onAfterHandle: F, onMapResponse: M, onAfterResponse: O, onError: z }), { request: Z, parse: J, transform: Y, beforeHandle: B, handle: w, afterHandle: G, error: D, mapResponse: I, afterResponse: P };
  };
};
var T3 = new Headers().toJSON;
var I2 = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var t = ($) => {
  if (!$)
    return false;
  const W = $?.schema;
  return !!W && I2.optional in W;
};
var J0 = ($) => {
  if (!$)
    return false;
  const W = $?.schema ?? $;
  if (W.anyOf)
    return W.anyOf.some(J0);
  if (W.someOf)
    return W.someOf.some(J0);
  if (W.allOf)
    return W.allOf.some(J0);
  if (W.not)
    return W.not.some(J0);
  if (W.type === "object") {
    const X = W.properties;
    if ("additionalProperties" in W)
      return W.additionalProperties;
    for (let Z of Object.keys(X)) {
      const j = X[Z];
      if (j.type === "object") {
        if (J0(j))
          return true;
      } else if (j.anyOf) {
        for (let J = 0;J < j.anyOf.length; J++)
          if (J0(j.anyOf[J]))
            return true;
      }
      return j.additionalProperties;
    }
    return false;
  }
  return false;
};
var g1 = ({ context: $ = "c", trace: W, addFn: X }) => {
  if (!W.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let Z = 0;Z < W.length; Z++)
    X(`let report${Z}, reportChild${Z}, reportErr${Z}, reportErrChild${Z}; let trace${Z} = ${$}[ELYSIA_TRACE]?.[${Z}] ?? trace[${Z}](${$});\n`);
  return (Z, { name: j, total: J = 0 } = {}) => {
    if (!j)
      j = "anonymous";
    const Q = Z === "error" ? "reportErr" : "report";
    for (let Y = 0;Y < W.length; Y++)
      X(`\n${Q}${Y} = trace${Y}.${Z}({id,event: '${Z}',name: '${j}',begin: performance.now(),total: ${J}})\n`);
    return { resolve() {
      for (let Y = 0;Y < W.length; Y++)
        X(`\n${Q}${Y}.resolve()\n`);
    }, resolveChild(Y) {
      for (let K = 0;K < W.length; K++)
        X(`${Q}Child${K} = ${Q}${K}.resolveChild?.shift()?.({id,event: '${Z}',name: '${Y}',begin: performance.now()})\n`);
      return (K) => {
        for (let B = 0;B < W.length; B++)
          if (K)
            X(`
                             	if (${K} instanceof Error)
                    				${Q}Child${B}?.(${K})
                           		else
                             		${Q}Child${B}?.()\n`);
          else
            X(`${Q}Child${B}?.()\n`);
      };
    } };
  };
};
var q3 = ({ injectResponse: $ = "", normalize: W = false, validator: X }) => ({ composeValidation: (Z, j = `c.${Z}`) => `c.set.status = 422; throw new ValidationError('${Z}', validator.${Z}, ${j})`, composeResponseValidation: (Z = "r") => {
  let j = "\n" + $ + "\n";
  j += `if(typeof ${Z} === "object" && ${Z} && ELYSIA_RESPONSE in ${Z}) {
			c.set.status = ${Z}[ELYSIA_RESPONSE]
			${Z} = ${Z}.response
		}

		const isResponse = ${Z} instanceof Response\n\n`, j += "switch(c.set.status) {\n";
  for (let [J, Q] of Object.entries(X.response)) {
    if (j += `\tcase ${J}:
				if (!isResponse) {\n`, W && "Clean" in Q && !J0(Q))
      j += `${Z} = validator.response['${J}'].Clean(${Z})\n`;
    j += `if(validator.response['${J}'].Check(${Z}) === false) {
					c.set.status = 422

					throw new ValidationError('response', validator.response['${J}'], ${Z})
				}

				c.set.status = ${J}
			}

			break\n\n`;
  }
  return j += "\n}\n", j;
} });
var n8 = Symbol.for("TypeBox.Kind");
var C0 = ($, W) => {
  if (!W)
    return;
  if (W.type === "object") {
    const X = W.properties;
    if (!X)
      return false;
    for (let Z of Object.keys(X)) {
      const j = X[Z];
      if ($ in j)
        return true;
      if (j.type === "object") {
        if (C0($, j))
          return true;
      } else if (j.anyOf) {
        for (let J = 0;J < j.anyOf.length; J++)
          if (C0($, j.anyOf[J]))
            return true;
      }
    }
    return false;
  }
  return $ in W;
};
var x1 = Symbol.for("TypeBox.Transform");
var S0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const W = $.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (S0(Z))
          return true;
      } else if (Z.anyOf) {
        for (let J = 0;J < Z.anyOf.length; J++)
          if (S0(Z.anyOf[J]))
            return true;
      }
      if (x1 in Z)
        return true;
    }
    return false;
  }
  return x1 in $ || $.properties && x1 in $.properties;
};
var E3 = /(?:return|=>) \S+\(/g;
var L0 = ($) => {
  return ($?.fn ?? $).constructor.name === "AsyncFunction";
};
var y = ($) => {
  const W = $?.fn ?? $;
  if (W.constructor.name === "AsyncFunction")
    return true;
  const X = W.toString();
  if (X.includes("=> response.clone("))
    return false;
  if (X.includes("await"))
    return true;
  if (X.includes("async"))
    return true;
  return !!X.match(E3);
};
var K1 = ($) => {
  const W = $?.fn ?? $;
  return W.constructor.name === "AsyncGeneratorFunction" || W.constructor.name === "GeneratorFunction";
};
var A2 = ({ app: $, path: W, method: X, localHook: Z, hooks: j, validator: J, handler: Q, allowMeta: Y = false, inference: K }) => {
  const B = typeof Q === "function";
  if (!B) {
    if (Q = g(Q, { headers: $.setHeaders ?? {} }), j.parse.length === 0 && j.transform.length === 0 && j.beforeHandle.length === 0 && j.afterHandle.length === 0)
      return Function("a", "return function () { return a.clone() }")(Q);
  }
  const U = B ? "handler(c)" : "handler", w = j.afterResponse.length > 0, F = j.trace.length > 0;
  let G = "";
  if (K = r0(Object.assign(Z, { handler: Q }), K), K.server)
    G += `\nObject.defineProperty(c, 'server', {
			get: function() { return getServer() }
		})\n`;
  if (K.body)
    G += "let isParsing = false\n";
  J.createBody?.(), J.createQuery?.(), J.createHeaders?.(), J.createParams?.(), J.createCookie?.(), J.createResponse?.();
  const z = K.query || !!J.query, D = X !== "$INTERNALWS" && X !== "GET" && X !== "HEAD" && (K.body || !!J.body || j.parse.length), M = $.setHeaders, I = M && !!Object.keys(M).length, O = K.headers || J.headers, P = K.cookie || !!J.cookie, b = P ? X1({ validator: J.cookie, defaultConfig: $.config.cookie, dynamic: !!$.config.aot, config: J.cookie?.config ?? {}, models: $.definitions.type }) : undefined, T = b?.config;
  let q = "";
  if (T?.sign) {
    if (!T.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${X}) ${W}.`);
    const N = !T.secrets ? undefined : typeof T.secrets === "string" ? T.secrets : T.secrets[0];
    if (q += `const _setCookie = c.set.cookie
		if(_setCookie) {`, T.sign === true)
      q += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${N}')
			}`;
    else
      for (let _ of T.sign)
        q += `if(_setCookie['${_}']?.value) { c.set.cookie['${_}'].value = await signCookie(_setCookie['${_}'].value, '${N}') }\n`;
    q += "}\n";
  }
  const s = $.config.normalize, { composeValidation: L, composeResponseValidation: x } = q3({ normalize: s, validator: J });
  if (O)
    G += T3 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (P) {
    const N = (A, C) => {
      const S = T?.[A] ?? C;
      if (!S)
        return typeof C === "string" ? `${A}: "${C}",` : `${A}: ${C},`;
      if (typeof S === "string")
        return `${A}: '${S}',`;
      if (S instanceof Date)
        return `${A}: new Date(${S.getTime()}),`;
      return `${A}: ${S},`;
    }, _ = T ? `{
			secrets: ${T.secrets !== undefined ? typeof T.secrets === "string" ? `'${T.secrets}'` : "[" + T.secrets.reduce((A, C) => A + `'${C}',`, "") + "]" : "undefined"},
			sign: ${T.sign === true ? true : T.sign !== undefined ? "[" + T.sign.reduce((A, C) => A + `'${C}',`, "") + "]" : "undefined"},
			${N("domain")}
			${N("expires")}
			${N("httpOnly")}
			${N("maxAge")}
			${N("path", "/")}
			${N("priority")}
			${N("sameSite")}
			${N("secure")}
		}` : "undefined";
    if (O)
      G += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${_})\n`;
    else
      G += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${_})\n`;
  }
  if (z) {
    const N = [];
    if (J.query && J.query.schema.type === "object") {
      const _ = J.query.schema.properties;
      if (!J0(J.query))
        for (let [A, C] of Object.entries(_)) {
          let S = C;
          if (S && I2.optional in S && S.type === "array" && S.items)
            S = S.items;
          const { type: a, anyOf: H } = S, U0 = a === "array" || H?.some((u) => u.type === "string" && u.format === "ArrayString");
          N.push({ key: A, isArray: U0, isNestedObjectArray: U0 && S.items?.type === "object" || !!S.items?.anyOf?.some((u) => u.type === "object" || u.type === "array"), isObject: a === "object" || H?.some((u) => u.type === "string" && u.format === "ArrayString"), anyOf: !!H });
        }
    }
    if (!N.length)
      G += `if(c.qi === -1) {
				c.query = {}
			} else {
				c.query = parseQueryFromURL(c.url.slice(c.qi + 1))
			}`;
    else
      G += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1)

				${N.map(({ key: _, isArray: A, isObject: C, isNestedObjectArray: S, anyOf: a }, H) => {
        const U0 = `${H === 0 ? "let" : ""} memory = url.indexOf('&${_}=')
							let a${H}\n`;
        if (A)
          return U0 + (S ? `while (memory !== -1) {
											const start = memory + ${_.length + 2}
											memory = url.indexOf('&', start)

											if(a${H} === undefined)
												a${H} = ''
											else
												a${H} += ','

											let temp

											if(memory === -1) temp = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
											else temp = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

											const charCode = temp.charCodeAt(0)
											if(charCode !== 91 && charCode !== 123)
												temp = '"' + temp + '"'

											a${H} += temp

											if(memory === -1) break

											memory = url.indexOf('&${_}=', memory)
											if(memory === -1) break
										}

										try {
										    if(a${H}.charCodeAt(0) === 91)
												a${H} = JSON.parse(a${H})
											else
												a${H} = JSON.parse('[' + a${H} + ']')
										} catch {}\n` : `while (memory !== -1) {
											const start = memory + ${_.length + 2}
											memory = url.indexOf('&', start)

											if(a${H} === undefined)
												a${H} = []

											if(memory === -1) {
												a${H}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g, ' '))
												break
											}
											else a${H}.push(decodeURIComponent(url.slice(start, memory)).replace(/\\+/g, ' '))

											memory = url.indexOf('&${_}=', memory)
											if(memory === -1) break
										}\n`);
        if (C)
          return U0 + `if (memory !== -1) {
										const start = memory + ${_.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${H} = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
										else a${H} = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

										if (a${H} !== undefined) {
											try {
												a${H} = JSON.parse(a${H})
											} catch {}
										}
									}`;
        return U0 + `if (memory !== -1) {
										const start = memory + ${_.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${H} = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
										else {
											a${H} = decodeURIComponent(url.slice(start, memory).replace(/\\+/g, ' '))

											${a ? `
											let deepMemory = url.indexOf('&${_}=', memory)

											if(deepMemory !== -1) {
												a${H} = [a${H}]
												let first = true

												while(true) {
													const start = deepMemory + ${_.length + 2}
													if(first)
														first = false
													else
														deepMemory = url.indexOf('&', start)

													let value
													if(deepMemory === -1) value = decodeURIComponent(url.slice(start).replace(/\\+/g, ' '))
													else value = decodeURIComponent(url.slice(start, deepMemory).replace(/\\+/g, ' '))

													const vStart = value.charCodeAt(0)
													const vEnd = value.charCodeAt(value.length - 1)

													if((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
														try {
															a${H}.push(JSON.parse(value))
														} catch {
														 	a${H}.push(value)
														}

													if(deepMemory === -1) break
												}
											}
												` : ""}
										}
									}`;
      }).join("\n")}

				c.query = {
					${N.map(({ key: _ }, A) => `'${_}': a${A}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
  }
  if (F)
    G += "\nconst id = c[ELYSIA_REQUEST_ID]\n";
  const R = g1({ trace: j.trace, addFn: (N) => {
    G += N;
  } });
  G += "\ntry {\n";
  const G0 = typeof Q === "function" && y(Q), e = F || j.afterResponse.length > 0 ? "c.response = " : "", k0 = P || D || G0 || j.parse.length > 0 || j.afterHandle.some(y) || j.beforeHandle.some(y) || j.transform.some(y) || j.mapResponse.some(y), V2 = (typeof Q === "function" ? K1(Q) : false) || j.beforeHandle.some(K1) || j.afterHandle.some(K1) || j.transform.some(K1), s0 = K.cookie || K.set || O || F || J.response || B && I || V2, r = ", c.request";
  G += `c.route = \`${W}\`\n`;
  const C2 = R("parse", { total: j.parse.length });
  if (D) {
    const N = j.parse.length || K.body || J.body;
    if (G += "isParsing = true\n", j.type && !j.parse.length)
      switch (j.type) {
        case "json":
        case "application/json":
          if (t(J.body))
            G += "try { c.body = await c.request.json() } catch {}";
          else
            G += "c.body = await c.request.json()";
          break;
        case "text":
        case "text/plain":
          G += "c.body = await c.request.text()\n";
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          G += "c.body = parseQuery(await c.request.text())\n";
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          G += "c.body = await c.request.arrayBuffer()\n";
          break;
        case "formdata":
        case "multipart/form-data":
          if (G += "c.body = {}\n", t(J.body))
            G += "let form; try { form = await c.request.formData() } catch {}";
          else
            G += "const form = await c.request.formData()";
          G += `\nif(form)
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						} else form = {}\n`;
          break;
      }
    else if (N) {
      if (G += "\n", G += O ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", G += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n
					c.contentType = contentType\n`, j.parse.length) {
        G += "let used = false\n";
        const _ = R("parse", { total: j.parse.length });
        for (let A = 0;A < j.parse.length; A++) {
          const C = _.resolveChild(j.parse[A].fn.name), S = `bo${A}`;
          if (A !== 0)
            G += "if(!used) {\n";
          if (G += `let ${S} = parse[${A}](c, contentType)\n`, G += `if(${S} instanceof Promise) ${S} = await ${S}\n`, G += `if(${S} !== undefined) { c.body = ${S}; used = true }\n`, C(), A !== 0)
            G += "}";
        }
        _.resolve();
      }
      if (G += "\ndelete c.contentType\n", j.parse.length)
        G += "if (!used) {";
      if (j.type && !Array.isArray(j.type))
        switch (j.type) {
          case "json":
          case "application/json":
            if (t(J.body))
              G += "try { c.body = await c.request.json() } catch {}";
            else
              G += "c.body = await c.request.json()";
            break;
          case "text":
          case "text/plain":
            G += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            G += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            G += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            G += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}\n`;
            break;
        }
      else
        G += `
					switch (contentType) {
						case 'application/json':
							${t(J.body) ? "try { c.body = await c.request.json() } catch {}" : "c.body = await c.request.json()"}
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
      if (j.parse.length)
        G += "}";
      G += "}\n";
    }
    G += "\nisParsing = false\n";
  }
  if (C2.resolve(), j?.transform) {
    const N = R("transform", { total: j.transform.length });
    if (j.transform.length)
      G += "\nlet transformed\n";
    for (let _ = 0;_ < j.transform.length; _++) {
      const A = j.transform[_], C = N.resolveChild(A.fn.name);
      if (G += y(A) ? `transformed = await transform[${_}](c)\n` : `transformed = transform[${_}](c)\n`, A.subType === "mapDerive")
        G += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else {
					transformed.request = c.request
					transformed.store = c.store
					transformed.qi = c.qi
					transformed.path = c.path
					transformed.url = c.url
					transformed.redirect = c.redirect
					transformed.set = c.set
					transformed.error = c.error

					c = transformed
			}`;
      else
        G += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else
					Object.assign(c, transformed)\n`;
      C();
    }
    N.resolve();
  }
  if (J) {
    if (G += "\n", J.headers) {
      if (s && "Clean" in J.headers && !J0(J.headers))
        G += "c.headers = validator.headers.Clean(c.headers);\n";
      if (C0("default", J.headers.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(J.headers.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            G += `c.headers['${N}'] ??= ${A}\n`;
        }
      if (t(J.headers))
        G += "if(isNotEmpty(c.headers)) {";
      if (G += `if(validator.headers.Check(c.headers) === false) {
				${L("headers")}
			}`, S0(J.headers.schema))
        G += "c.headers = validator.headers.Decode(c.headers)\n";
      if (t(J.headers))
        G += "}";
    }
    if (J.params) {
      if (C0("default", J.params.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(J.params.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            G += `c.params['${N}'] ??= ${A}\n`;
        }
      if (G += `if(validator.params.Check(c.params) === false) {
				${L("params")}
			}`, S0(J.params.schema))
        G += "\nc.params = validator.params.Decode(c.params)\n";
    }
    if (J.query) {
      if (s && "Clean" in J.query && !J0(J.query))
        G += "c.query = validator.query.Clean(c.query);\n";
      if (C0("default", J.query.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(J.query.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            G += `if(c.query['${N}'] === undefined) c.query['${N}'] = ${A}\n`;
        }
      if (t(J.query))
        G += "if(isNotEmpty(c.query)) {";
      if (G += `if(validator.query.Check(c.query) === false) {
          		${L("query")}
			}`, S0(J.query.schema))
        G += "\nc.query = validator.query.Decode(Object.assign({}, c.query))\n";
      if (t(J.query))
        G += "}";
    }
    if (J.body) {
      if (s && "Clean" in J.body && !J0(J.body))
        G += "c.body = validator.body.Clean(c.body);\n";
      const N = S0(J.body.schema);
      if (N || t(J.body))
        G += '\nconst isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))\n';
      if (C0("default", J.body.schema)) {
        const _ = exports_value2.Default(J.body.schema, J.body.schema.type === "object" ? {} : undefined), A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
        if (G += `if(validator.body.Check(c.body) === false) {
					if (typeof c.body === 'object') {
						c.body = Object.assign(${A}, c.body)
					} else { c.body = ${A} }`, t(J.body))
          G += `
					    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            				${L("body")}
             			}
                    }`;
        else
          G += `
    				if(validator.body.Check(c.body) === false) {
        				${L("body")}
         			}
                }`;
      } else if (t(J.body))
        G += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         			${L("body")}
          		}`;
      else
        G += `if(validator.body.Check(c.body) === false) {
         			${L("body")}
          		}`;
      if (N)
        G += "\nif(isNotEmptyObject) c.body = validator.body.Decode(c.body)\n";
    }
    if (p(b?.schema?.properties ?? b?.schema?.schema ?? {})) {
      if (G += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, C0("default", b.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(b.schema, {})))
          G += `cookieValue['${N}'] = ${typeof _ === "object" ? JSON.stringify(_) : _}\n`;
      if (t(J.cookie))
        G += "if(isNotEmpty(c.cookie)) {";
      if (G += `if(validator.cookie.Check(cookieValue) === false) {
				${L("cookie", "cookieValue")}
			}`, S0(J.cookie.schema))
        G += `\nfor(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
					c.cookie[key].value = value\n`;
      if (t(J.cookie))
        G += "}";
    }
  }
  if (j?.beforeHandle) {
    const N = R("beforeHandle", { total: j.beforeHandle.length });
    let _ = false;
    for (let A = 0;A < j.beforeHandle.length; A++) {
      const C = j.beforeHandle[A], S = N.resolveChild(C.fn.name), a = E0(C);
      if (C.subType === "resolve" || C.subType === "mapResolve") {
        if (!_)
          _ = true, G += "\nlet resolved\n";
        if (G += y(C) ? `resolved = await beforeHandle[${A}](c);\n` : `resolved = beforeHandle[${A}](c);\n`, C.subType === "mapResolve")
          G += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else {
						resolved.request = c.request
						resolved.store = c.store
						resolved.qi = c.qi
						resolved.path = c.path
						resolved.url = c.url
						resolved.redirect = c.redirect
						resolved.set = c.set
						resolved.error = c.error

						c = resolved
					}`;
        else
          G += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)\n`;
      } else if (!a)
        G += y(C) ? `await beforeHandle[${A}](c);\n` : `beforeHandle[${A}](c);\n`, S();
      else {
        if (G += y(C) ? `be = await beforeHandle[${A}](c);\n` : `be = beforeHandle[${A}](c);\n`, S("be"), G += "if(be !== undefined) {\n", N.resolve(), j.afterHandle?.length) {
          R("handle", { name: B ? Q.name : undefined }).resolve();
          const u = R("afterHandle", { total: j.afterHandle.length });
          for (let Y0 = 0;Y0 < j.afterHandle.length; Y0++) {
            const T0 = j.afterHandle[Y0], S2 = E0(T0), L2 = u.resolveChild(T0.fn.name);
            if (G += "c.response = be\n", !S2)
              G += y(T0.fn) ? `await afterHandle[${Y0}](c, be)\n` : `afterHandle[${Y0}](c, be)\n`;
            else
              G += y(T0.fn) ? `af = await afterHandle[${Y0}](c)\n` : `af = afterHandle[${Y0}](c)\n`, G += "if(af !== undefined) { c.response = be = af }\n";
            L2("af");
          }
          u.resolve();
        }
        if (J.response)
          G += x("be");
        const U0 = R("mapResponse", { total: j.mapResponse.length });
        if (j.mapResponse.length) {
          G += "\nc.response = be\n";
          for (let u = 0;u < j.mapResponse.length; u++) {
            const Y0 = j.mapResponse[u], T0 = U0.resolveChild(Y0.fn.name);
            G += `\nif(mr === undefined) {
							mr = ${L0(Y0) ? "await" : ""} onMapResponse[${u}](c)
							if(mr !== undefined) be = c.response = mr
						}\n`, T0();
          }
        }
        U0.resolve(), G += q, G += `return mapEarlyResponse(${e} be, c.set ${r})}\n`;
      }
    }
    N.resolve();
  }
  if (j?.afterHandle.length) {
    const N = R("handle", { name: B ? Q.name : undefined });
    if (j.afterHandle.length)
      G += G0 ? `let r = c.response = await ${U};\n` : `let r = c.response = ${U};\n`;
    else
      G += G0 ? `let r = await ${U};\n` : `let r = ${U};\n`;
    N.resolve();
    const _ = R("afterHandle", { total: j.afterHandle.length });
    for (let C = 0;C < j.afterHandle.length; C++) {
      const S = j.afterHandle[C], a = E0(S), H = _.resolveChild(S.fn.name);
      if (!a)
        G += y(S.fn) ? `await afterHandle[${C}](c)\n` : `afterHandle[${C}](c)\n`, H();
      else if (G += y(S.fn) ? `af = await afterHandle[${C}](c)\n` : `af = afterHandle[${C}](c)\n`, H("af"), J.response)
        G += "if(af !== undefined) {", _.resolve(), G += x("af"), G += "c.response = af }";
      else
        G += "if(af !== undefined) {", _.resolve(), G += "c.response = af}\n";
    }
    if (_.resolve(), G += "r = c.response\n", J.response)
      G += x();
    G += q;
    const A = R("mapResponse", { total: j.mapResponse.length });
    if (j.mapResponse.length)
      for (let C = 0;C < j.mapResponse.length; C++) {
        const S = j.mapResponse[C], a = A.resolveChild(S.fn.name);
        G += `\nmr = ${L0(S) ? "await" : ""} onMapResponse[${C}](c)
				if(mr !== undefined) r = c.response = mr\n`, a();
      }
    if (A.resolve(), s0)
      G += `return mapResponse(${e} r, c.set ${r})\n`;
    else
      G += `return mapCompactResponse(${e} r ${r})\n`;
  } else {
    const N = R("handle", { name: B ? Q.name : undefined });
    if (J.response || j.mapResponse.length) {
      if (G += G0 ? `let r = await ${U};\n` : `let r = ${U};\n`, N.resolve(), J.response)
        G += x();
      R("afterHandle").resolve();
      const _ = R("mapResponse", { total: j.mapResponse.length });
      if (j.mapResponse.length) {
        G += "\nc.response = r\n";
        for (let A = 0;A < j.mapResponse.length; A++) {
          const C = j.mapResponse[A], S = _.resolveChild(C.fn.name);
          G += `\nif(mr === undefined) {
						mr = ${L0(C) ? "await" : ""} onMapResponse[${A}](c)
    					if(mr !== undefined) r = c.response = mr
					}\n`, S();
        }
      }
      if (_.resolve(), G += q, Q instanceof Response)
        G += K.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${e} ${U}.clone(), c.set ${r})
				else
					return ${U}.clone()` : `return ${U}.clone()`, G += "\n";
      else if (s0)
        G += `return mapResponse(${e} r, c.set ${r})\n`;
      else
        G += `return mapCompactResponse(${e} r ${r})\n`;
    } else if (P || F) {
      G += G0 ? `let r = await ${U};\n` : `let r = ${U};\n`, N.resolve(), R("afterHandle").resolve();
      const _ = R("mapResponse", { total: j.mapResponse.length });
      if (j.mapResponse.length) {
        G += "\nc.response = r\n";
        for (let A = 0;A < j.mapResponse.length; A++) {
          const C = j.mapResponse[A], S = _.resolveChild(C.fn.name);
          G += `\nif(mr === undefined) {
							mr = ${L0(C) ? "await" : ""} onMapResponse[${A}](c)
    						if(mr !== undefined) r = c.response = mr
						}\n`, S();
        }
      }
      if (_.resolve(), G += q, s0)
        G += `return mapResponse(${e} r, c.set ${r})\n`;
      else
        G += `return mapCompactResponse(${e} r ${r})\n`;
    } else {
      N.resolve();
      const _ = G0 ? `await ${U}` : U;
      if (R("afterHandle").resolve(), Q instanceof Response)
        G += K.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${e} ${U}.clone(), c.set ${r})
				else
					return ${U}.clone()` : `return ${U}.clone()`, G += "\n";
      else if (s0)
        G += `return mapResponse(${e} ${_}, c.set ${r})\n`;
      else
        G += `return mapCompactResponse(${e} ${_} ${r})\n`;
    }
  }
  if (G += "\n} catch(error) {", D)
    G += "\nif(isParsing) error = new ParseError()\n";
  if (!k0)
    G += "\nreturn (async () => {\n";
  if (G += "\nconst set = c.set\nif (!set.status || set.status < 300) set.status = error?.status || 500\n", F)
    for (let N = 0;N < j.trace.length; N++)
      G += `report${N}?.resolve(error);reportChild${N}?.(error);\n`;
  const U1 = R("error", { total: j.error.length });
  if (j.error.length) {
    G += `
				c.error = error
				if(error instanceof TypeBoxError) {
					c.code = "VALIDATION"
					c.set.status = 422
				} else
					c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				let er
			`;
    for (let N = 0;N < j.error.length; N++) {
      const _ = U1.resolveChild(j.error[N].fn.name);
      if (y(j.error[N]))
        G += `\ner = await handleErrors[${N}](c)\n`;
      else
        G += `\ner = handleErrors[${N}](c)\nif (er instanceof Promise) er = await er\n`;
      _();
      const A = R("mapResponse", { total: j.mapResponse.length });
      if (j.mapResponse.length)
        for (let C = 0;C < j.mapResponse.length; C++) {
          const S = j.mapResponse[C], a = A.resolveChild(S.fn.name);
          G += `\nc.response = er\n
							er = ${L0(S) ? "await" : ""} onMapResponse[${C}](c)
							if(er instanceof Promise) er = await er\n`, a();
        }
      if (A.resolve(), G += `er = mapEarlyResponse(er, set ${r})\n`, G += "if (er) {", F) {
        for (let C = 0;C < j.trace.length; C++)
          G += `\nreport${C}.resolve()\n`;
        U1.resolve();
      }
      G += "return er\n}\n";
    }
  }
  if (U1.resolve(), G += "return handleError(c, error, true)\n", !k0)
    G += "})()";
  if (G += "}", w || F) {
    if (G += " finally { ", !k0)
      G += ";(async () => {";
    const N = R("afterResponse", { total: j.afterResponse.length });
    if (w)
      for (let _ = 0;_ < j.afterResponse.length; _++) {
        const A = N.resolveChild(j.afterResponse[_].fn.name);
        G += `\nawait afterResponse[${_}](c);\n`, A();
      }
    if (N.resolve(), !k0)
      G += "})();";
    G += "}";
  }
  G = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			afterResponse,
			trace: _trace
		},
		validator,
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			parseQueryFromURL,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer,
		TypeBoxError
	} = hooks

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

	return ${k0 ? "async" : ""} function handle(c) {
		${j.beforeHandle.length ? "let be" : ""}
		${j.afterHandle.length ? "let af" : ""}
		${j.mapResponse.length ? "let mr" : ""}

		${Y ? "c.schema = schema; c.defs = definitions" : ""}
		${G}
	}`;
  try {
    return Function("hooks", G)({ handler: Q, hooks: E1(j), validator: J, handleError: $.handleError, utils: { mapResponse: g, mapCompactResponse: Z0, mapEarlyResponse: k, parseQuery: i0, parseQueryFromURL: B1, isNotEmpty: p }, error: { NotFoundError: O0, ValidationError: E, InternalServerError: G1, ParseError: Y1 }, schema: $.router.history, definitions: $.definitions.type, ERROR_CODE: A0, parseCookie: $1, signCookie: g0, decodeURIComponent: P2.default, ELYSIA_RESPONSE: d, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: I0, getServer: () => $.getServer(), TypeBoxError });
  } catch {
    const N = E1(j);
    console.log("[Composer] failed to generate optimized handler"), console.log("Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"), console.log("---"), console.log({ handler: typeof Q === "function" ? Q.toString() : Q, hooks: { ...N, transform: N?.transform?.map?.((_) => _.toString()), resolve: N?.resolve?.map?.((_) => _.toString()), beforeHandle: N?.beforeHandle?.map?.((_) => _.toString()), afterHandle: N?.afterHandle?.map?.((_) => _.toString()), mapResponse: N?.mapResponse?.map?.((_) => _.toString()), parse: N?.parse?.map?.((_) => _.toString()), error: N?.error?.map?.((_) => _.toString()), afterResponse: N?.afterResponse?.map?.((_) => _.toString()), stop: N?.stop?.map?.((_) => _.toString()) }, validator: J, definitions: $.definitions.type }), console.log("---"), process.exit(1);
  }
};
var f1 = ($) => {
  const W = $.config.handler?.standardHostname ?? true;
  let X = "", Z = "";
  const j = $.setHeaders;
  for (let D of Object.keys($.singleton.decorator))
    X += `,${D}: app.singleton.decorator.${D}`;
  const J = $.router, Q = $.event.trace.length > 0;
  let Y = `
	const route = router.find(request.method, path) ${J.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params\n`;
  Y += `if(route.store.handler) return route.store.handler(ctx)
	return (route.store.handler = route.store.compile())(ctx)\n`;
  let K = "";
  for (let [D, { code: M, all: I, static: O }] of Object.entries(J.static.http.map)) {
    if (O)
      K += `case '${D}':\nswitch(request.method) {\n${M}\n${I ?? "default: break map"}}\n\n`;
    K += `case '${D}':\nswitch(request.method) {\n${M}\n${I ?? "default: break map"}}\n\n`;
  }
  const B = $.event.request.some(y);
  if (Z += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		error,
		redirect,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const st = staticRouter.handlers
	const wsRouter = app.router.ws
	const router = app.router.http
	const trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

	const notFound = new NotFoundError()
	const hoc = app.extender.higherOrderFunctions.map(x => x.fn)

	${$.event.request.length ? "const onRequest = app.event.request.map(x => x.fn)" : ""}
	${$.event.error.length ? "" : `\nconst error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });\n`}

	${$.event.trace.length ? `const ${$.event.trace.map((D, M) => `tr${M} = app.event.trace[${M}].fn`).join(",")}` : ""}

	${B ? "async" : ""} function map(request) {\n`, $.event.request.length)
    Z += "let re";
  if (Z += `\nconst url = request.url
		const s = url.indexOf('/', ${W ? 11 : 7})
		const qi = url.indexOf('?', s + 1)
		let path
		if(qi === -1)
			path = url.substring(s)
		else
			path = url.substring(s, qi)\n`, Z += `${Q ? "const id = randomId()" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(j ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${$.inference.server ? `, get server() {
							return getServer()
						}` : ""}
			${Q ? ",[ELYSIA_REQUEST_ID]: id" : ""}
			${X}
		}\n`, $.event.trace.length)
    Z += `\nctx[ELYSIA_TRACE] = [${$.event.trace.map((D, M) => `tr${M}(ctx)`).join(",")}]\n`;
  const w = g1({ context: "ctx", trace: $.event.trace, addFn(D) {
    Z += D;
  } })("request", { attribute: "ctx", total: $.event.request.length });
  if ($.event.request.length) {
    Z += "\n try {\n";
    for (let D = 0;D < $.event.request.length; D++) {
      const M = $.event.request[D], I = E0(M), O = y(M), P = w.resolveChild($.event.request[D].fn.name);
      if (I)
        Z += `re = mapEarlyResponse(
					${O ? "await" : ""} onRequest[${D}](ctx),
					ctx.set,
					request
				)\n`, P("re"), Z += "if(re !== undefined) return re\n";
      else
        Z += `${O ? "await" : ""} onRequest[${D}](ctx)\n`, P();
    }
    Z += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
  }
  w.resolve();
  const F = $.router.static.ws, G = $.router.ws;
  if (Object.keys(F).length || G.history.length) {
    Z += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [D, M] of Object.entries(F))
      Z += `
					case '${D}':
						if(request.headers.get('upgrade') === 'websocket')
							return st[${M}](ctx)

						break`;
    Z += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							if(route.store.handler)
							    return route.store.handler(ctx)

							return (route.store.handler = route.store.compile())(ctx)
						}
					}

					break
			}
		}\n`;
  }
  if (Z += `
		map: switch(path) {
			${K}

			default:
				break
		}

		${Y}
	}\n`, $.extender.higherOrderFunctions.length) {
    let D = "map";
    for (let M = 0;M < $.extender.higherOrderFunctions.length; M++)
      D = `hoc[${M}](${D}, request)`;
    Z += `return function hocMap(request) { return ${D}(request) }`;
  } else
    Z += "return map";
  const z = y1($);
  return $.handleError = z, Function("data", Z)({ app: $, mapEarlyResponse: k, NotFoundError: O0, randomId: J1, handleError: z, error: H1, redirect: c0, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: I0, getServer: () => $.getServer() });
};
var y1 = ($) => {
  const W = $.event;
  let X = "";
  X += `const {
		app: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID
	} = inject

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
	const onMapResponse = []

	for(let i = 0; i < _onMapResponse.length; i++)
		onMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

	delete _onMapResponse

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${$.event.error.find(y) || $.event.mapResponse.find(y) ? "async" : ""} function(context, error, skipGlobal) {`;
  const Z = $.event.trace.length > 0;
  if (Z)
    X += "\nconst id = context[ELYSIA_REQUEST_ID]\n";
  const j = g1({ context: "context", trace: W.trace, addFn: (Y) => {
    X += Y;
  } });
  X += `
		const set = context.set
		let r

		if(!context.code)
			context.code = error.code ?? error[ERROR_CODE]

		if(!(context.error instanceof Error))
			context.error = error

		if(typeof error === "object" && error && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}\n`;
  const J = Z || W.afterResponse.length > 0 || W.afterResponse.length > 0 ? "context.response = " : "";
  for (let Y = 0;Y < $.event.error.length; Y++) {
    const K = $.event.error[Y], B = `${y(K) ? "await " : ""}onError[${Y}](context)`;
    if (X += "\nif(skipGlobal !== true) {\n", E0(K)) {
      X += `r = ${B}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status\n`;
      const U = j("mapResponse", { total: W.mapResponse.length, name: "context" });
      if (W.mapResponse.length)
        for (let w = 0;w < W.mapResponse.length; w++) {
          const F = W.mapResponse[w], G = U.resolveChild(F.fn.name);
          X += `\ncontext.response = r
						r = ${L0(F) ? "await" : ""} onMapResponse[${w}](context)\n`, G();
        }
      U.resolve(), X += `return mapResponse(${J} r, set, context.request)}\n`;
    } else
      X += B + "\n";
    X += "\n}\n";
  }
  X += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)\n`;
  const Q = j("mapResponse", { total: W.mapResponse.length, name: "context" });
  if (W.mapResponse.length)
    for (let Y = 0;Y < W.mapResponse.length; Y++) {
      const K = W.mapResponse[Y], B = Q.resolveChild(K.fn.name);
      X += `\ncontext.response = error
			error = ${L0(K) ? "await" : ""} onMapResponse[${Y}](context)\n`, B();
    }
  return Q.resolve(), X += `\nreturn mapResponse(${J} error, set, context.request)\n}\n}`, Function("inject", X)({ app: $, mapResponse: g, ERROR_CODE: A0, ELYSIA_RESPONSE: d, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: I0 });
};
var k1 = ($) => async (W) => {
  const X = W.url, Z = X.indexOf("/", 11), j = X.indexOf("?", Z + 1), J = j === -1 ? X.substring(Z) : X.substring(Z, j), Q = { cookie: {}, status: 200, headers: {} }, Y = Object.assign({}, $.singleton.decorator, { set: Q, store: $.singleton.store, request: W, path: J, qi: j, redirect: c0 });
  try {
    for (let I = 0;I < $.event.request.length; I++) {
      const O = $.event.request[I].fn;
      let P = O(Y);
      if (P instanceof Promise)
        P = await P;
      if (P = k(P, Q), P)
        return Y.response = P;
    }
    const K = $.router.dynamic.find(W.method, J) ?? $.router.dynamic.find("ALL", J);
    if (!K)
      throw new O0;
    const { handle: B, hooks: U, validator: w, content: F } = K.store;
    let G;
    if (W.method !== "GET" && W.method !== "HEAD")
      if (F)
        switch (F) {
          case "application/json":
            G = await W.json();
            break;
          case "text/plain":
            G = await W.text();
            break;
          case "application/x-www-form-urlencoded":
            G = i0(await W.text());
            break;
          case "application/octet-stream":
            G = await W.arrayBuffer();
            break;
          case "multipart/form-data":
            G = {};
            const I = await W.formData();
            for (let O of I.keys()) {
              if (G[O])
                continue;
              const P = I.getAll(O);
              if (P.length === 1)
                G[O] = P[0];
              else
                G[O] = P;
            }
            break;
        }
      else {
        let I = W.headers.get("content-type");
        if (I) {
          const O = I.indexOf(";");
          if (O !== -1)
            I = I.slice(0, O);
          Y.contentType = I;
          for (let P = 0;P < U.parse.length; P++) {
            const b = U.parse[P].fn;
            let T = b(Y, I);
            if (T instanceof Promise)
              T = await T;
            if (T) {
              G = T;
              break;
            }
          }
          if (delete Y.contentType, G === undefined)
            switch (I) {
              case "application/json":
                G = await W.json();
                break;
              case "text/plain":
                G = await W.text();
                break;
              case "application/x-www-form-urlencoded":
                G = i0(await W.text());
                break;
              case "application/octet-stream":
                G = await W.arrayBuffer();
                break;
              case "multipart/form-data":
                G = {};
                const P = await W.formData();
                for (let b of P.keys()) {
                  if (G[b])
                    continue;
                  const T = P.getAll(b);
                  if (T.length === 1)
                    G[b] = T[0];
                  else
                    G[b] = T;
                }
                break;
            }
        }
      }
    Y.body = G, Y.params = K?.params || undefined, Y.query = j === -1 ? {} : B1(X.substring(j + 1)), Y.headers = {};
    for (let [I, O] of W.headers.entries())
      Y.headers[I] = O;
    const z = Object.assign({}, $.config?.cookie, w?.cookie?.config), D = W.headers.get("cookie");
    Y.cookie = await $1(Y.set, D, z ? { secrets: z.secrets !== undefined ? typeof z.secrets === "string" ? z.secrets : z.secrets.join(",") : undefined, sign: z.sign === true ? true : z.sign !== undefined ? typeof z.sign === "string" ? z.sign : z.sign.join(",") : undefined } : undefined);
    for (let I = 0;I < U.transform.length; I++) {
      const O = U.transform[I], P = O.fn(Y);
      if (O.subType === "derive")
        if (P instanceof Promise)
          Object.assign(Y, await P);
        else
          Object.assign(Y, P);
      else if (P instanceof Promise)
        await P;
    }
    if (w) {
      if (w.createHeaders?.()) {
        const I = {};
        for (let O in W.headers)
          I[O] = W.headers.get(O);
        if (w.headers.Check(I) === false)
          throw new E("header", w.headers, I);
      } else if (w.headers?.Decode)
        Y.headers = w.headers.Decode(Y.headers);
      if (w.createParams?.()?.Check(Y.params) === false)
        throw new E("params", w.params, Y.params);
      else if (w.params?.Decode)
        Y.params = w.params.Decode(Y.params);
      if (w.createQuery?.()?.Check(Y.query) === false)
        throw new E("query", w.query, Y.query);
      else if (w.query?.Decode)
        Y.query = w.query.Decode(Y.query);
      if (w.createCookie?.()) {
        let I = {};
        for (let [O, P] of Object.entries(Y.cookie))
          I[O] = P.value;
        if (w.cookie.Check(I) === false)
          throw new E("cookie", w.cookie, I);
        else if (w.cookie?.Decode)
          I = w.cookie.Decode(I);
      }
      if (w.createBody?.()?.Check(G) === false)
        throw new E("body", w.body, G);
      else if (w.body?.Decode)
        Y.body = w.body.Decode(G);
    }
    for (let I = 0;I < U.beforeHandle.length; I++) {
      const O = U.beforeHandle[I];
      let P = O.fn(Y);
      if (O.subType === "resolve") {
        if (P instanceof Promise)
          Object.assign(Y, await P);
        else
          Object.assign(Y, P);
        continue;
      } else if (P instanceof Promise)
        P = await P;
      if (P !== undefined) {
        Y.response = P;
        for (let T = 0;T < U.afterHandle.length; T++) {
          let q = U.afterHandle[T].fn(Y);
          if (q instanceof Promise)
            q = await q;
          if (q)
            P = q;
        }
        const b = k(P, Y.set);
        if (b)
          return Y.response = b;
      }
    }
    let M = B(Y);
    if (M instanceof Promise)
      M = await M;
    if (!U.afterHandle.length) {
      const I = M?.[d] ?? (Q.status ? typeof Q.status === "string" ? _0[Q.status] : Q.status : 200), O = w?.createResponse?.()?.[I];
      if (O?.Check(M) === false)
        throw new E("response", O, M);
      else if (O?.Decode)
        M = O.Decode(M);
    } else {
      Y.response = M;
      for (let I = 0;I < U.afterHandle.length; I++) {
        let O = U.afterHandle[I].fn(Y);
        if (O instanceof Promise)
          O = await O;
        const P = k(O, Y.set);
        if (P !== undefined) {
          const b = w?.response?.[P.status];
          if (b?.Check(P) === false)
            throw new E("response", b, P);
          else if (b?.Decode)
            M = b.Decode(M);
          return Y.response = P;
        }
      }
    }
    if (Y.set.cookie && z?.sign) {
      const I = !z.secrets ? undefined : typeof z.secrets === "string" ? z.secrets : z.secrets[0];
      if (z.sign === true)
        for (let [O, P] of Object.entries(Y.set.cookie))
          Y.set.cookie[O].value = await g0(P.value, "${secret}");
      else {
        const O = w?.cookie?.schema?.properties;
        for (let P of z.sign) {
          if (!(P in O))
            continue;
          if (Y.set.cookie[P]?.value)
            Y.set.cookie[P].value = await g0(Y.set.cookie[P].value, I);
        }
      }
    }
    return Y.response = g(M, Y.set);
  } catch (K) {
    if (K.status)
      Q.status = K.status;
    return $.handleError(Y, K);
  } finally {
    for (let K of $.event.afterResponse)
      await K.fn(Y);
  }
};
var O2 = ($) => async (W, X) => {
  const Z = Object.assign(W, { error: X, code: X.code });
  Z.set = W.set;
  for (let j = 0;j < $.event.error.length; j++) {
    let Q = $.event.error[j].fn(Z);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return W.response = g(Q, W.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: W.set.headers, status: X.status ?? 500 });
};

class Q0 {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Scoped: false, Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  static version = b1;
  version = b1;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  definitions = { type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return x0(x0(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new M0, ws: new M0, dynamic: new M0, static: { http: { static: {}, handlers: [], map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false };
  getServer() {
    return this.server;
  }
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new q1;
    return this._promisedModules;
  }
  constructor($ = {}) {
    if ($.tags)
      if (!$.detail)
        $.detail = { tags: $.tags };
      else
        $.detail.tags = $.tags;
    if ($.nativeStaticResponse === undefined)
      $.nativeStaticResponse = true;
    if (this.config = {}, this.applyConfig($ ?? {}), $?.analytic && ($?.name || $?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  env($, W = Bun?.env ?? process.env) {
    if (m($, { dynamic: true, additionalProperties: true, coerce: true }).Check(W) === false) {
      const Z = new E("env", $, W);
      throw new Error(Z.all.map((j) => j.summary).join("\n"));
    }
    return this;
  }
  wrap($) {
    return this.extender.higherOrderFunctions.push({ checksum: P0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ }), this;
  }
  applyMacro($) {
    if (this.extender.macros.length) {
      const W = M2({ globalHook: this.event, localHook: $ }), X = { events: { global: this.event, local: $ }, onParse: W("parse"), onTransform: W("transform"), onBeforeHandle: W("beforeHandle"), onAfterHandle: W("afterHandle"), mapResponse: W("mapResponse"), onAfterResponse: W("afterResponse"), onError: W("error") };
      for (let Z of this.extender.macros)
        F2(Z.fn(X), $);
    }
  }
  applyConfig($) {
    return this.config = { prefix: "", aot: true, strictPath: false, global: false, analytic: false, normalize: true, ...$, cookie: { path: "/", ...$?.cookie }, experimental: $?.experimental ?? {}, seed: $?.seed === undefined ? "" : $?.seed }, this;
  }
  get models() {
    const $ = {};
    for (let [W, X] of Object.entries(this.definitions.type))
      $[W] = m(X);
    return $;
  }
  add($, W, X, Z, { allowMeta: j = false, skipPrefix: J = false } = { allowMeta: false, skipPrefix: false }) {
    if (Z = z2(Z), W !== "" && W.charCodeAt(0) !== 47)
      W = "/" + W;
    if (this.config.prefix && !J && !this.config.scoped)
      W = this.config.prefix + W;
    if (Z?.type)
      switch (Z.type) {
        case "text":
          Z.type = "text/plain";
          break;
        case "json":
          Z.type = "application/json";
          break;
        case "formdata":
          Z.type = "multipart/form-data";
          break;
        case "urlencoded":
          Z.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          Z.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const Q = this.definitions.type, Y = !this.config.aot, K = { ...this.validator.getCandidate() }, B = { body: Z?.body ?? K?.body, headers: Z?.headers ?? K?.headers, params: Z?.params ?? K?.params, query: Z?.query ?? K?.query, cookie: Z?.cookie ?? K?.cookie, response: Z?.response ?? K?.response }, U = () => B.cookie ? X1({ validator: B.cookie, defaultConfig: this.config.cookie, config: B.cookie?.config ?? {}, dynamic: Y, models: Q }) : undefined, w = this.config.normalize, F = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: m(B.body, { dynamic: Y, models: Q, normalize: w, additionalCoerce: S1() }), headers: m(B.headers, { dynamic: Y, models: Q, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: D0() }), params: m(B.params, { dynamic: Y, models: Q, coerce: true, additionalCoerce: D0() }), query: m(B.query, { dynamic: Y, models: Q, normalize: w, coerce: true, additionalCoerce: D0() }), cookie: U(), response: W1(B.response, { dynamic: Y, models: Q, normalize: w }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = m(B.body, { dynamic: Y, models: Q, normalize: w, additionalCoerce: S1() });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = m(B.headers, { dynamic: Y, models: Q, additionalProperties: !w, coerce: true, additionalCoerce: D0() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = m(B.params, { dynamic: Y, models: Q, coerce: true, additionalCoerce: D0() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = m(B.query, { dynamic: Y, models: Q, coerce: true, additionalCoerce: D0() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = U();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = W1(B.response, { dynamic: Y, models: Q, normalize: w });
    } }, G = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
    if (Z = i(Z, K), Z.tags)
      if (!Z.detail)
        Z.detail = { tags: Z.tags };
      else
        Z.detail.tags = Z.tags;
    if (p(this.config.detail))
      Z.detail = c(Object.assign({}, this.config.detail), Z.detail);
    this.applyMacro(Z);
    const z = i(this.event, Z);
    if (this.config.aot === false) {
      if (this.router.dynamic.add($, W, { validator: F, hooks: z, content: Z?.type, handle: X }), this.config.strictPath === false)
        this.router.dynamic.add($, G, { validator: F, hooks: z, content: Z?.type, handle: X });
      this.router.history.push({ method: $, path: W, composed: null, handler: X, hooks: z });
      return;
    }
    const D = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, M = d0(this.inference), I = typeof X !== "function" ? G2(X, z, this.setHeaders) : undefined, O = typeof X !== "function" ? Y2(X, z, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && O && ($ === "GET" || $ === "ALL"))
      this.router.static.http.static[W] = O();
    const P = () => A2({ app: this, path: W, method: $, localHook: i(Z), hooks: z, validator: F, handler: X, allowMeta: j, inference: M }), b = D ? P() : (L) => {
      return P()(L);
    }, T = this.router.history.length;
    if (this.routeTree.has($ + W))
      for (let L = 0;L < this.router.history.length; L++) {
        const x = this.router.history[L];
        if (x.path === W && x.method === $) {
          const R = this.router.history.splice(L, 1)[0];
          if (R && this.routeTree.has(R?.method + R?.path))
            this.routeTree.delete(R.method + R.path);
        }
      }
    else
      this.routeTree.set($ + W, T);
    this.router.history.push({ method: $, path: W, composed: b, handler: X, hooks: z });
    const q = this.router.static.http, s = { handler: D ? b : undefined, compile: P };
    if ($ === "$INTERNALWS") {
      const L = this.config.strictPath ? undefined : W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
        const x = q.handlers.length;
        if (q.handlers.push((R) => (q.handlers[x] = P())(R)), this.router.static.ws[W] = x, L)
          this.router.static.ws[L] = x;
      } else if (this.router.ws.add("ws", W, s), L)
        this.router.ws.add("ws", L, s);
      return;
    }
    if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
      const L = q.handlers.length;
      if (q.handlers.push(I ?? ((R) => (q.handlers[L] = P())(R))), !q.map[W])
        q.map[W] = { code: "" };
      const x = I ? "" : "ctx";
      if ($ === "ALL")
        q.map[W].all = `default: return st[${L}](${x})\n`;
      else
        q.map[W].code = `case '${$}': return st[${L}](${x})\n${q.map[W].code}`;
      if (!this.config.strictPath) {
        if (!q.map[G])
          q.map[G] = { code: "" };
        if (this.config.nativeStaticResponse === true && O && ($ === "GET" || $ === "ALL"))
          this.router.static.http.static[G] = O();
        if ($ === "ALL")
          q.map[G].all = `default: return st[${L}](${x})\n`;
        else
          q.map[G].code = `case '${$}': return st[${L}](${x})\n${q.map[G].code}`;
      }
    } else if (this.router.http.add($, W, s), !this.config.strictPath) {
      const L = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (this.config.nativeStaticResponse === true && I && ($ === "GET" || $ === "ALL"))
        this.router.static.http.static[L] = I();
      this.router.http.add($, L, s);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = c(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($, W) {
    if (!W)
      return this.on("parse", $);
    return this.on($, "parse", W);
  }
  onTransform($, W) {
    if (!W)
      return this.on("transform", $);
    return this.on($, "transform", W);
  }
  resolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "resolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  mapResolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "mapResolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  onBeforeHandle($, W) {
    if (!W)
      return this.on("beforeHandle", $);
    return this.on($, "beforeHandle", W);
  }
  onAfterHandle($, W) {
    if (!W)
      return this.on("afterHandle", $);
    return this.on($, "afterHandle", W);
  }
  mapResponse($, W) {
    if (!W)
      return this.on("mapResponse", $);
    return this.on($, "mapResponse", W);
  }
  onAfterResponse($, W) {
    if (!W)
      return this.on("afterResponse", $);
    return this.on($, "afterResponse", W);
  }
  trace($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    if (!Array.isArray(W))
      W = [W];
    for (let X of W)
      this.on($, "trace", N2(X));
    return this;
  }
  error($, W) {
    switch (typeof $) {
      case "string":
        return W.prototype[A0] = $, this.definitions.error[$] = W, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, Z] of Object.entries($))
      Z.prototype[A0] = X, this.definitions.error[X] = Z;
    return this;
  }
  onError($, W) {
    if (!W)
      return this.on("error", $);
    return this.on($, "error", W);
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, W, X) {
    let Z;
    switch (typeof $) {
      case "string":
        Z = $, X = W;
        break;
      case "object":
        if (Z = W, !Array.isArray(W) && typeof W === "object")
          X = W;
        break;
    }
    if (Array.isArray(X))
      X = n(X);
    else if (typeof X === "function")
      X = [{ fn: X }];
    else
      X = [X];
    const j = X;
    for (let J of j)
      J.scope = typeof $ === "string" ? "local" : $?.as ?? "local";
    if (Z !== "trace")
      r0({ [Z]: j.map((J) => J.fn) }, this.inference);
    for (let J of j) {
      const Q = _2(J, "global", { skipIfHasType: true });
      switch (Z) {
        case "start":
          this.event.start.push(Q);
          break;
        case "request":
          this.event.request.push(Q);
          break;
        case "parse":
          this.event.parse.push(Q);
          break;
        case "transform":
          this.event.transform.push(Q);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(Q);
          break;
        case "afterHandle":
          this.event.afterHandle.push(Q);
          break;
        case "mapResponse":
          this.event.mapResponse.push(Q);
          break;
        case "afterResponse":
          this.event.afterResponse.push(Q);
          break;
        case "trace":
          this.event.trace.push(Q);
          break;
        case "error":
          this.event.error.push(Q);
          break;
        case "stop":
          this.event.stop.push(Q);
          break;
      }
    }
    return this;
  }
  propagate() {
    return v(this.event.parse), v(this.event.transform), v(this.event.beforeHandle), v(this.event.afterHandle), v(this.event.mapResponse), v(this.event.afterResponse), v(this.event.trace), v(this.event.error), this;
  }
  as($) {
    const W = { plugin: "scoped", global: "global" }[$];
    if (v(this.event.parse, W), v(this.event.transform, W), v(this.event.beforeHandle, W), v(this.event.afterHandle, W), v(this.event.mapResponse, W), v(this.event.afterResponse, W), v(this.event.trace, W), v(this.event.error, W), $ === "plugin")
      this.validator.scoped = x0(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if ($ === "global")
      this.validator.global = x0(this.validator.global, x0(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group($, W, X) {
    const Z = new Q0({ ...this.config, prefix: "" });
    Z.singleton = { ...this.singleton }, Z.definitions = { ...this.definitions }, Z.getServer = () => this.getServer(), Z.inference = d0(this.inference), Z.extender = { ...this.extender };
    const j = typeof W === "object", J = (j ? X : W)(Z);
    if (this.singleton = c(this.singleton, Z.singleton), this.definitions = c(this.definitions, Z.definitions), J.event.request.length)
      this.event.request = [...this.event.request || [], ...J.event.request || []];
    if (J.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...J.event.mapResponse || []];
    return this.model(J.definitions.type), Object.values(Z.router.history).forEach(({ method: Q, path: Y, handler: K, hooks: B }) => {
      if (Y = (j ? "" : this.config.prefix) + $ + Y, j) {
        const U = W, w = B;
        this.add(Q, Y, K, i(U, { ...w || {}, error: !w.error ? J.event.error : Array.isArray(w.error) ? [...w.error || {}, ...J.event.error || {}] : [w.error, ...J.event.error || {}] }));
      } else
        this.add(Q, Y, K, i(B, { error: J.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, W) {
    if (!W) {
      if (typeof $ === "object") {
        this.applyMacro($);
        const j = $.as ?? "local";
        if (this.validator[j] = { body: $.body ?? this.validator[j]?.body, headers: $.headers ?? this.validator[j]?.headers, params: $.params ?? this.validator[j]?.params, query: $.query ?? this.validator[j]?.query, response: $.response ?? this.validator[j]?.response, cookie: $.cookie ?? this.validator[j]?.cookie }, $.parse)
          this.on({ as: j }, "parse", $.parse);
        if ($.transform)
          this.on({ as: j }, "transform", $.transform);
        if ($.beforeHandle)
          this.on({ as: j }, "beforeHandle", $.beforeHandle);
        if ($.afterHandle)
          this.on({ as: j }, "afterHandle", $.afterHandle);
        if ($.mapResponse)
          this.on({ as: j }, "mapResponse", $.mapResponse);
        if ($.afterResponse)
          this.on({ as: j }, "afterResponse", $.afterResponse);
        if ($.error)
          this.on({ as: j }, "error", $.error);
        if ($.detail)
          if (this.config.detail)
            this.config.detail = c(Object.assign({}, this.config.detail), $.detail);
          else
            this.config.detail = $.detail;
        if ($?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: $.tags };
          else
            this.config.detail.tags = $.tags;
        return this;
      }
      return this.guard({}, $);
    }
    const X = new Q0({ ...this.config, prefix: "" });
    X.singleton = { ...this.singleton }, X.definitions = { ...this.definitions }, X.inference = d0(this.inference), X.extender = { ...this.extender };
    const Z = W(X);
    if (this.singleton = c(this.singleton, X.singleton), this.definitions = c(this.definitions, X.definitions), Z.getServer = () => this.server, Z.event.request.length)
      this.event.request = [...this.event.request || [], ...Z.event.request || []];
    if (Z.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...Z.event.mapResponse || []];
    return this.model(Z.definitions.type), Object.values(X.router.history).forEach(({ method: j, path: J, handler: Q, hooks: Y }) => {
      this.add(j, J, Q, i($, { ...Y || {}, error: !Y.error ? Z.event.error : Array.isArray(Y.error) ? [...Y.error || {}, ...Z.event.error || []] : [Y.error, ...Z.event.error || []] }));
    }), this;
  }
  use($, W) {
    if (W?.scoped)
      return this.guard({}, (X) => X.use($));
    if (Array.isArray($)) {
      let X = this;
      for (let Z of $)
        X = this.use(Z);
      return X;
    }
    if ($ instanceof Promise)
      return this.promisedModules.add($.then((X) => {
        if (typeof X === "function")
          return X(this);
        if (X instanceof Q0)
          return this._use(X).compile();
        if (typeof X.default === "function")
          return X.default(this);
        if (X.default instanceof Q0)
          return this._use(X.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((X) => X.compile())), this;
    return this._use($);
  }
  _use($) {
    if (typeof $ === "function") {
      const j = $(this);
      if (j instanceof Promise)
        return this.promisedModules.add(j.then((J) => {
          if (J instanceof Q0) {
            J.getServer = () => this.getServer(), J.getGlobalRoutes = () => this.getGlobalRoutes(), J.model(this.definitions.type), J.error(this.definitions.error);
            for (let { method: Q, path: Y, handler: K, hooks: B } of Object.values(J.router.history))
              this.add(Q, Y, K, i(B, { error: J.event.error }));
            return J.compile(), J;
          }
          if (typeof J === "function")
            return J(this);
          if (typeof J.default === "function")
            return J.default(this);
          return this._use(J);
        }).then((J) => J.compile())), this;
      return j;
    }
    const { name: W, seed: X } = $.config;
    $.getServer = () => this.getServer(), $.getGlobalRoutes = () => this.getGlobalRoutes(), $.model(this.definitions.type), $.error(this.definitions.error);
    const Z = $.config.scoped;
    if (Z) {
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const J = X !== undefined ? P0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: Q }) => J === Q))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton.decorator, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Q) => Q.subType === "derive").map((Q) => ({ fn: Q.fn.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Q) => Q.subType === "derive").map((Q) => ({ fn: Q.fn.toString(), stack: new Error().stack ?? "" })) });
      }
      $.extender.macros = this.extender.macros.concat($.extender.macros);
      const j = [];
      for (let J = 0;J < $.extender.macros.length; J++) {
        const Q = this.extender.macros[J];
        if (j.includes(Q.checksum))
          $.extender.macros.splice(J, 1), J--;
        j.push(Q.checksum);
      }
      if ($.onRequest((J) => {
        Object.assign(J, this.singleton.decorator), Object.assign(J.store, this.singleton.store);
      }), $.event.trace.length)
        $.event.trace.push(...$.event.trace);
      if (!$.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if ($.event.error.length)
        $.event.error.push(...this.event.error);
      if ($.config.aot)
        $.compile();
      if (Z === true && $.config.prefix) {
        this.mount($.config.prefix + "/", $.fetch);
        for (let J of $.router.history)
          this.routeTree.set(J.method + `${$.config.prefix}${J.path}`, this.router.history.length), this.router.history.push({ ...J, path: `${$.config.prefix}${J.path}`, hooks: i(J.hooks, { error: this.event.error }) });
      } else {
        this.mount($.fetch);
        for (let J of $.router.history)
          this.routeTree.set(J.method + `${$.config.prefix}${J.path}`, this.router.history.length), this.router.history.push({ ...J, path: `${$.config.prefix}${J.path}`, hooks: i(J.hooks, { error: this.event.error }) });
      }
      return this;
    } else {
      if (this.headers($.setHeaders), W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const J = X !== undefined ? P0(W + JSON.stringify(X)) : 0;
        if (!this.dependencies[W].some(({ checksum: Q }) => J === Q))
          this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      } else
        this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      Q1(this.extender.macros), Q1(this.extender.higherOrderFunctions);
      const j = [];
      for (let J = 0;J < this.extender.higherOrderFunctions.length; J++) {
        const Q = this.extender.higherOrderFunctions[J];
        if (Q.checksum) {
          if (j.includes(Q.checksum))
            this.extender.higherOrderFunctions.splice(J, 1), J--;
          j.push(Q.checksum);
        }
      }
      this.inference = { body: this.inference.body || $.inference.body, cookie: this.inference.cookie || $.inference.cookie, headers: this.inference.headers || $.inference.headers, query: this.inference.query || $.inference.query, set: this.inference.set || $.inference.set, server: this.inference.server || $.inference.server };
    }
    this.decorate($.singleton.decorator), this.state($.singleton.store), this.model($.definitions.type), this.error($.definitions.error), $.extender.macros = this.extender.macros.concat($.extender.macros);
    for (let { method: j, path: J, handler: Q, hooks: Y } of Object.values($.router.history))
      this.add(j, J, Q, i(Y, { error: $.event.error }));
    if (!Z)
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const j = X !== undefined ? P0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: J }) => j === J))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((J) => J?.subType === "derive").map((J) => ({ fn: J.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((J) => J?.subType === "resolve").map((J) => ({ fn: J.toString(), stack: new Error().stack ?? "" })) }), this.event = L1(this.event, T1($.event), j);
      } else
        this.event = L1(this.event, T1($.event));
    return this.validator.global = i(this.validator.global, { ...$.validator.global }), this.validator.local = i(this.validator.local, { ...$.validator.scoped }), this;
  }
  macro($) {
    const W = { checksum: P0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ };
    return this.extender.macros.push(W), this;
  }
  mount($, W) {
    if ($ instanceof Q0 || typeof $ === "function" || $.length === 0 || $ === "/") {
      const j = typeof $ === "function" ? $ : $ instanceof Q0 ? $.compile().fetch : W instanceof Q0 ? W.compile().fetch : W, J = async ({ request: Q, path: Y }) => {
        if (Q.method === "GET" || Q.method === "HEAD" || !Q.headers.get("content-type"))
          return j(new Request(b0(Q.url, Y || "/"), Q));
        return j(new Request(b0(Q.url, Y || "/"), { ...Q, body: await Q.arrayBuffer() }));
      };
      return this.all("/*", J, { type: "none" }), this;
    }
    const X = $.length;
    if (W instanceof Q0)
      W = W.compile().fetch;
    const Z = async ({ request: j, path: J }) => {
      if (j.method === "GET" || j.method === "HEAD" || !j.headers.get("content-type"))
        return W(new Request(b0(j.url, J.slice(X) || "/"), j));
      return W(new Request(b0(j.url, J.slice(X) || "/"), { ...j, body: await j.arrayBuffer() }));
    };
    return this.all($, Z, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), Z, { type: "none" }), this;
  }
  get($, W, X) {
    return this.add("GET", $, W, X), this;
  }
  post($, W, X) {
    return this.add("POST", $, W, X), this;
  }
  put($, W, X) {
    return this.add("PUT", $, W, X), this;
  }
  patch($, W, X) {
    return this.add("PATCH", $, W, X), this;
  }
  delete($, W, X) {
    return this.add("DELETE", $, W, X), this;
  }
  options($, W, X) {
    return this.add("OPTIONS", $, W, X), this;
  }
  all($, W, X) {
    return this.add("ALL", $, W, X), this;
  }
  head($, W, X) {
    return this.add("HEAD", $, W, X), this;
  }
  connect($, W, X) {
    return this.add("CONNECT", $, W, X), this;
  }
  route($, W, X, Z) {
    return this.add($.toUpperCase(), W, X, Z, Z?.config), this;
  }
  ws($, W) {
    const X = W.transformMessage ? Array.isArray(W.transformMessage) ? W.transformMessage : [W.transformMessage] : undefined;
    let Z = null;
    const j = m(W?.body, { models: this.definitions.type, normalize: this.config.normalize }), J = m(W?.response, { models: this.definitions.type, normalize: this.config.normalize }), Q = (Y) => {
      if (typeof Y === "string") {
        const K = Y?.charCodeAt(0);
        if (K === 47 || K === 123)
          try {
            Y = JSON.parse(Y);
          } catch {
          }
        else if (j1(Y))
          Y = +Y;
      }
      if (X?.length)
        for (let K = 0;K < X.length; K++) {
          const B = X[K](Y);
          if (B !== undefined)
            Y = B;
        }
      return Y;
    };
    return this.route("$INTERNALWS", $, (Y) => {
      const { set: K, path: B, qi: U, headers: w, query: F, params: G } = Y;
      if (Z === null)
        Z = this.getServer();
      if (Z?.upgrade(Y.request, { headers: typeof W.upgrade === "function" ? W.upgrade(Y) : W.upgrade, data: { validator: J, open(z) {
        W.open?.(new f0(z, Y));
      }, message: (z, D) => {
        const M = Q(D);
        if (j?.Check(M) === false)
          return void z.send(new E("message", j, M).message);
        W.message?.(new f0(z, Y), M);
      }, drain(z) {
        W.drain?.(new f0(z, Y));
      }, close(z, D, M) {
        W.close?.(new f0(z, Y), D, M);
      } } }))
        return;
      return K.status = 400, "Expected a websocket connection";
    }, { beforeHandle: W.beforeHandle, transform: W.transform, headers: W.headers, params: W.params, query: W.query }), this;
  }
  state($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    const { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.store)
            this.singleton.store[W] = c(this.singleton.store[W], X, { override: Z === "override" });
          else
            this.singleton.store[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.store = c(this.singleton.store, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.store))
            this.singleton.store[W] = X;
        } else
          this.singleton.store = X(this.singleton.store);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.store))
          this.singleton.store[W] = X;
        return this;
    }
  }
  decorate($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    const { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.decorator)
            this.singleton.decorator[W] = c(this.singleton.decorator[W], X, { override: Z === "override" });
          else
            this.singleton.decorator[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.decorator = c(this.singleton.decorator, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.decorator))
            this.singleton.decorator[W] = X;
        } else
          this.singleton.decorator = X(this.singleton.decorator);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.decorator))
          this.singleton.decorator[W] = X;
        return this;
    }
  }
  derive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "derive", fn: W };
    return this.onTransform($, X);
  }
  model($, W) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, Z]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = Z;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = W, this;
  }
  mapDerive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "mapDerive", fn: W };
    return this.onTransform($, X);
  }
  affix($, W, X) {
    if (X === "")
      return this;
    const Z = ["_", "-", " "], j = (K) => K[0].toUpperCase() + K.slice(1), J = $ === "prefix" ? (K, B) => Z.includes(K.at(-1) ?? "") ? K + B : K + j(B) : Z.includes(X.at(-1) ?? "") ? (K, B) => B + K : (K, B) => B + j(K), Q = (K) => {
      const B = {};
      switch (K) {
        case "decorator":
          for (let U in this.singleton.decorator)
            B[J(X, U)] = this.singleton.decorator[U];
          this.singleton.decorator = B;
          break;
        case "state":
          for (let U in this.singleton.store)
            B[J(X, U)] = this.singleton.store[U];
          this.singleton.store = B;
          break;
        case "model":
          for (let U in this.definitions.type)
            B[J(X, U)] = this.definitions.type[U];
          this.definitions.type = B;
          break;
        case "error":
          for (let U in this.definitions.error)
            B[J(X, U)] = this.definitions.error[U];
          this.definitions.error = B;
          break;
      }
    }, Y = Array.isArray(W) ? W : [W];
    for (let K of Y.some((B) => B === "all") ? ["decorator", "state", "model", "error"] : Y)
      Q(K);
    return this;
  }
  prefix($, W) {
    return this.affix("prefix", $, W);
  }
  suffix($, W) {
    return this.affix("suffix", $, W);
  }
  compile() {
    if (this.fetch = this.config.aot ? f1(this) : k1(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? f1(this) : k1(this))($);
  };
  handleError = async ($, W) => (this.handleError = this.config.aot ? y1(this) : O2(this))($, W);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, W) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if (!j1($))
        throw new Error("Port must be a numeric value");
      $ = parseInt($);
    }
    const X = this.fetch, Z = typeof $ === "object" ? { development: !l0, reusePort: true, ...this.config.serve || {}, ...$ || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...R1 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !l0, reusePort: true, ...this.config.serve || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...R1 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    this.server = Bun?.serve(Z);
    for (let j = 0;j < this.event.start.length; j++)
      this.event.start[j].fn(this);
    if (W)
      W(this.server);
    return process.on("beforeExit", () => {
      if (this.server) {
        this.server.stop(), this.server = null;
        for (let j = 0;j < this.event.stop.length; j++)
          this.event.stop[j].fn(this);
      }
    }), this.promisedModules.then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async ($) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop($), this.server = null, this.event.stop.length)
        for (let W = 0;W < this.event.stop.length; W++)
          this.event.stop[W].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// src/utils/convertKeys.ts
function convertKeys(obj) {
  if (Array.isArray(obj)) {
    return obj.map((v3) => convertKeys(v3));
  } else if (obj !== null && obj.constructor === Object) {
    return Object.keys(obj).reduce((result, key) => {
      const lowerCase = key.toLowerCase();
      result[lowerCase] = convertKeys(obj[key]);
      return result;
    }, {});
  }
  return obj;
}

// src/utils/saveTofile.ts
var fs = require_lib();
var saveToJson = (data) => {
  const filePath = "stations.json";
  fs.remove(filePath).then(() => {
    return fs.writeJson(filePath, data);
  }).then(() => {
    console.log("File lama dihapus, data baru berhasil disimpan ke stations.json");
  }).catch((err) => {
    console.error("Error saat menghapus atau menyimpan file:", err);
  });
};

// src/routes/chargingStation.ts
var getChargingStation = (app) => {
  app.get("/list-charging-station", async () => {
    try {
      const endpoint = Bun.env.OPEN_CHARGE_MAP_ENDPOINT || "https://api.openchargemap.io/v3/poi/?client=ocm.app.ionic.8.6.1&verbose=false&output=json&includecomments=true&maxresults=500&compact=true&boundingbox=(-15.643672615667683,103.34353043551516),(1.248513186507509,115.90827107059266)";
      const apiKey = Bun.env.OPEN_CHARGE_MAP_X_API_KEY || "9bb03e5b-0fb2-4916-9b2b-26c6bd27a56a";
      const response = await fetch(endpoint, {
        method: "GET",
        headers: {
          "x-api-key": apiKey,
          "Content-Type": "application/json"
        }
      });
      const data = await response.json();
      const filteredData = convertKeys(data);
      const mappedData = filteredData.map((item) => ({
        uuid: item.uuid,
        usageCost: item.usagecost,
        addressInfo: item.addressinfo,
        connections: item.connections
      }));
      saveToJson(mappedData);
      return { message: "Success get charging station list", code: 200, data: mappedData };
    } catch (error3) {
      return { message: "Failed get charging station list", code: 400, error: error3.message };
    }
  });
};
var chargingStation_default = getChargingStation;

// src/config/db.ts
var sdk = require_dist();
var apiKey = Bun.env.APPWRITE_API_KEY || "standard_8e7d0eef6d9f5fdce26c004bcaf14a09102bb3b6af2b36c08cecb0c3ab7a828aee617abf6dded894cf942338d84b9ebcb87dac087f45fb7d529e23ddd27b88d8fc81a63229e7147cf276faa64dc1be053834743cce09dcf214ca966db2c607f418ca80a3d0f19ce2490a6f433c2ea9dd311a87b9e6b60cba1ab45660d4a134f9";
var endPoint = Bun.env.APPWRITE_END_POINT || "https://cloud.appwrite.io/v1";
var projectId = Bun.env.APPWRITE_PROJECT_ID || "66f654140008e57331cd";
var client = new sdk.Client().setEndpoint(endPoint).setProject(projectId).setKey(apiKey);
var databases = new sdk.Databases(client);
var dbUser = new sdk.Users(client);

// node_modules/node-appwrite/dist/client.mjs
init_native();
var import_agent = __toESM(require_agent(), 1);

// node_modules/node-appwrite/dist/query.mjs
var _Query = class _Query2 {
  constructor(method, attribute, values) {
    this.method = method;
    this.attribute = attribute;
    if (values !== undefined) {
      if (Array.isArray(values)) {
        this.values = values;
      } else {
        this.values = [values];
      }
    }
  }
  toString() {
    return JSON.stringify({
      method: this.method,
      attribute: this.attribute,
      values: this.values
    });
  }
};
_Query.equal = (attribute, value2) => new _Query("equal", attribute, value2).toString();
_Query.notEqual = (attribute, value2) => new _Query("notEqual", attribute, value2).toString();
_Query.lessThan = (attribute, value2) => new _Query("lessThan", attribute, value2).toString();
_Query.lessThanEqual = (attribute, value2) => new _Query("lessThanEqual", attribute, value2).toString();
_Query.greaterThan = (attribute, value2) => new _Query("greaterThan", attribute, value2).toString();
_Query.greaterThanEqual = (attribute, value2) => new _Query("greaterThanEqual", attribute, value2).toString();
_Query.isNull = (attribute) => new _Query("isNull", attribute).toString();
_Query.isNotNull = (attribute) => new _Query("isNotNull", attribute).toString();
_Query.between = (attribute, start, end) => new _Query("between", attribute, [start, end]).toString();
_Query.startsWith = (attribute, value2) => new _Query("startsWith", attribute, value2).toString();
_Query.endsWith = (attribute, value2) => new _Query("endsWith", attribute, value2).toString();
_Query.select = (attributes) => new _Query("select", undefined, attributes).toString();
_Query.search = (attribute, value2) => new _Query("search", attribute, value2).toString();
_Query.orderDesc = (attribute) => new _Query("orderDesc", attribute).toString();
_Query.orderAsc = (attribute) => new _Query("orderAsc", attribute).toString();
_Query.cursorAfter = (documentId) => new _Query("cursorAfter", undefined, documentId).toString();
_Query.cursorBefore = (documentId) => new _Query("cursorBefore", undefined, documentId).toString();
_Query.limit = (limit) => new _Query("limit", undefined, limit).toString();
_Query.offset = (offset) => new _Query("offset", undefined, offset).toString();
_Query.contains = (attribute, value2) => new _Query("contains", attribute, value2).toString();
_Query.or = (queries) => new _Query("or", undefined, queries.map((query) => JSON.parse(query))).toString();
_Query.and = (queries) => new _Query("and", undefined, queries.map((query) => JSON.parse(query))).toString();
var Query = _Query;

// node_modules/node-appwrite/dist/client.mjs
function getUserAgent() {
  let ua = "AppwriteNodeJSSDK/14.1.0";
  const platform = [];
  if (typeof process !== "undefined") {
    if (typeof process.platform === "string")
      platform.push(process.platform);
    if (typeof process.arch === "string")
      platform.push(process.arch);
  }
  if (platform.length > 0) {
    ua += ` (${platform.join("; ")})`;
  }
  if (typeof navigator !== "undefined" && typeof navigator.userAgent === "string") {
    ua += ` ${navigator.userAgent}`;
  } else if (typeof globalThis.EdgeRuntime === "string") {
    ua += ` EdgeRuntime`;
  } else if (typeof process !== "undefined" && typeof process.version === "string") {
    ua += ` Node.js/${process.version}`;
  }
  return ua;
}
var AppwriteException = class extends Error {
  constructor(message, code = 0, type3 = "", response = "") {
    super(message);
    this.name = "AppwriteException";
    this.message = message;
    this.code = code;
    this.type = type3;
    this.response = response;
  }
};
var _Client = class _Client2 {
  constructor() {
    this.config = {
      endpoint: "https://cloud.appwrite.io/v1",
      selfSigned: false,
      project: "",
      key: "",
      jwt: "",
      locale: "",
      session: "",
      forwardeduseragent: ""
    };
    this.headers = {
      "x-sdk-name": "Node.js",
      "x-sdk-platform": "server",
      "x-sdk-language": "nodejs",
      "x-sdk-version": "14.1.0",
      "user-agent": getUserAgent(),
      "X-Appwrite-Response-Format": "1.6.0"
    };
  }
  setEndpoint(endpoint) {
    this.config.endpoint = endpoint;
    return this;
  }
  setSelfSigned(selfSigned) {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      console.warn("setSelfSigned is not supported in edge runtimes.");
    }
    this.config.selfSigned = selfSigned;
    return this;
  }
  addHeader(header, value2) {
    this.headers[header.toLowerCase()] = value2;
    return this;
  }
  setProject(value2) {
    this.headers["X-Appwrite-Project"] = value2;
    this.config.project = value2;
    return this;
  }
  setKey(value2) {
    this.headers["X-Appwrite-Key"] = value2;
    this.config.key = value2;
    return this;
  }
  setJWT(value2) {
    this.headers["X-Appwrite-JWT"] = value2;
    this.config.jwt = value2;
    return this;
  }
  setLocale(value2) {
    this.headers["X-Appwrite-Locale"] = value2;
    this.config.locale = value2;
    return this;
  }
  setSession(value2) {
    this.headers["X-Appwrite-Session"] = value2;
    this.config.session = value2;
    return this;
  }
  setForwardedUserAgent(value2) {
    this.headers["X-Forwarded-User-Agent"] = value2;
    this.config.forwardeduseragent = value2;
    return this;
  }
  prepareRequest(method, url, headers = {}, params = {}) {
    method = method.toUpperCase();
    headers = Object.assign({}, this.headers, headers);
    let options = {
      method,
      headers,
      ...import_agent.createAgent(this.config.endpoint, { rejectUnauthorized: !this.config.selfSigned })
    };
    if (method === "GET") {
      for (const [key, value2] of Object.entries(_Client2.flatten(params))) {
        url.searchParams.append(key, value2);
      }
    } else {
      switch (headers["content-type"]) {
        case "application/json":
          options.body = JSON.stringify(params);
          break;
        case "multipart/form-data":
          const formData = new a;
          for (const [key, value2] of Object.entries(params)) {
            if (value2 instanceof o3) {
              formData.append(key, value2, value2.name);
            } else if (Array.isArray(value2)) {
              for (const nestedValue of value2) {
                formData.append(`${key}[]`, nestedValue);
              }
            } else {
              formData.append(key, value2);
            }
          }
          options.body = formData;
          delete headers["content-type"];
          break;
      }
    }
    return { uri: url.toString(), options };
  }
  async chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {
    const file = Object.values(originalPayload).find((value2) => value2 instanceof o3);
    if (file.size <= _Client2.CHUNK_SIZE) {
      return await this.call(method, url, headers, originalPayload);
    }
    let start = 0;
    let response = null;
    while (start < file.size) {
      let end = start + _Client2.CHUNK_SIZE;
      if (end >= file.size) {
        end = file.size;
      }
      headers["content-range"] = `bytes ${start}-${end - 1}/${file.size}`;
      const chunk = file.slice(start, end);
      let payload = { ...originalPayload, file: new o3([chunk], file.name) };
      response = await this.call(method, url, headers, payload);
      if (onProgress && typeof onProgress === "function") {
        onProgress({
          $id: response.$id,
          progress: Math.round(end / file.size * 100),
          sizeUploaded: end,
          chunksTotal: Math.ceil(file.size / _Client2.CHUNK_SIZE),
          chunksUploaded: Math.ceil(end / _Client2.CHUNK_SIZE)
        });
      }
      if (response && response.$id) {
        headers["x-appwrite-id"] = response.$id;
      }
      start = end;
    }
    return response;
  }
  async redirect(method, url, headers = {}, params = {}) {
    const { uri, options } = this.prepareRequest(method, url, headers, params);
    const response = await l(uri, {
      ...options,
      redirect: "manual"
    });
    if (response.status !== 301 && response.status !== 302) {
      throw new AppwriteException("Invalid redirect", response.status);
    }
    return response.headers.get("location") || "";
  }
  async call(method, url, headers = {}, params = {}, responseType = "json") {
    var _a;
    const { uri, options } = this.prepareRequest(method, url, headers, params);
    let data = null;
    const response = await l(uri, options);
    const warnings = response.headers.get("x-appwrite-warning");
    if (warnings) {
      warnings.split(";").forEach((warning) => console.warn("Warning: " + warning));
    }
    if ((_a = response.headers.get("content-type")) == null ? undefined : _a.includes("application/json")) {
      data = await response.json();
    } else if (responseType === "arrayBuffer") {
      data = await response.arrayBuffer();
    } else {
      data = {
        message: await response.text()
      };
    }
    if (400 <= response.status) {
      throw new AppwriteException(data == null ? undefined : data.message, response.status, data == null ? undefined : data.type, data);
    }
    return data;
  }
  static flatten(data, prefix = "") {
    let output = {};
    for (const [key, value2] of Object.entries(data)) {
      let finalKey = prefix ? prefix + "[" + key + "]" : key;
      if (Array.isArray(value2)) {
        output = { ...output, ..._Client2.flatten(value2, finalKey) };
      } else {
        output[finalKey] = value2;
      }
    }
    return output;
  }
};
_Client.CHUNK_SIZE = 1024 * 1024 * 5;
// node_modules/node-appwrite/dist/permission.mjs
var Permission = class {
};
Permission.read = (role) => {
  return `read("${role}")`;
};
Permission.write = (role) => {
  return `write("${role}")`;
};
Permission.create = (role) => {
  return `create("${role}")`;
};
Permission.update = (role) => {
  return `update("${role}")`;
};
Permission.delete = (role) => {
  return `delete("${role}")`;
};
// node_modules/node-appwrite/dist/id.mjs
var ID = class _ID {
  static #hexTimestamp() {
    const now = /* @__PURE__ */ new Date;
    const sec = Math.floor(now.getTime() / 1000);
    const msec = now.getMilliseconds();
    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, "0");
    return hexTimestamp;
  }
  static custom(id) {
    return id;
  }
  static unique(padding = 7) {
    const baseId = _ID.#hexTimestamp();
    let randomPadding = "";
    for (let i4 = 0;i4 < padding; i4++) {
      const randomHexDigit = Math.floor(Math.random() * 16).toString(16);
      randomPadding += randomHexDigit;
    }
    return baseId + randomPadding;
  }
};
// src/utils/verifyPassword.ts
async function verifyPassword(hash3, plainPassword) {
  try {
    if (await argon2.verify(hash3, plainPassword)) {
      console.log("Password matches");
      return true;
    } else {
      console.log("Password does not match");
      return false;
    }
  } catch (err) {
    console.error("Error verifying password:", err);
    return false;
  }
}
var argon2 = require_argon2();

// src/middleware/userMiddleware.ts
var getAllUser = (app, url) => {
  app.get(url, async (req) => {
    try {
      const { users } = await dbUser.list();
      const mappedUsers = users.map((user) => ({
        id: user.$id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        isLogin: user?.prefs?.isLogin ?? false
      }));
      return {
        message: "Succesfully get all users",
        code: 200,
        data: mappedUsers
      };
    } catch (error3) {
      return {
        message: "Failed to create user",
        code: 400,
        error: error3.message
      };
    }
  });
};
var createUser = (app, url) => {
  app.post(url, async (req) => {
    try {
      const { email, password, name, phone } = req.body;
      const { users } = await dbUser.list();
      const filterData = users.filter((item) => item?.email === email);
      if (filterData.length > 0) {
        return {
          message: "User was registered",
          code: 400,
          data: { email }
        };
      }
      const userCreate = await dbUser.create(ID.unique(), email, phone, password, name);
      await dbUser.updatePrefs(userCreate.$id, {
        isLogin: false
      });
      return {
        message: "User created successfully",
        code: 200,
        data: userCreate
      };
    } catch (error3) {
      return {
        message: "Failed to create user",
        code: 400,
        error: error3.message
      };
    }
  });
};
var login = (app, url) => {
  app.put(url, async (req) => {
    try {
      const { email, password } = req.body;
      const { users } = await dbUser.list([Query.equal("email", email)]);
      const isPasswordMatch = await verifyPassword(users[0].password, password);
      const mappedUser = users.map((user) => ({
        id: user.$id,
        name: user.name,
        email: user.email,
        phone: user.phone
      }));
      if (isPasswordMatch && email === mappedUser[0].email) {
        const result = await dbUser.updatePrefs(mappedUser[0].id, {
          isLogin: true
        });
        return {
          message: "Login successfull",
          code: 200,
          data: result
        };
      }
      return {
        message: "User not registered",
        code: 400,
        error: { email }
      };
    } catch (error3) {
      return {
        message: "Failed to login",
        code: 400,
        error: error3.message
      };
    }
  });
};
var logout = (app, url) => {
  app.put(url, async (req) => {
    try {
      const { id } = req.body;
      const result = await dbUser.updatePrefs(id, {
        isLogin: false
      });
      return {
        message: "Logout successfull",
        code: 200,
        data: result
      };
    } catch (error3) {
      return {
        message: "Failed to login",
        code: 400,
        error: error3.message
      };
    }
  });
};
var deleteUser = (app, url) => {
  app.delete(url, async (req) => {
    try {
      const { id } = req.body;
      const deleteUser2 = await dbUser.delete(id);
      return {
        message: "User deleted",
        code: 200,
        data: deleteUser2
      };
    } catch (error3) {
      return {
        message: "Failed to delete user",
        code: 400,
        error: error3.message
      };
    }
  });
};

// src/routes/user.ts
var user = (app) => {
  getAllUser(app, "/users");
  createUser(app, "/register");
  login(app, "/login");
  logout(app, "/logout");
  deleteUser(app, "/delete-user");
};
var user_default = user;

// src/middleware/carMiddleware.ts
var carCollectionID = "car";
var getAllCar = (app, url) => {
  app.get(url, async (req) => {
    try {
      const response = await databases.listDocuments(Bun.env.APPWRITE_DATABASE_ID, carCollectionID);
      return {
        message: "Succesfully get all cars",
        code: 200,
        data: response.documents
      };
    } catch (error3) {
      return {
        message: "Failed to get all cars",
        code: 400,
        error: error3.message
      };
    }
  });
};
var addNewCar = (app, url) => {
  app.post(url, async (req) => {
    try {
      const { name, powerKw } = req.body;
      const lowerName = name.toLowerCase();
      let response;
      let promise3 = await databases.listDocuments(Bun.env.APPWRITE_DATABASE_ID, carCollectionID, [
        Query.equal("name", lowerName)
      ]);
      if (promise3.total > 0) {
        return {
          message: "Car already registered",
          code: 200,
          data: promise3
        };
      }
      response = await databases.createDocument(Bun.env.APPWRITE_DATABASE_ID, carCollectionID, ID.unique(), {
        name: lowerName,
        powerKw
      });
      return {
        message: "Succesfully add new car",
        code: 200,
        data: response
      };
    } catch (error3) {
      return {
        message: "Failed to get all cars",
        code: 400,
        error: error3.message
      };
    }
  });
};
var deleteCar = (app, url) => {
  app.delete(url, async (req) => {
    try {
      const { id } = req.body;
      const promise3 = await databases.deleteDocument(Bun.env.APPWRITE_DATABASE_ID, carCollectionID, id);
      return {
        message: "Succesfully delete car",
        code: 200,
        data: promise3
      };
    } catch (error3) {
      return {
        message: "Failed to delete car",
        code: 400,
        error: error3.message
      };
    }
  });
};

// src/routes/car.ts
var car = (app) => {
  getAllCar(app, "/cars");
  addNewCar(app, "/car");
  deleteCar(app, "/delete-car");
};
var car_default = car;

// src/middleware/carUserMiddleware.ts
var carUserCollectionID = "user-car";
var addCar = (app, url) => {
  app.post(url, async (req) => {
    try {
      const { user_id, car_id } = req.body;
      console.log("\uD83D\uDE80 ~ app.post ~ req.body:", req.body);
      const response = await databases.createDocument(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID, ID.unique(), { user_id, car_id });
      return { message: "Car added successfully", code: 200, data: response.documents };
    } catch (error3) {
      return { message: "Failed to add car", code: 400, error: error3.message };
    }
  });
};
var getListAllUserCar = (app, url) => {
  app.get(url, async (req) => {
    try {
      const res = await databases.listDocuments(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID, [
        Query.select(["$id", "user_id", "car_id"])
      ]);
      return {
        message: "Suceess get all car",
        code: 200,
        data: res
      };
    } catch (error3) {
      return {
        message: "Suceess get all car",
        code: 200,
        data: error3.message
      };
    }
  });
};
var deleteUserCar = (app, url) => {
  app.delete(url, async (req) => {
    try {
      const { id } = req.body;
      const res = await databases.deleteDocument(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID, id);
      return {
        message: "Succesfully delete car",
        code: 200,
        data: res
      };
    } catch (error3) {
      return {
        message: "Failed to delete car",
        code: 400,
        error: error3.message
      };
    }
  });
};
var getCarByUserId = (app, url) => {
  app.post(url, async (req) => {
    try {
      const { user_id } = req.body;
      const res = await databases.listDocuments(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID, [
        Query.equal("user_id", user_id),
        Query.select(["$id", "user_id", "car_id"])
      ]);
      console.log("\uD83D\uDE80 ~ app.post ~ res:", res);
      return {
        message: "Succesfully delete car",
        code: 200,
        data: res
      };
    } catch (error3) {
      return {
        message: "Failed to delete car",
        code: 400,
        error: error3.message
      };
    }
  });
};

// src/routes/userCar.ts
var userCar = (app) => {
  addCar(app, "/add-user-car");
  getListAllUserCar(app, "/list-all-user-car");
  deleteUserCar(app, "/delete-user-car");
  getCarByUserId(app, "/list-user-car");
};
var userCar_default = userCar;

// src/middleware/favoriteMiddleware.ts
var carUserCollectionID2 = "user-favorite";
var addNewFavorite = (app, url) => {
  app.post(url, async (req) => {
    try {
      const { user_id, station_id } = req.body;
      const response = await databases.createDocument(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID2, ID.unique(), { user_id, station_id });
      return { message: "Success add to favorite", code: 200, data: response.documents };
    } catch (error3) {
      return { message: "Failed add to favorite", code: 400, error: error3.message };
    }
  });
};
var getListAllFavorite = (app, url) => {
  app.get(url, async (req) => {
    try {
      const res = await databases.listDocuments(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID2, [
        Query.select(["$id", "user_id", "station_id"])
      ]);
      return {
        message: "Suceess get all favorite",
        code: 200,
        data: res
      };
    } catch (error3) {
      return {
        message: "Failed get all favorite",
        code: 400,
        data: error3.message
      };
    }
  });
};
var deleteFavorite = (app, url) => {
  app.delete(url, async (req) => {
    try {
      const { id } = req.body;
      const res = await databases.deleteDocument(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID2, id);
      return {
        message: "Succesfully remove from favorite",
        code: 200,
        data: res
      };
    } catch (error3) {
      return {
        message: "Failed to remove from favorite",
        code: 400,
        error: error3.message
      };
    }
  });
};
var getFavoriteByUserId = (app, url) => {
  app.post(url, async (req) => {
    try {
      const { user_id } = req.body;
      const res = await databases.listDocuments(Bun.env.APPWRITE_DATABASE_ID, carUserCollectionID2, [
        Query.equal("user_id", user_id),
        Query.select(["$id", "user_id", "station_id"])
      ]);
      return {
        message: "Succesfully get list favorite",
        code: 200,
        data: res
      };
    } catch (error3) {
      return {
        message: "Failed to get list favorite",
        code: 400,
        error: error3.message
      };
    }
  });
};

// src/routes/userFavorite.ts
var userFavorite = (app) => {
  addNewFavorite(app, "/add-new-favorite");
  deleteFavorite(app, "/delete-favorite");
  getFavoriteByUserId(app, "/list-favorite");
  getListAllFavorite(app, "/list-all-favorite");
};
var userFavorite_default = userFavorite;

// src/index.ts
var app = new Q0;
chargingStation_default(app);
user_default(app);
car_default(app);
userCar_default(app);
userFavorite_default(app);
app.listen(3000);
console.log("-------------  Welcome  -------------");
console.log("=== Server Running on http://localhost:3000 ===");
export {
  app
};
